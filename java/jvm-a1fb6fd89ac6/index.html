

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/logo.png">
  <link rel="icon" href="/img/logo.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Ocsio">
  <meta name="keywords" content="java">
  
    <meta name="description" content="JVM 基础">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM 基础">
<meta property="og:url" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/index.html">
<meta property="og:site_name" content="Ocsio">
<meta property="og:description" content="JVM 基础">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/image-20240118102353745.png">
<meta property="og:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/image-20231103152951178.png">
<meta property="og:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/image-20231103153702802.png">
<meta property="og:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/image-20231103160850095.png">
<meta property="og:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/image-20231103163823441.png">
<meta property="og:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/image-20231103203406741.png">
<meta property="og:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4.gif">
<meta property="og:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/image-20231103211356306.png">
<meta property="og:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/image-20231103221655754.png">
<meta property="og:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/image-20231103222511779.png">
<meta property="og:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/image-20231103225856543.png">
<meta property="og:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/image-20231103233124594.png">
<meta property="og:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/image-20231103233056536.png">
<meta property="og:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/image-20231103235430273.png">
<meta property="og:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/image-20231104083658269.png">
<meta property="og:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/image-20231104084438278.png">
<meta property="og:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/image-20231104085854546.png">
<meta property="og:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/image-20231104093541460.png">
<meta property="og:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/image-20240118103441563.png">
<meta property="og:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/image-20231104100111868.png">
<meta property="og:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/image-20231104101950889.png">
<meta property="og:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/image-20240118103719423.png">
<meta property="og:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6.gif">
<meta property="og:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/image-20231104105410974.png">
<meta property="og:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/image-20240121140456494.png">
<meta property="og:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/image-20231104150131878.png">
<meta property="og:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/image-20231104150444606.png">
<meta property="og:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/image-20231104150850892.png">
<meta property="og:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/image-20231104152357045.png">
<meta property="og:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/image-20240121140756638.png">
<meta property="og:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/image-20240121141013535.png">
<meta property="og:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/image-20231104160924602.png">
<meta property="og:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/image-20231104161333899.png">
<meta property="og:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/image-20231104162050780.png">
<meta property="og:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/image-20231104162134953.png">
<meta property="og:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/image-20231104162627465.png">
<meta property="og:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/image-20240121141321115.png">
<meta property="og:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/image-20231104170923678.png">
<meta property="og:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/image-20240121141549362.png">
<meta property="og:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/image-20231104203312875.png">
<meta property="og:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/image-20231104204559115.png">
<meta property="og:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/image-20231104205457240.png">
<meta property="og:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/image-20231104211342232.png">
<meta property="og:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/image-20240121142220376.png">
<meta property="og:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/image-20231104214126404.png">
<meta property="og:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/image-20231104220843375.png">
<meta property="og:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/image-20231104224349006.png">
<meta property="og:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/image-20231104230352005.png">
<meta property="og:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/image-20230707140735001.png">
<meta property="og:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/image-20230707140844654.png">
<meta property="og:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/image-20230707141002927.png">
<meta property="og:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/image-20240121143406072.png">
<meta property="og:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/image-20240121143515843.png">
<meta property="og:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/image-20231105091535983.png">
<meta property="og:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/image-20231105091803795.png">
<meta property="og:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/image-20230707143335506.png">
<meta property="og:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/image-20230707143512479.png">
<meta property="og:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/image-20230707143856544.png">
<meta property="og:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/image-20230707143953741.png">
<meta property="og:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/image-20231105092409968.png">
<meta property="og:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/image-20231105092846027.png">
<meta property="og:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/image-20231105092710615.png">
<meta property="og:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/image-20230707145459334.png">
<meta property="og:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/image-20231105113034737.png">
<meta property="og:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/image-20240121143829523.png">
<meta property="og:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/image-20231105133903469.png">
<meta property="og:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/image-20231105151612757.png">
<meta property="og:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/image-20231105154044849.png">
<meta property="og:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/image-20231105154519274.png">
<meta property="og:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/image-20231105154712603.png">
<meta property="og:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/image-20240121144524842.png">
<meta property="og:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/image-20240121145047629.png">
<meta property="og:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/image-20240121145242442.png">
<meta property="og:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/image-20231105172016426.png">
<meta property="og:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/image-20231105175018931.png">
<meta property="og:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/image-20231105180718625.png">
<meta property="og:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/image-20231105181512385.png">
<meta property="og:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/image-20231105175646598.png">
<meta property="og:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/image-20231105181853219.png">
<meta property="og:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/image-20230708154652640.png">
<meta property="og:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/image-20240121145637502.png">
<meta property="article:published_time" content="2023-12-30T08:11:00.000Z">
<meta property="article:modified_time" content="2024-01-21T06:58:14.256Z">
<meta property="article:author" content="Ocsio">
<meta property="article:tag" content="java">
<meta property="article:tag" content="jvm">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://ocsio.cn/java/jvm-a1fb6fd89ac6/image-20240118102353745.png">
  
  
  
  <title>JVM 基础 - Ocsio</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"ocsio.cn","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"JAVA"},"copy_btn":true,"image_caption":{"enable":false},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Ocsio</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/" target="_self">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/background.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="JVM 基础"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-12-30 16:11" pubdate>
          2023年12月30日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          31k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          262 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">JVM 基础</h1>
            
            
              <div class="markdown-body">
                
                <h1>JVM 基础</h1>
<h2 id="引言">引言</h2>
<h3 id="1-什么是-JVM">1. 什么是 JVM</h3>
<p>定义：Java Virtual Machine（Java 虚拟机），是 Java 程序的运行环境（Java  二进制字节码的运行环境）</p>
<p>JVM 的本质是一个运行在计算机上的程序，它的职责是 <strong>运行 Java 字节码文件</strong>。</p>
<p>比较：JVM、JRE（Java Runtime Environment）、JDK（Java Development Kit）</p>
<p><img src="/java/jvm-a1fb6fd89ac6/image-20240118102353745.png" srcset="/img/loading.gif" lazyload alt="JVM vs JRE vs JDK"></p>
<p>其中，</p>
<ul>
<li><strong>基础类库</strong> 指的是 Java 的一些基础类，例如 IO 类、集合类、线程类、日期类等。</li>
<li><strong>编译工具</strong> 指的是像 Javac、Javap、内存监测工具这些 Java 编译工具。</li>
<li><strong>应用服务器</strong> 就是像 tomcat 这样的服务器。</li>
<li><strong>IDE</strong> 就是像 vscode、Idea 这样的集成开发环境。</li>
</ul>
<h3 id="2-JVM-的功能">2. JVM 的功能</h3>
<h4 id="2-1-解释和运行">2.1 解释和运行</h4>
<p>对字节码中的指令，实时的解释为机器码，让计算机执行。</p>
<p>我们平时编写的 .java 文件，会经过 javac 编译为 .class 字节码文件，将其交由 JVM 解释运行，其中字节码文件中包含了一连串的指令，即字节码指令，这些指令需要转换为机器码才能交给计算机执行，而转换机器码的过程就是 <strong>解释</strong>。</p>
<h4 id="2-2-内存管理">2.2 内存管理</h4>
<p>自动为对象、方法分配内存，自动垃圾回收机制，回收不再使用的对象。</p>
<p>对比于 C/C++，Java 的一个优势在于 JVM 会自动的帮助我们为对象分配内存，同时将不用的对象经过垃圾回收机制回收掉。</p>
<h4 id="2-3-即时编译">2.3 即时编译</h4>
<p>对热点代码进行优化，提升执行效率。对于 Java 程序来说，即时编译是提升 Java 程序性能的最核心的手段。</p>
<p>Java 语言需要将字节码指令实时的通过 JVM 解释为机器码，才能交给计算机执行，这个过程随着程序的执行需要反复的进行，所以每一次都会花费一定的时间。</p>
<p>而 C/C++ 在编译过程直接将源代码转换为机器码，省去了解释的过程，这样的话，Java 程序的性能就不如 C/C++。</p>
<p>而为了保证跨平台的特性，Java 不得不这样做，所以在 Jdk 1.1 版本中就推出了 <strong>即时编译</strong> 来提升性能。</p>
<blockquote>
<p>跨平台特性：</p>
<ul>
<li>将一份字节码指令交给不同的平台，在这些平台上安装不同的 JVM，分别将这份字节码指令解释为当前平台的机器码，就可以交给不同平台的操作系统执行。</li>
</ul>
</blockquote>
<p>即时编译具体的做法是，</p>
<ul>
<li>现在有一份字节码文件，里面的某段字节码指令，如果 JVM 发现这段指令是热点代码（很短的时间内被多次调用），则认为这段代码有必要优化。</li>
<li>于是 JVM 将该段代码解释为机器码，并将该机器码保存在内存中，当后面执行相同的代码时，直接从内存中调用该机器码，这样省略了解释的步骤，提升了性能。</li>
</ul>
<h3 id="3-常见的-JVM">3. 常见的 JVM</h3>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html">Java® 虚拟机规范（oracle.com）</a></p>
</blockquote>
<p>对于一款 Java 虚拟机，必须遵守 Oracle 制定的 Java 虚拟机的规范。具体，</p>
<ul>
<li>字节码文件的定义。</li>
<li>类和接口的加载和初始化。</li>
<li>指令集。</li>
</ul>
<p>此外，Java 虚拟机不仅限于 Java 使用，现在像 Groovy、Scale 这样语言只能能够编译成满足规范的 .class 文件，同一能够借助于 Java 虚拟机来运行，这也体现了虚拟机的 <strong>标准化、灵活性</strong>。</p>
<p><strong>常见的 JVM</strong></p>
<p><img src="/java/jvm-a1fb6fd89ac6/image-20231103152951178.png" srcset="/img/loading.gif" lazyload alt="常见的 JVM"></p>
<h2 id="JVM-组成">JVM 组成</h2>
<p><img src="/java/jvm-a1fb6fd89ac6/image-20231103153702802.png" srcset="/img/loading.gif" lazyload alt="JVM 组成"></p>
<p>从 Java 源文件经过 javac 编译后的 <strong>字节码文件</strong> 开始，</p>
<ol>
<li>首先该字节码文件的来源有多种，比如从磁盘读取、从网络传输，JVM 需要把这些文件中的内容加载到内存中，后续使用才会比较高效，这个过程由 **类加载器（ClassLoader）**来实现。</li>
<li>那么 JVM 理所应当要准备一块内存去存放这些字节码文件中的类和接口，如果要创建对象，还要为这些对象申请内存，所以这块存放类、对象的内存区域就叫做 <strong>运行时数据区域</strong>，本质上它就是 JVM 所管理的内存。</li>
<li>最后应该执行字节码文件中的指令，也就是执行代码，所以将文件中的类和接口被加载到内存之后，JVM 就要使用 <strong>执行引擎</strong> 执行代码，需要将字节码指令解释成机器码，同时还要使用 <strong>即时编译（JIT）</strong> 优化性能，有些对象不再使用了，还要使用 <strong>垃圾回收器</strong> 来回收对象。</li>
<li>还有一个组件叫做本地接口，Java 虚拟机像 HotSport，使用 C++ 语言来编写，所以 Java 程序在运行时需要调用底层虚拟机实现的用 C++ 编写的方法（比如用 native 修饰的方法），这些方法在字节码文件中不存在，将它统称为本地接口，执行引擎会负责本地接口的调用，同时本地接口也会去创建对象。</li>
</ol>
<h2 id="字节码文件">字节码文件</h2>
<h3 id="1-概述">1. 概述</h3>
<p>在字节码文件中，主要包含 5 部分内容，</p>
<ol>
<li>基础信息：魔术版本号、访问标志、包含的父类、实现的接口。</li>
<li>常量池：字符串常量、类或接口名、字段名，主要在字节码指令中使用。</li>
<li>字段：源代码中类和接口的字段信息。</li>
<li>方法：源代码中类和接口的方法信息，以及方法转换的字节码指令。</li>
<li>属性：类的属性，可以理解为类的元信息，比如源码的文件名、内部类的列表等。</li>
</ol>
<p>下面我们将以下面的代码为例，详细说明上面的内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.aman;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hello</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello World&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a + b;<br>        System.out.println(<span class="hljs-string">&quot;c = &quot;</span> + c);<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="2-基础信息">2. 基础信息</h3>
<p><img src="/java/jvm-a1fb6fd89ac6/image-20231103160850095.png" srcset="/img/loading.gif" lazyload alt="基础信息"></p>
<p>在一般信息中，包含了，</p>
<ol>
<li>主次版本号，即编译该字节码的 JVM 版本</li>
<li>计数（常量池、接口、字段、方法、属性计数）</li>
<li>访问标志</li>
<li>本类和父类的索引（链接到常量池）</li>
</ol>
<h4 id="2-1-魔术">2.1 魔术</h4>
<p>所有的字节码文件的前四个字节就是魔数，魔数的固定值为：0xCAFEBABE。魔数放在字节码文件开头，JVM 可以根据文件的开头来判断这个文件是否是一个字节码文件，若是，才会继续进行后续的操作。</p>
<h4 id="2-2-主次版本号">2.2 主次版本号</h4>
<p>主次版本号指的是编译字节码文件的 JDK 版本号，其中，</p>
<ul>
<li>主版本号用于标识大版本。</li>
<li>次版本号是当主版本号相同时作为区分不同版本的标识。</li>
</ul>
<p>JDK 1.0 ~ 1.1 使用 45.0 ~ 45.3，之后每升级一个大版本则主版本号加 1，所以在 JDK 1.2 后，大版本号的计算方法是 <strong>主版本号 - 44</strong>。</p>
<p>版本号主要的作用：判断当前字节码的版本和运行时的 JDK （即 JRE）是否兼容。</p>
<p>如，现在启动的是 JDK 7 的环境，想要运行一个 JDK 17 的字节码文件，当然是不行的，在加载过程就会报错。</p>
<h4 id="2-3-访问标志">2.3 访问标志</h4>
<p>描述该 Class 是类还是接口，以及是否被 public、abstract、final 等修饰符修饰。JVM 规范规定了如下表的访问标志（Access_Flag）。</p>
<table>
<thead>
<tr>
<th>Flag Name</th>
<th>Value</th>
<th>Interpretation</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ACC_PUBLIC</code></td>
<td>0x0001</td>
<td>public</td>
</tr>
<tr>
<td><code>ACC_FINAL</code></td>
<td>0x0010</td>
<td>final</td>
</tr>
<tr>
<td><code>ACC_SUPER</code></td>
<td>0x0020</td>
<td>略</td>
</tr>
<tr>
<td><code>ACC_INTERFACE</code></td>
<td>0x0200</td>
<td>接口</td>
</tr>
<tr>
<td><code>ACC_ABSTRACT</code></td>
<td>0x0400</td>
<td>abstract</td>
</tr>
<tr>
<td><code>ACC_SYNTHETIC</code></td>
<td>0x1000</td>
<td>略</td>
</tr>
<tr>
<td><code>ACC_ANNOTATION</code></td>
<td>0x2000</td>
<td>注解类型</td>
</tr>
<tr>
<td><code>ACC_ENUM</code></td>
<td>0x4000</td>
<td>枚举类型</td>
</tr>
</tbody>
</table>
<p>JVM 并没有穷举所有的访问标志，而是使用按位或操作来进行描述的</p>
<ul>
<li>如某个类的修饰符为 public final，则对应的访问修饰符的值为 ACC_PUBLIC | ACC_FINAL，即 0x0001 | 0x0010 = 0x0011。</li>
<li>字节码文件中 <strong>字段</strong> 和 <strong>方法</strong> 的访问标志与上述类似。</li>
</ul>
<h3 id="3-常量池">3. 常量池</h3>
<p>字节码文件中常量池的作用：可以避免相同的内容重复定义，以节省空间。主要存储两部分内容，</p>
<ol>
<li>字面量：源代码中声明为 final 的常量值。</li>
<li>符号引用：如类和接口的全限定名、字段的名称和描述符、方法的名称和描述符。</li>
</ol>
<p>注意，由于常量的个数是不固定的，所以需要在常量池前面预留两个字节表示常量池中常量个数（常量池计数器）</p>
<h3 id="4-字段">4. 字段</h3>
<p><img src="/java/jvm-a1fb6fd89ac6/image-20231103163823441.png" srcset="/img/loading.gif" lazyload alt="字段"></p>
<p>字段很简单，就是存储源代码中类、接口中的字段名称、描述符、访问标志。</p>
<h3 id="5-方法">5. 方法</h3>
<p><img src="/java/jvm-a1fb6fd89ac6/image-20231103203406741.png" srcset="/img/loading.gif" lazyload alt="方法"></p>
<p>方法就是源代码中的类和接口中声明的方法信息存放在了字节码文件里，但此时类和接口中的方法已经被编译为字节码指令。</p>
<p>每个方法中有 3 个部分，</p>
<ol>
<li>“Code” 区：源代码对应的字节码指令，在进行字节码增强时重点操作的区域。
<ul>
<li>在 “Code” 区中除了字节码指令，还有异常表，在处理异常的时候使用。</li>
<li>还记录操作数栈的最大深度，局部变量最大槽数（即局部变量的个数），以及字节码指令的总行数（字节码长度）。</li>
</ul>
</li>
<li>“LineNumberTable”：行号表，将 Code 区的操作码与源代码中的行号对应，主要用于 Debug（决定了当源代码执行一行，JVM 指令执行多少行）</li>
<li>“LocalVariableTable”：本地变量表，实质是一个数组，
<ul>
<li>对于非静态方法，索引 0 号位置默认为 this（所以在方法内部可以使用 this），接着是方法参数，最后是方法内的局部变量。</li>
<li>对于静态方法，由于不能使用 this，所以首先是方法参数，最后是方法内的局部变量。</li>
</ul>
</li>
</ol>
<p>那么下面重点关注字节码指令。以下面的代码为例，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.aman;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Method</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        i = i++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>其编译后的字节码指令为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">0</span> iconst_0<br><span class="hljs-number">1</span> istore_1<br><span class="hljs-number">2</span> iload_1<br><span class="hljs-number">3</span> iinc <span class="hljs-number">1</span> by <span class="hljs-number">1</span><br><span class="hljs-number">6</span> istore_1<br><span class="hljs-number">7</span> <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure>
<p>上面各个指令的含义：</p>
<ul>
<li>iconst_0：将常量 0 压入操作数栈。</li>
<li>istore_1：弹出当前操作数栈顶元素，存储在当前栈帧中，局部变量表 1 号索引处。</li>
<li>iload_1：将当前栈帧中，局部变量表 1 号索引处的元素 <strong>拷贝</strong> 到操作数栈。</li>
<li>iinc 1 by 1：将局部变量表中 1 号索引处的元素加 1</li>
<li>return：返回</li>
</ul>
<p>图示：</p>
<p><img src="/java/jvm-a1fb6fd89ac6/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4.gif" srcset="/img/loading.gif" lazyload alt="字节码指令"></p>
<blockquote>
<p>字节码指令的查看：</p>
<ol>
<li>使用 jclasslib Bytecode Viewer 插件，右键指令后点击 “显示 JVM 规范” 会自动跳转到指令详情页面。</li>
<li>在 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html">Java 虚拟机规范</a> 中查看</li>
</ol>
</blockquote>
<h3 id="6-属性">6. 属性</h3>
<p><img src="/java/jvm-a1fb6fd89ac6/image-20231103211356306.png" srcset="/img/loading.gif" lazyload alt="属性"></p>
<p>属性很简单，就是存储源代码的名称、内部类列表等。</p>
<h3 id="7-查看字节码的工具">7. 查看字节码的工具</h3>
<p>1）上面所使用到的 Idea 插件：jclasslib Bytecode Viewer</p>
<p>2）Java 自带的工具 javap，可以通过控制台查看字节码文件的内容，适合在服务器上查看字节码文件。</p>
<ul>
<li>可以通过 <code>javap -help</code> 查看该命令的参数，一般使用 <code>javap -v</code> 即可。</li>
<li>需要先将 .java 源文件经过 javac 编译为 .class 文件，才能使用 javap 反编译。</li>
</ul>
<p>3）通过 arthas 获取正在运行时的字节码文件</p>
<blockquote>
<p>arthas  官网：<a target="_blank" rel="noopener" href="https://arthas.aliyun.com/">arthas（aliyun.com）</a></p>
</blockquote>
<ul>
<li>使用 dump 命令将 JVM 中实际运行的 class 的字节码信息 dump 到指定目录，再使用 javap 将其反编译即可。</li>
<li>使用 jad 将 JVM 中实际运行的 class 的字节码反编译为 Java 代码（可能存在语法错误，但不影响阅读）。</li>
</ul>
<h2 id="类加载器">类加载器</h2>
<h3 id="1-类的生命周期">1. 类的生命周期</h3>
<h4 id="1-1-概述">1.1 概述</h4>
<p>类的生命周期描述了一个类从加载、使用、卸载的全过程。</p>
<p>主要包含 5 个阶段：</p>
<ol>
<li>加载（Loading）</li>
<li>连接（Linking），可细分为 <strong>验证、准备、解析</strong> 这三个阶段，所以也可以说类的生命周期是七个阶段</li>
<li>初始化（Initialization）</li>
<li>使用（Using）</li>
<li>卸载（Unloading）</li>
</ol>
<ul>
<li>其中 <strong>使用</strong> 就是平时我们写代码过程中通过 new 关键字或者反射操作创建对象并使用的过程，不再赘述。</li>
<li>而 <strong>卸载</strong> 主要和垃圾回收有关，在垃圾回收章节说明。</li>
</ul>
<p>所以在这里我们的重点就是 <strong>加载</strong>、<strong>连接</strong>、<strong>初始化</strong> 这三个阶段。</p>
<h4 id="1-2-加载">1.2 加载</h4>
<p><strong>在类的加载阶段</strong></p>
<p>1）首先类加载器根据类的全限定名（包名 + 类名），通过不同的渠道，以二进制流的方式将字节码信息加载到内存。</p>
<p>Java 虚拟机在设计时已经考虑到了扩展性，它允许通过不同的途径，读取字节码文件。如，</p>
<ul>
<li>最常见的就是将在磁盘上编译好的字节码文件加载进内存。</li>
<li>其次是一些框架，如 Spring，使用到的动态代理技术。在程序运行时，通过动态代理生成的类也需要被加载，这时类加载器就会根据类的全限定名，在内存中找到其二进制数据，将其读取到一块专门的内存区域中。</li>
<li>甚至可以通过网络将一个类传输过来，再通过类加载器加载到内存中，实际的应用场景就是早期的 applet 技术。</li>
</ul>
<p>2）接下里 Java 虚拟机会将字节码信息保存到一块专门的内存区域中，即方法区。</p>
<p>方法区只是 JVM 规范中设计的一个虚拟概念，每一款不同的 JVM，甚至 HotSport 虚拟机的不同版本，在设计方法区时都用到了不同的内存空间。比如像早期的 JDK 版本中，使用的永久代，而目前较新的版本使用的是元空间。</p>
<p>3）JVM 在回收到字节码信息后，会在方法区中生成一个对象（instanceKlass）来保存这些信息。</p>
<p>该 instanceKlass 对象保存了类的所有信息，还包括实现特定功能如 <strong>多态</strong> 的信息（虚方法表）。</p>
<p><img src="/java/jvm-a1fb6fd89ac6/image-20231103221655754.png" srcset="/img/loading.gif" lazyload alt="instanceKlass"></p>
<p>4）JVM 除了在方法区中存放一份类的信息之外，还会在堆中也生成一份与方法区中数据类似的一个对象（Class 对象）。</p>
<p>主要作用是，在实现反射时，需要先获取类的基本信息，也就是 Class 对象，再通过它获取到该类的方法或字段，所以该 Class 对象存放在堆区，在类的加载阶段被创建，其包含的基本内容就有字段、方法等信息。</p>
<p>这两个对象（instanceKlass 和 Class）之间会通过一个引用彼此关联。</p>
<p>除此之外，在 JDK 8 之后，该 Class 对象还会存放一份静态字段的数据，如类中创建的静态变量，其真实数据就存放在当前对象里。</p>
<blockquote>
<p>当然在 JDK 8 之前，是存放在方法区。</p>
</blockquote>
<p><img src="/java/jvm-a1fb6fd89ac6/image-20231103222511779.png" srcset="/img/loading.gif" lazyload alt="instanceKlass"></p>
<p>那么，整个加载阶段，主要是通过类加载器，将类的字节码信息加载到内存，并在方法区和堆区中分别创建一份对象以作后用。</p>
<p><strong>思考</strong></p>
<p>为什么需要在方法区和堆区中都创建一个对象，若不要堆区中的对象，只留下方法区中的对象，在反射的时候使用方法区中的信息，这样不是更节省内存吗？</p>
<ul>
<li>首先，方法区中的 instanceKlass 对象是使用 C++ 编写的对象，而 Java 代码不应该直接去操作该对象，所以 JVM 在堆区中专门创建一个 Class 对象，以便在 Java 代码中获取。</li>
<li>其次，Class 对象中的字段是少于 instanceKlass 对象中的字段，因为 instanceKlass 对象中的信息并不完全由 Java 开发者使用，如虚方法表，这是 JVM 在底层实现多态时使用的，对于 Java 开发者而言完全不需要使用，这样很好的控制了开发者访问数据的范围，保证了数据的安全性。</li>
</ul>
<p><strong>使用 HSDB 查看 Class 和 instanceKlass 中的信息</strong></p>
<p>使用 JDK 自带的 HSDB 工具查看 JVM 内存信息。工具是 JDK 8 的 lib 目录下的 sa-jdi.jar，其内部的启动类就是 HSDB 的启动类。</p>
<p>启动命令：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">java -cp sa-jdi.jar sun.jvm.hotspot.HSDB<br></code></pre></td></tr></table></figure>
<p>测试程序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HSDBDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">HSDBDemo</span>();<br>        System.in.read();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>可以使用 jps 查看正在运行的 Java 程序的进程 id。</p>
</blockquote>
<p>结果：</p>
<p><img src="/java/jvm-a1fb6fd89ac6/image-20231103225856543.png" srcset="/img/loading.gif" lazyload alt="结果"></p>
<h4 id="1-3-连接">1.3 连接</h4>
<p>当加载阶段完成后，一个类或者接口的字节码信息就被加载到了内存中，接下来 JVM 开始进入连接阶段。</p>
<p>连接阶段主要做 3 件事：</p>
<ol>
<li>验证，主要是校验字节码的信息是否满足 Java 虚拟机规范。</li>
<li>准备，虽然在加载阶段，JVM 给对象分配了内存，但是静态变量还没有处理，所以该阶段主要是给静态变量分配内存并赋初值。</li>
<li>解析，将常量池中的符号引用替换为指向内存的直接引用，方便后续获取常量池中的信息。</li>
</ol>
<p>这三个阶段，总的来说，被称为连接阶段，做了一些校验和前期的准备工作，并不会执行代码。</p>
<h5 id="验证">验证</h5>
<p>校验字节码文件的内容是否符合 Java 虚拟机规范。</p>
<p>这个阶段一般不需要开发人员参与，了解一下常见的校验内容（真正的校验极为复杂，可能包含格式、信息、字节码、指令等），</p>
<ol>
<li>文件格式的校验，比如在字节码开头是否有魔数，主次版本号是否满足当前 JVM 运行环境</li>
<li>对元信息（基础信息）进行校验，如一个类，必须有父类</li>
<li>校验字节码指令中的语义是否正确，如字节码指令跳转时不能跳转到不存在的语句。</li>
<li>校验符号引用，如有没有访问其他类中的 private 方法。</li>
</ol>
<h5 id="准备">准备</h5>
<p>给静态变量分配内存，并且赋初值。</p>
<p>在下面的代码中，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>定义类 Student，存放一个静态变量 value，赋值为 1。</li>
<li>那么 JVM 在加载这个类的过程中，会在堆上创建一个 Class 的对象，并给 value 变量分配一块内存区域，将其赋初始值为 0。</li>
<li>注意是 0 而不是 1。这里初始值指的是变量的初始值（默认值），而将该 value 的值变为 1 是在下一个阶段（初始化阶段）。</li>
<li>其他类型，如 long 默认为 0L，short 默认为 0，char 默认为 ‘\u0000’，byte 默认为 0，boolean 默认为 false，double 默认为 0.0，引用数据类型默认为 null。</li>
<li>至于为什么需要赋初值为默认值，当静态变量只声明不赋初值的时候，即 <code>public static int value;</code>，若不将 value 赋初值为默认值 0，假如该内存区域有残留的值，那么输出 value 变量就会是随机值。</li>
</ul>
<p>但是对于 final 修饰的静态变量且是基本类型，如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>定义类 Student，存放静态常量 value，赋值为 1。</li>
<li>那么此时在堆上创建 Class 对象后，直接给 value 赋值为 1，而省略了上面赋初值为默认值 0 的过程。</li>
<li>这是因为，当使用 final 修饰，那么在编译阶段就可以确定 value 的值一定是 1。</li>
</ul>
<h5 id="解析">解析</h5>
<p>将常量池中的符号引用替换为指向内存的直接引用，方便后续获取常量池中的信息。</p>
<p>指向内存的直接引用性能较高，以后只要找到当前类的内存地址，就可以直接访问常量池的信息。</p>
<p>如，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HSDBDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">HSDBDemo</span>();<br>        System.in.read();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在字节码中，一般信息中展示了该类的父类索引，使用的是符号引用，即 cp_info #6，而在 HSDB 里面该类的父类的符号引用就被替换为内存地址（@0x00000007c0000f28）</p>
<p><img src="/java/jvm-a1fb6fd89ac6/image-20231103233124594.png" srcset="/img/loading.gif" lazyload alt="符号引用"></p>
<p><img src="/java/jvm-a1fb6fd89ac6/image-20231103233056536.png" srcset="/img/loading.gif" lazyload alt="内存地址"></p>
<h4 id="1-4-初始化">1.4 初始化</h4>
<h5 id="初始化">初始化</h5>
<p>在连接阶段结束后，类的信息已经被加载到了内存中，同时校验和前置的准备工作已经完成，那接下来就进入到与开发人员有关初始化的阶段。</p>
<p>在初始化阶段，会执行静态代码块中的代码，并为静态变量赋值，在字节码文件中体现在，&lt;clinit&gt; 方法。</p>
<p>以下面的类为例，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InitDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        value = <span class="hljs-number">2</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>查看其字节码中的方法：</p>
<p><img src="/java/jvm-a1fb6fd89ac6/image-20231103235430273.png" srcset="/img/loading.gif" lazyload alt="clinit"></p>
<p>生成了 3 个方法，</p>
<ol>
<li>构造方法 &lt;init&gt;，虽然该类没有构造方法，但是编译器会自动生成无参的构造方法。</li>
<li>main 主方法。</li>
<li>类的初始化方法 &lt;clinit&gt;。</li>
</ol>
<p>主要关注 &lt;clinit&gt; 方法，其字节码指令</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">0</span> iconst_1<br><span class="hljs-number">1</span> putstatic #<span class="hljs-number">2</span> &lt;com/aman/InitDemo.value : I&gt;<br><span class="hljs-number">4</span> iconst_2<br><span class="hljs-number">5</span> putstatic #<span class="hljs-number">2</span> &lt;com/aman/InitDemo.value : I&gt;<br><span class="hljs-number">8</span> <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure>
<ul>
<li>iconst_1：将常量 1 压入操作数栈。</li>
<li>putstatic：将操作数栈顶的值赋给常量池中符号引用为 #2 的变量，即 com/aman/InitDemo.value</li>
<li>iconst_2：将常量 2 压入操作数栈。</li>
<li>putstatic：将操作数栈顶的值赋给常量池中符号引用为 #2 的变量，即 com/aman/InitDemo.value</li>
<li>return：返回。</li>
</ul>
<p>所以，总结 &lt;clinit&gt; 的作用：编译器会按从上到下的顺序，收集所有 static 静态代码块和静态变量赋值的代码，合并为一个特殊的方法，即 &lt;clinit&gt; 在类加载的初始化阶段被调用。</p>
<p>此外，说明 &lt;init&gt; 的作用：编译器按从上到下的顺序，收集所有实例代码块 <code>&#123;&#125;</code> 和非静态变量赋值的代码，以及类的构造方法，合并为 &lt;init&gt; 方法，注意，原始的构造方法内的代码总是在最后。</p>
<h5 id="触发类的初始化的方式">触发类的初始化的方式</h5>
<ol>
<li>访问一个类的静态变量或者静态方法，会触发类的初始化，但是若该变量用 final 修饰，并且等号右边是一个常量，那么在连接阶段就会直接给该变量赋常量值。</li>
<li>调用 Class.forName(String className) 方法，会触发类的初始化，注意在 Class 类的 forName 方法还有一个含 3 个参数的重载方法，其第二个参数为 initialize 的布尔值，可以用来决定是否让类初始化。</li>
<li>通过 new 关键字来创建一个对象，会触发类的初始化。</li>
<li>执行 main 方法的当前类，会触发类的初始化。</li>
</ol>
<blockquote>
<p>添加 -XX:+TraceClassLoading 虚拟机参数，可以打印出加载并初始化的类。</p>
</blockquote>
<p>示例：</p>
<p>1）访问某个类的静态变量或者静态方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">isInit</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Demo1.num = &quot;</span> + Demo1.num);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Demo1 被初始化了&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>说明：</p>
<ul>
<li>当 isInit 中 main 方法访问 Demo1.num，而 num 是非 final 的静态变量，则会导致 Demo1 的初始化，则输出静态代码块中的内容。</li>
<li>将 num 加上 final 修饰，则不会输出静态代码块中的内容。</li>
</ul>
<p>2）调用 Class.forName(String className) 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">isInit</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>        Class&lt;?&gt; clazz = Class.forName(<span class="hljs-string">&quot;com.aman.Demo2&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo2</span> &#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Demo2 被初始化了&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>说明：</p>
<ul>
<li>调用了 Class.forName(“com.aman.Demo2”) 方法，则会导致 Demo2 的初始化，则输出静态代码块中的内容。</li>
</ul>
<p>3）使用 new 关键字创建对象、执行 main 方法的类会被初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">isInit</span> &#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;isInit 被初始化了&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Demo3</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo3</span> &#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Demo3 被初始化了&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>说明：</p>
<ul>
<li>在 isInit 中使用 new 创建了 Demo3 的对象，而 isInit 类本身执行了 main 方法，则这两个类都会被初始化，则输出静态代码块中的内容，先输出 isInit，后输出 Demo3。</li>
</ul>
<h5 id="clinit-不会出现的情况">&lt;clinit&gt; 不会出现的情况</h5>
<ol>
<li>无静态代码块且无静态变量赋值语句。</li>
<li>有静态变量的声明但没有赋值语句。</li>
<li>静态变量的定义使用  final 关键字，该类变量会在准备阶段直接赋值。</li>
</ol>
<h5 id="存在继承关系的情况">存在继承关系的情况</h5>
<ol>
<li>直接访问父类的静态变量，不会触发子类的初始化。</li>
<li>子类的初始化 &lt;clinit&gt; 调用之前，会先调用父类的 &lt;clinit&gt; 初始化方法。</li>
</ol>
<h5 id="两个面试题">两个面试题</h5>
<p>1）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;A&quot;</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test1</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test1</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Test1</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;B&quot;</span>);<br>    &#125;<br><br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;C&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;D&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>输出结果：DACBCB</p>
<ul>
<li>首先，进入 main 则必然初始化 Test1 类，则先执行静态代码块中的内容，输出 “D”，后输出 “A”</li>
<li>当 new Test1 对象，由于该类已经被初始化过，所以直接执行实例代码块和构造方法的内容，输出 “CBCB”</li>
</ul>
<p>2）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(A02.a);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A01</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        a = <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A02</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A01</span> &#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        a = <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>输出结果：1</p>
<ul>
<li>虽然访问是 A02.a，但是 a 变量是继承自父类，相当于直接访问父类的静态变量，不会触发子类的初始化。</li>
</ul>
<h3 id="2-类加载器">2. 类加载器</h3>
<h4 id="2-1-概述">2.1 概述</h4>
<p>在类的生命周期的第一个阶段就是加载，在这个阶段使用的就是类加载器。</p>
<p>类加载器（ClassLoader）是 JVM 提供给应用程序去实现获取类和接口字节码数据的技术。</p>
<p>类加载器负责接收字节码文件，不管字节码文件从哪来（磁盘、网络传输、动态代理生成），当收到这些二进制数据后，类加载器就需要执行 JNI（本地接口调用），在方法区和堆区创建对象，保存字节码中的类和接口的信息。</p>
<p>所以，类加载器只是负责获取二进制的字节码信息，后续对象的创建还是交给 JVM 其他部分完成的。</p>
<p>Java 中类加载大部分是使用 Java 语言编写的，但是也有一些使用 C++ 语言编写，这些类加载就位于虚拟机的源码中。</p>
<p><img src="/java/jvm-a1fb6fd89ac6/image-20231104083658269.png" srcset="/img/loading.gif" lazyload alt="类加载"></p>
<h4 id="2-2-类加载器的分类">2.2 类加载器的分类</h4>
<blockquote>
<p>类加载器在 JDK 8 ~ 9 变化巨大，这里先说明 JDK 8 的类加载器，后续说明 JDK 9。</p>
</blockquote>
<h5 id="概述">概述</h5>
<p><strong>类加载器分为两类</strong></p>
<p>1）虚拟机底层源码实现</p>
<p>其源码位于虚拟机的源码中，实现的语言和虚拟机一致。在虚拟机底层中有一个 <strong>启动类加载器（Bootstrap）</strong></p>
<p>其作用：加载编写 Java 程序需要用到的基础类、最核心的类，如 String 类，确保类被加载的可靠性。</p>
<p>2）Java 语言实现</p>
<p>JDK 源码中提供了许多不同作用的类加载器，开发人员也可以根据需要个性化定制（实现自定义类加载器）。</p>
<p>所有的类加载器都是继承自 ClassLoader 抽象类，如</p>
<p><img src="/java/jvm-a1fb6fd89ac6/image-20231104084438278.png" srcset="/img/loading.gif" lazyload alt="ClassLoader"></p>
<p>在 Java 中，提供的类加载器有 2 种，</p>
<ul>
<li>扩展类加载器（Extension），主要用于扩展 Java 中的一些比较通用的类</li>
<li>应用程序类加载（Application），主要用于加载开发人员编写的类，以及引用的第三方 jar 包里的类。</li>
</ul>
<p><strong>查看类加载器</strong></p>
<p>使用 arthas 的 classloader 命令可以查看正在使用的类加载器。</p>
<p><img src="/java/jvm-a1fb6fd89ac6/image-20231104085854546.png" srcset="/img/loading.gif" lazyload alt="classloader"></p>
<ol>
<li>BootstrapClassLoader，即启动类加载器。</li>
<li>ArthasClassLoader，arthas 类加载器。</li>
<li>ExtClassLoader，即扩展类加载器。</li>
<li>DelegatingClassLoader，JDK 底层用于提升反射效率的类加载器。</li>
<li>APPClassLoader，即应用程序类加载器。</li>
</ol>
<h5 id="启动类加载器">启动类加载器</h5>
<p>启动类加载器是由 HotSpot 虚拟机提供的，使用 C++ 编写的一款类加载器。</p>
<p>作用：加载 JDK 安装目录下 jre/lib 中的类文件，如 String 类就位于该文件中的 rj.jar 中。</p>
<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassLoaderTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> String.class.getClassLoader();<br>        System.out.println(classLoader); <span class="hljs-comment">// null</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>获取 String 类的类信息后再拿到它对应的类加载器，并打印，结果为 null。</li>
<li>由于启动类加载器位于虚拟机环境中，是偏向底层的应用，而 Java 程序偏向上层的应用，所以虚拟机并不允许在 Java 代码中获取到启动类加载器。</li>
<li>所以当获得的类加载器为 null 的时候，该类加载器可能就是启动类加载器。</li>
</ul>
<p><strong>扩展基础类</strong></p>
<p>如何让启动类加载器加载开发人员自定义的类？</p>
<p>使用 JVM 参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">-Xbootclasspath/a:jar 包目录/jar 包名<br></code></pre></td></tr></table></figure>
<p>那么，此时启动类加载器就会加载位于 <strong>jar 包目录/jar 包名</strong> 中的类。</p>
<h5 id="扩展、应用程序类加载器">扩展、应用程序类加载器</h5>
<p>扩展类加载器和应用程序加载器都是由 JDK 提供的、使用 Java 编写的类加载器。</p>
<p>源码位于 sun.misc.Launcher 中，是该类的静态内部类，继承自 URLClassLoader。</p>
<p><img src="/java/jvm-a1fb6fd89ac6/image-20231104093541460.png" srcset="/img/loading.gif" lazyload alt="Launcher"></p>
<p>作用：通过目录或者指定 jar 包将字节码加载到内存中。</p>
<p>这两类加载器的继承关系：</p>
<p><img src="/java/jvm-a1fb6fd89ac6/image-20240118103441563.png" srcset="/img/loading.gif" lazyload alt="继承关系"></p>
<ul>
<li>ClassLoader：抽象类，规范了类加载的步骤，即获取二进制字节码信息，调用 JVM 底层方法创建方法区和堆区的对象。</li>
<li>SecureClassLoader：使用证书机制提升类加载的安全性。</li>
<li>URLClassLoader：利用 URL 获取目录下或者指定 jar 包的字节码文件进行加载。</li>
<li>扩展、应用程序类加载器通过该继承体系，也有了上面各个类的功能。</li>
</ul>
<p><strong>扩展类加载器</strong></p>
<p>默认加载 JDK 安装目录下 jre\lib\ext 文件中的类文件，如 nashorn.jar（提供一整套 JavaScript 的运行环境）。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> jdk.nashorn.internal.runtime.ScriptEnvironment;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestExt</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> ScriptEnvironment.class.getClassLoader();<br>        System.out.println(classLoader); <span class="hljs-comment">// sun.misc.Launcher$ExtClassLoader@677327b6</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>如何让扩展类加载器加载开发人员自定义的类？</strong></p>
<p>使用 JVM 参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">-Djava.ext.dirs=jar 包目录<br></code></pre></td></tr></table></figure>
<p>注意：这种方式会覆盖到原始目录，在使用时需要追加上原始目录（Windows 环境中使用 <code>;</code> 隔开），如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">-Djava.etx.dirs=<span class="hljs-string">&quot;D:\environment\JDK8\jdk1.8.0_341\jre\lib\ext;D:\jvm\jar&quot;</span><br></code></pre></td></tr></table></figure>
<p><strong>应用程序类加载器</strong></p>
<p>加载 ClassPath 下的类文件，包括项目中编写的类和接口的文件，以及第三方 jar 包中类和接口的文件。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.mysql.jdbc.Driver; <span class="hljs-comment">// 引入 mysql-connector-java </span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestApp</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader1</span> <span class="hljs-operator">=</span> Student.class.getClassLoader();<br>        System.out.println(classLoader1); <span class="hljs-comment">// sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader2</span> <span class="hljs-operator">=</span> Driver.class.getClassLoader(); <br>        System.out.println(classLoader2); <span class="hljs-comment">// sun.misc.Launcher$AppClassLoader@18b4aac2</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="使用-arthas-查看">使用 arthas 查看</h5>
<ol>
<li>首先使用 classpath 命令获取类加载器的哈希码信息。</li>
<li>然后使用该哈希码输出该类加载所加载的路径。</li>
</ol>
<p>示例：</p>
<p><img src="/java/jvm-a1fb6fd89ac6/image-20231104100111868.png" srcset="/img/loading.gif" lazyload alt="classloader"></p>
<h4 id="2-3-双亲委派机制">2.3 双亲委派机制</h4>
<p>如果虚拟机要去加载一个类，到底由哪个类加载器完成？这就需要使用 <strong>双亲委派机制</strong> 来解释。</p>
<p>首先明确类在被加载过程中最基本的要求：</p>
<ol>
<li>保证类加载的安全性。开发人员如果自定义了 java.lang.String，JVM 保证该类不能替换到 rj.jar 中的 String 核心类。</li>
<li>避免重复加载。减少在加载过程中的性能开销。</li>
</ol>
<p>在 ClassLoader 抽象类中，有一个 parent 属性，表示每一个类加载器都有一个父类加载器（启动类加载器除外）。</p>
<p><img src="/java/jvm-a1fb6fd89ac6/image-20231104101950889.png" srcset="/img/loading.gif" lazyload alt="ClassLoader"></p>
<ul>
<li>应用程序类加载的父类加载器为 <strong>扩展类加载器</strong>。</li>
<li>扩展类加载器的父类加载器为 <strong>null</strong>。于是就有了下面的类加载器的层次结构图：</li>
</ul>
<p><img src="/java/jvm-a1fb6fd89ac6/image-20240118103719423.png" srcset="/img/loading.gif" lazyload alt="层次结构"></p>
<p><strong>双亲委派机制</strong></p>
<ol>
<li>当一个类加载器去加载某个类时，会先自底向上查找父类加载器是否加载过，如果加载过就直接返回该类信息，如果一直到最顶层的类加载器都没有加载，再自顶向下进行加载。</li>
<li>应用程序类加载器的父类加载器是扩展类加载器，扩展类加载器没有父类加载器，但在双亲委派时会委派给启动类加载器。</li>
</ol>
<p>向上查找的机制保证只要其中一个类加载器加载过该类，则直接返回该类，避免重复加载。而向下委派的机制起到了加载优先级的作用，一个类优先由启动类加载器加载，它加载不了再交给扩展类加载器。</p>
<p>示例：</p>
<p>1）假设类 com.aman.Test 位于 classpath 下，且未被加载过</p>
<p><img src="/java/jvm-a1fb6fd89ac6/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6.gif" srcset="/img/loading.gif" lazyload alt="双亲委派机制"></p>
<p>2）若开发人员自定义了 java.lang.String，则 JVM 保证该类不能替换到 rj.jar 中的 String 核心类。</p>
<p>![String 类加载](./JVM基础/String 类加载.gif)</p>
<p>3）自定义 java.lang.String，由 Application 类加载加载，看实际是由哪个类加载器加载。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> java.lang;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可以通过类加载器的 loadClass 方法指定某个类加载器加载。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoadTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader1</span> <span class="hljs-operator">=</span> LoadTest.class.getClassLoader();<br>        System.out.println(classLoader1); <span class="hljs-comment">// sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><br>        Class&lt;?&gt; clazz = classLoader1.loadClass(<span class="hljs-string">&quot;java.lang.String&quot;</span>);<br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader2</span> <span class="hljs-operator">=</span> clazz.getClassLoader();<br>        System.out.println(classLoader2); <span class="hljs-comment">// null</span><br>        Field[] fields = clazz.getFields();<br>        System.out.println(Arrays.toString(fields)); <br>        <span class="hljs-comment">// [public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER]</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>classLoader2 为 null，说明即使自定义了 java.lang.String 类，JVM 还是会让启动类加载器加载。</li>
<li>且加载的 java.lang.String 是 rj.jar 中的 Java 核心类 String。</li>
</ul>
<p>4）使用 arthas 查看类加载器的继承关系</p>
<p>命令：<code>classloader - t</code></p>
<p><img src="/java/jvm-a1fb6fd89ac6/image-20231104105410974.png" srcset="/img/loading.gif" lazyload alt="classloader"></p>
<p><strong>三个问题</strong></p>
<p>1）若一个类重复出现在三个类加载器，由谁加载？</p>
<p>由启动类加载器加载，根据双亲委派机制，它的优先级是最高的。</p>
<p>2）String 类可以被覆盖吗？</p>
<p>不能，会交由启动类加载器加载在 rj.jar 中的 String 类。</p>
<p>3）类加载器的关系？</p>
<p>应用程序类加载器的父类加载器是扩展类加载器，扩展类加载器没有父类加载器，但是会委派给启动类加载器。</p>
<h4 id="2-4-打破双亲委派机制">2.4 打破双亲委派机制</h4>
<p>在某些特定的情况下，需要打破双亲委派机制才能实现想要的功能。大致有 3 种方法，</p>
<ol>
<li>自定义类加载器。</li>
<li>线程上下文类加载器。</li>
<li>Osgi 框架的类加载器（略）。</li>
</ol>
<h5 id="自定义类加载器">自定义类加载器</h5>
<h6 id="应用场景">应用场景</h6>
<p>在 Tomcat 中，可以运行多个 Web 应用，假设当前 Tomcat 容器运行了两个 Web 应用，但是这两个应用中存放了相同全限定名的类，现在 Tomcat 要去加载这两个类，由于双亲委派机制的存在，势必只能加载其中一个类，而另一个会直接返回已加载的类信息。</p>
<p><img src="/java/jvm-a1fb6fd89ac6/image-20240121140456494.png" srcset="/img/loading.gif" lazyload alt="Tomcat"></p>
<p>而 Tomcat 底层为每一个 Web 应用都单独生成了一个类加载器，且这些类加载不再使用双亲委派机制。</p>
<h6 id="分析双亲委派机制">分析双亲委派机制</h6>
<p>在 ClassLoader 抽象类中，有 4 个重要方法：</p>
<ol>
<li>public Class&lt;?&gt; loadClass(String name)：类加载的入口方法，提供了双亲委派机制，内部会调用 findClass 方法。</li>
<li>protected Class&lt;?&gt; findClass(String name)：由子类实现，获取二进制数据调用 defineClass，如 URLClassLoader 会根据文件路径获取类文件中的二进制数据。</li>
<li>protected final Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len)：做一些类名的校验，然后调用虚拟机底层的方法将字节码信息加载到内存中。</li>
<li>protected final void resolveClass(Class&lt;?&gt; c)：执行类生命周期中的连接阶段。</li>
</ol>
<p><strong>loadClass 方法</strong></p>
<p>两个重载方法，区别是否对类进行连接（即是否调用 resolveClass 方法），默认为 false。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-type">boolean</span> resolve)<br>    <span class="hljs-keyword">throws</span> ClassNotFoundException<br>&#123;<br>    <span class="hljs-comment">// 加锁保证线程安全</span><br>    <span class="hljs-keyword">synchronized</span> (getClassLoadingLock(name)) &#123;<br>        <span class="hljs-comment">// First, check if the class has already been loaded</span><br>        <span class="hljs-comment">// 首先检查该类是否已经被加载过, 若被加载过则进入 resolve 的判断, 然后返回</span><br>        Class&lt;?&gt; c = findLoadedClass(name);<br>        <span class="hljs-comment">// c == null 表示还未被加载</span><br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">t0</span> <span class="hljs-operator">=</span> System.nanoTime();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 若该类加载器的父类加载器不为 null 则递归调用父类加载器的 loadClass 方法</span><br>                <span class="hljs-comment">// 向上查找</span><br>                <span class="hljs-keyword">if</span> (parent != <span class="hljs-literal">null</span>) &#123;<br>                    c = parent.loadClass(name, <span class="hljs-literal">false</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 否则调用启动类加载器加载</span><br>                    <span class="hljs-comment">// 该方法内部调用 private native Class&lt;?&gt; findBootstrapClass(String name);</span><br>                    c = findBootstrapClassOrNull(name);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>                <span class="hljs-comment">// ClassNotFoundException thrown if class not found</span><br>                <span class="hljs-comment">// from the non-null parent class loader</span><br>            &#125;<br><br>            <span class="hljs-comment">// 此时若 c == null 表示父类加载器并没有加载成功, 则让当前类加载器尝试进行加载</span><br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// If still not found, then invoke findClass in order</span><br>                <span class="hljs-comment">// to find the class.</span><br>                <span class="hljs-type">long</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> System.nanoTime();<br>                <span class="hljs-comment">// 调用 findClass 方法, 该方法由子类实现</span><br>                c = findClass(name);<br><br>                <span class="hljs-comment">// this is the defining class loader; record the stats</span><br>                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);<br>                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);<br>                sun.misc.PerfCounter.getFindClasses().increment();<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 若 resolve 为 true 则进行连接</span><br>        <span class="hljs-keyword">if</span> (resolve) &#123;<br>            resolveClass(c);<br>        &#125;<br>        <span class="hljs-comment">// 返回</span><br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>defineClass 方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Class&lt;?&gt; defineClass(String name, <span class="hljs-type">byte</span>[] b, <span class="hljs-type">int</span> off, <span class="hljs-type">int</span> len,<br>                                     ProtectionDomain protectionDomain)<br>    <span class="hljs-keyword">throws</span> ClassFormatError<br>&#123;<br>    <span class="hljs-comment">// 进行校验工作</span><br>    protectionDomain = preDefineClass(name, protectionDomain);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">source</span> <span class="hljs-operator">=</span> defineClassSourceLocation(protectionDomain);<br>    <span class="hljs-comment">// private native Class&lt;?&gt; defineClass1(String name, byte[] b, int off, int len,</span><br>    <span class="hljs-comment">//                                      ProtectionDomain pd, String source);</span><br>    <span class="hljs-comment">// 本地方法, 交给虚拟机创建对象</span><br>    Class&lt;?&gt; c = defineClass1(name, b, off, len, protectionDomain, source);<br>    postDefineClass(c, protectionDomain);<br>    <span class="hljs-keyword">return</span> c;<br>&#125;<br></code></pre></td></tr></table></figure>
<h6 id="打破双亲委派机制">打破双亲委派机制</h6>
<p>经过上面的代码分析，打破双亲委派机制的关键就在 loadClass 方法上。</p>
<p>我们可以自定义类加载器，重写 loadClass 方法，自定义类加载时的逻辑，示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.apache.commons.io.IOUtils;<br><br><span class="hljs-keyword">import</span> java.io.File;<br><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.util.regex.Matcher;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BreakClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ClassLoader</span> &#123;<br>    <span class="hljs-keyword">private</span> String basePath;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">FILE_EXT</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;.class&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBasePath</span><span class="hljs-params">(String basePath)</span> &#123;<br>        <span class="hljs-built_in">this</span>.basePath = basePath;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] loadClassData(String name) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">tempName</span> <span class="hljs-operator">=</span> name.replaceAll(<span class="hljs-string">&quot;\\.&quot;</span>, Matcher.quoteReplacement(File.separator));<br>            <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(basePath + tempName + FILE_EXT);<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">return</span> IOUtils.toByteArray(fis);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                IOUtils.closeQuietly(fis);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;自定义类加载器失败, 原因: &quot;</span> + e.getMessage());<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 重写 loadClass 方法, 去掉双亲委派机制</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>        <span class="hljs-type">byte</span>[] data = loadClassData(name);<br>        <span class="hljs-keyword">return</span> defineClass(name, data, <span class="hljs-number">0</span>, data.length);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">BreakClassLoader</span> <span class="hljs-variable">loader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BreakClassLoader</span>();<br>        loader.setBasePath(<span class="hljs-string">&quot;D:\\jvm\\&quot;</span>);<br><br>        Class&lt;?&gt; clazz = loader.loadClass(<span class="hljs-string">&quot;java.lang.String&quot;</span>);<br>        clazz.newInstance();<br>        System.out.println(clazz);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在 <code>D:\jvm\</code> 下提前编写一个 java.lang.String 文件，通过 javac 编译为 class 文件。</p>
<p>运行代码：</p>
<p><img src="/java/jvm-a1fb6fd89ac6/image-20231104150131878.png" srcset="/img/loading.gif" lazyload alt="运行"></p>
<p>报错的原因是包名 java.lang 不合法，在使用 defineClass 来创建方法区和堆区的对象时，在 ClassLoader 类中的 preDefineClass 方法中会进行校验，如果需要加载的类名以 java. 开头，则直接抛出安全性的异常（因为以 java 为前缀的类必须是由启动类加载器加载）。</p>
<p><img src="/java/jvm-a1fb6fd89ac6/image-20231104150444606.png" srcset="/img/loading.gif" lazyload alt="运行"></p>
<p>所以使用自定义加载器加载 java.lang.String 是不可能成功的，再尝试另一个自定义的类 com.aman.Hello。</p>
<p>修改代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">BreakClassLoader</span> <span class="hljs-variable">loader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BreakClassLoader</span>();<br>    loader.setBasePath(<span class="hljs-string">&quot;D:\\jvm\\&quot;</span>);<br><br>    Class&lt;?&gt; clazz = loader.loadClass(<span class="hljs-string">&quot;com.aman.Hello&quot;</span>);<br>    clazz.newInstance();<br>    System.out.println(clazz);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/java/jvm-a1fb6fd89ac6/image-20231104150850892.png" srcset="/img/loading.gif" lazyload alt="运行"></p>
<p>报错：在该路径下找不到 Object.class，因为所有的类都继承自 Object 类，那么在文件中找不到 Object 的字节码就会报错。</p>
<p>修改代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>    <span class="hljs-keyword">if</span> (name.startsWith(<span class="hljs-string">&quot;java.&quot;</span>)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.loadClass(name);<br>    &#125;<br>    <span class="hljs-type">byte</span>[] data = loadClassData(name);<br>    <span class="hljs-keyword">return</span> defineClass(name, data, <span class="hljs-number">0</span>, data.length);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">BreakClassLoader</span> <span class="hljs-variable">loader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BreakClassLoader</span>();<br>    loader.setBasePath(<span class="hljs-string">&quot;D:\\jvm\\&quot;</span>);<br><br>    Class&lt;?&gt; clazz = loader.loadClass(<span class="hljs-string">&quot;com.aman.Hello&quot;</span>);<br>    clazz.newInstance();<br>    System.out.println(clazz); <span class="hljs-comment">// class com.aman.Hello</span><br>    System.out.println(clazz.getClassLoader()); <span class="hljs-comment">// com.aman.BreakClassLoader@70177ecd</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>这一次就会成功的加载，而且加载该类的类加载器就是自定义类加载器。那么就成功的打破了双亲委派机制。</p>
<h6 id="两个小问题">两个小问题</h6>
<p>1）对于自定义类加载器，它的父类加载器是？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">BreakClassLoader</span> <span class="hljs-variable">loader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BreakClassLoader</span>();<br>    loader.setBasePath(<span class="hljs-string">&quot;D:\\jvm\\&quot;</span>);<br><br>    Class&lt;?&gt; clazz = loader.loadClass(<span class="hljs-string">&quot;com.aman.Hello&quot;</span>);<br>    clazz.newInstance();<br>    System.out.println(clazz); <span class="hljs-comment">// class com.aman.Hello</span><br>    System.out.println(clazz.getClassLoader()); <span class="hljs-comment">// com.aman.BreakClassLoader@70177ecd</span><br>    System.out.println(clazz.getClassLoader().getParent()); <br>    <span class="hljs-comment">// sun.misc.Launcher$AppClassLoader@18b4aac2</span><br>    System.out.println(getSystemClassLoader()); <span class="hljs-comment">// sun.misc.Launcher$AppClassLoader@18b4aac2</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行代码，可以发现，自定义类加载器的父类加载器为 Application 类加载器。</p>
<p>原因在于，ClassLoader 的构造方法的重载方法中，如果没有指定父类加载器，则默认为系统类加载器（即应用程序类加载器）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-title function_">ClassLoader</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>(checkCreateClassLoader(), getSystemClassLoader());<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果需要指定父类加载器，只需重写 ClassLoader 的构造方法，传递父类加载器即可。</p>
<p>2）如果两个自定义类加载器去加载一个相同全限定名的类，会不会冲突？</p>
<p>在同一个 Java 虚拟机中，只有相同的类加载器 + 相同的类全限定名，才会被认为是同一个类。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">BreakClassLoader</span> <span class="hljs-variable">loader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BreakClassLoader</span>();<br>    loader.setBasePath(<span class="hljs-string">&quot;D:\\jvm\\&quot;</span>);<br><br>    Class&lt;?&gt; clazz = loader.loadClass(<span class="hljs-string">&quot;com.aman.Hello&quot;</span>);<br>    clazz.newInstance();<br>    System.out.println(clazz); <span class="hljs-comment">// class com.aman.Hello</span><br>    System.out.println(clazz.getClassLoader()); <span class="hljs-comment">// com.aman.BreakClassLoader@70177ecd</span><br>    System.out.println(clazz.getClassLoader().getParent()); <br>    <span class="hljs-comment">// sun.misc.Launcher$AppClassLoader@18b4aac2</span><br>    System.out.println(getSystemClassLoader()); <span class="hljs-comment">// sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><br>    <span class="hljs-comment">// 拿到应用程序类加载器</span><br>    <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> BreakClassLoader.class.getClassLoader();<br>    Class&lt;?&gt; clazz2 = classLoader.loadClass(<span class="hljs-string">&quot;com.aman.Hello&quot;</span>);<br><br>    System.out.println(clazz == clazz2); <span class="hljs-comment">// false</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h6 id="通过-arthas-查看类的详细信息">通过 arthas 查看类的详细信息</h6>
<p>命令：<code>sc -d 类的全限定名</code></p>
<p><img src="/java/jvm-a1fb6fd89ac6/image-20231104152357045.png" srcset="/img/loading.gif" lazyload alt="sc"></p>
<h5 id="线程上下文类加载器">线程上下文类加载器</h5>
<h6 id="应用场景-2">应用场景</h6>
<p>线程上下文类加载器被广泛应用在 JDBC、JNDI 这样的技术中，下面以 JDBC 来说明 <strong>线程上下文类加载器</strong>。</p>
<p>对于 JDBC 这个框架，其目的是在 Java 中去操作数据库，在它设计的核心思想中，不希望出现某个特定数据库的语法，保持泛用性，这样将来对接任何的数据库都不会有较大的代码变动。</p>
<p>那么它是怎么做到这一点的？</p>
<ul>
<li>在 java.sql 包中有一个 DriverManager 类，该类会管理在 jar 包中引入的数据库驱动类，比如使用 MySQL 数据库，就需要添加 MySQL 的驱动， 而 DriverManager 会负责加载 MySQL 的 jar 包中的驱动累，这样就可以连接 MySQL 的数据库。</li>
<li>如果想连接 Oracle 数据库，那么只需把 jar 包替换成 Oracle 的 jar 包，由 DriverManager 去加载 Oracle 的 jar 包中驱动类。</li>
</ul>
<p>通过引入不同驱动的方式，DriverManager 就可以对接不同的数据库，且在代码层次它是统一的。</p>
<p>但 DriverManager 类去加载驱动 jar 包中的类的过程中，会发现它打破了双亲委派机制，具体：</p>
<ul>
<li>DriverManager 类是 rj.jar 中的类，属于 Java 的核心 jar 包，会由启动类加载器来进行加载。</li>
<li>而数据库的驱动类其实是由应用程序类加载器加载的，所以这里就产生了一个冲突。</li>
<li>在双亲委派机制中，应该是自底向上进行委派，而现在仿佛变成了自顶向下的委派。</li>
</ul>
<p><img src="/java/jvm-a1fb6fd89ac6/image-20240121140756638.png" srcset="/img/loading.gif" lazyload alt="自顶向下的委派"></p>
<p>下面分析 DriverManager 是如何来实现这种向下委派的机制的？</p>
<h6 id="SPI-机制">SPI 机制</h6>
<p>DriverManager 位于 rj.jar，属于 JDK 的底层类，它是怎么知道引入了一个驱动 jar 包？</p>
<p>这就需要用到 JDK 的底层技术，SPI 机制，该机制也被大量用于如 dubbo 等框架。</p>
<p>简单来说，就是 JDK 提供了一种机制，当需要加载一个 <strong>接口的实现类对象</strong>，就可以通过 SPI 机制快速找到。</p>
<p>图示：</p>
<p><img src="/java/jvm-a1fb6fd89ac6/image-20240121141013535.png" srcset="/img/loading.gif" lazyload alt="SPI"></p>
<p>当服务的提供者提供了一种接口的实现之后，需要在 classpath 下的 META-INF/services/ 目录里创建一个以服务接口命名的文件，该文件里的内容就是这个接口的具体的实现类。</p>
<p>当其他的程序需要这个服务的时候，就可以通过查找该 jar 包（一般都是以 jar 包做依赖）的 META-INF/services/ 中的配置文件，配置文件中有接口的具体实现类名，可以根据这个类名进行加载实例化，就可以使用该服务了。</p>
<p>在 JDK 中查找服务实现的工具类是：java.util.ServiceLoader。</p>
<p>以 MySQL 为例，MySQL 的驱动 jar 包需要暴露驱动类给 DriverManager 使用，在它的 jar 包中有一个固定的文件夹（即 META-INF/services），SPI 机制会主动扫描该文件夹的文件，文件名就是驱动类所实现的接口，文件的内容就是驱动类，即</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">com.mysql.cj.jdbc.Driver<br></code></pre></td></tr></table></figure>
<p><img src="/java/jvm-a1fb6fd89ac6/image-20231104160924602.png" srcset="/img/loading.gif" lazyload alt="Driver"></p>
<p>在 MySQL 的 jar 包的源码中，这个驱动是在 com.mysql.cj.jdbc 包下的 Driver 类，它实现了 java.sql.Driver 接口。另外在静态代码块中将该类的对象创建出来注册到了 DriverManager  中，所以只要这个类被加载并初始化，那么注册驱动的过程完成了。</p>
<p><img src="/java/jvm-a1fb6fd89ac6/image-20231104161333899.png" srcset="/img/loading.gif" lazyload alt="Driver"></p>
<p>现在准备工作已经做好，那么 DriverManager  就可以拿到当前实现类的类名，并且用类加载器加载它。</p>
<p>在 DriverManager 中的静态代码块中的 loadInitialDrivers 方法就是用来初始化驱动。</p>
<p><img src="/java/jvm-a1fb6fd89ac6/image-20231104162050780.png" srcset="/img/loading.gif" lazyload alt="DriverManager"></p>
<p>在 loadInitialDrivers 方法内部会调用 ServiceLoader 的 load 方法，只需传递需要加载的接口，就会返回 ServiceLoader 对象，然后调用该对象的迭代器拿到当前类名，并创建对象。</p>
<p><img src="/java/jvm-a1fb6fd89ac6/image-20231104162134953.png" srcset="/img/loading.gif" lazyload alt="load"></p>
<h6 id="通过线程上下文拿到类加载器">通过线程上下文拿到类加载器</h6>
<p>在上面的 ServiceLoader 的 load 方法中，使用当前线程上下文的类加载器，调试一下可以发现为 Application 类加载器。</p>
<p><img src="/java/jvm-a1fb6fd89ac6/image-20231104162627465.png" srcset="/img/loading.gif" lazyload alt="load"></p>
<p>即我们也可以使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Thread.currentThread().setContextClassLoader(classLoader);<br>Thread.currentThread().getContextClassLoader();<br></code></pre></td></tr></table></figure>
<p>这两个方法获取或设置线程上下文类加载器。</p>
<h6 id="总结">总结</h6>
<ol>
<li>DriverManager 类位于 rt.jar 中，由启动类加载器进行加载。</li>
<li>而 DriverManager 需要拿到第三方 jar 包中对应的数据库的驱动，所以在底层使用了 SPI 这种服务发现机制，来找到对应 jar 包中的驱动。</li>
<li>而在 SPI 机制中的 ServiceLoader 类获取到了线程上下文的类加载器（在一个线程创建完后，虚拟机底层会将应用程序类加载器放入该线程上下文中）</li>
<li>DriverManager 使用 ServiceLoader 类返回的类加载器加载了 MySQL 的驱动。</li>
</ol>
<p>图示：</p>
<p><img src="/java/jvm-a1fb6fd89ac6/image-20240121141321115.png" srcset="/img/loading.gif" lazyload alt="过程"></p>
<h6 id="真的打破双亲委派机制了吗">真的打破双亲委派机制了吗</h6>
<p>由于上面的例子中由启动类加载器委托应用程序类加载器加载 jar 包中的驱动类，与双亲委派机制中自底向上的进行委派的方式违背，所以说打破了双亲委派机制。</p>
<p>但是，在上面的案例中，DriverManager 是由启动类加载器加载的，而在 jar 包中的驱动类位于 classpath 下，由应用程序类加载器进行加载也是满足双亲委派机制的向上委派，向下尝试的过程的，所以从这方面来说并没有打破双亲委派机制。</p>
<p>在我认为，只有重写在 ClassLoader 类中的 loadClass 方法，去除掉双亲委派机制的逻辑，才算真正的打破双亲委派机制。</p>
<h4 id="2-5-JDK-9-之后的类加载器">2.5 JDK 9 之后的类加载器</h4>
<p>在 JDK 9 之前，扩展类加载器和应用程序类加载器的源代码都在 sun.misc.Launcher 类中，该类位于 rt.jar，这两个类加载器都继承自 URLClassLoader，可以通过某个特定的目录查找 jar 包以及 jar 包中的字节码文件。</p>
<p>所以本质上 JDK 9 之前的版本中都是按照 jar 包的位置去加载字节码文件。</p>
<p>但是在 JDK 9 之后，由于引入了模块化的概念，那么就会将 Java 中的类放到 jmod 文件中，如下：</p>
<p><img src="/java/jvm-a1fb6fd89ac6/image-20231104170923678.png" srcset="/img/loading.gif" lazyload alt="jmod"></p>
<p>那么类加载器从原来在 jar 包中进行加载转变为从这些 jmod 文件中进行加载。</p>
<p>主要变化：</p>
<ol>
<li>启动类加载器（BootClassLoader）不再使用 C++ 编写，而是直接使用 Java 编写，是 jdk.internal.loader.ClassLoaders 类的静态内部类中，后面提及的其他类加载器也是该类的静态内部类。</li>
<li>启动类加载器会继承自 BuiltinClassLoader，实现了从 jmod 模块中找到要加载的字节码文件。</li>
<li>启动类加载器依然无法通过 Java 代码获取到，返回的仍然是 null，提高了类加载的安全性。</li>
<li>JDK 9 之前的 <strong>扩展类加载器</strong> 被替换为 <strong>平台类加载器</strong>（PlatformClassLoader），平台类加载器遵循模块化方式加载字节码文件，所以继承关系从 URLClassLoader 变为了 BuiltinClassLoader。平台类加载器的存在更多了为了与老版本的设计方案兼容，自身并没有特殊的逻辑。</li>
<li>JDK 9 之前的应用程序类加载器，只是继承关系发生了变化，还是应用程序类加载器（AppClassLoader）。</li>
</ol>
<h2 id="内存结构">内存结构</h2>
<h3 id="1-概述-2">1. 概述</h3>
<p>类加载器将字节码文件加载到内存中，会用到两块内存区域，即方法区和堆区。这两块区域都属于 JVM 管理的内存，由于 JVM 在运行过程中会使用这块内存，所以就称之为运行时数据区域。</p>
<p>Java 虚拟机规范中规定了运行时数据区域的中每个部分的作用，大致分为两大类：</p>
<ol>
<li>线程共享：方法区、堆区</li>
<li>线程不共享：程序计数器、Java 虚拟机栈、本地方法栈</li>
</ol>
<p><img src="/java/jvm-a1fb6fd89ac6/image-20240121141549362.png" srcset="/img/loading.gif" lazyload alt="运行时数据区域"></p>
<p>所谓线程不共享，</p>
<ol>
<li>每当创建一个线程后，每一个线程内部都会有独属于该线程的程序计数器、Java 虚拟机栈以及本地方法栈，其他线程是不可能访问到当前线程的这些数据的。</li>
<li>由于不能共享，整体的安全性比较高，而且当线程运行结束后，可以直接将整个线程回收掉，该内存区域即得到释放。</li>
</ol>
<p>而线程共享，</p>
<ol>
<li>指的是每个线程都可以从方法区、堆区中放入、获取数据并使用。</li>
<li>但线程共享的区域存在线程安全问题，且对于 Java 来说，该区域的内存回收也是一个复杂的问题。</li>
</ol>
<h3 id="2-程序计数器">2. 程序计数器</h3>
<h4 id="2-1-概述-2">2.1 概述</h4>
<p>程序计数器（Program Counter Register）也叫做 PC 寄存器，每个线程会通过程序寄存器记录当前要执行的字节码指令的地址。</p>
<ol>
<li>首先字节码指令最初是保存在字节码文件中，当类加载器将字节码文件读取到内存后，这些指令就会保存在内存中，所以每一行指令应该有自己的内存地址。</li>
<li>而字节码指令最终要交给解释器去解释执行，所以解释器就需要知道要执行的字节码指令的位置，那么程序计数器就保存了当前要执行的字节码指令的地址，解释器在程序计数器中获取到该地址，就可以拿到对应的字节码指令来执行。</li>
</ol>
<h4 id="2-2-程序计数器作用">2.2 程序计数器作用</h4>
<p><strong>1）程序计数器可以控制程序指令的进行，实现分支、跳转、异常处理等逻辑</strong></p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PCTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;<br>            i--;<br>        &#125;<br>        i++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>上面的代码转换为字节码指令为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-number">0</span> iconst_0<br> <span class="hljs-number">1</span> istore_1<br> <span class="hljs-number">2</span> iload_1<br> <span class="hljs-number">3</span> ifne <span class="hljs-number">9</span> (+<span class="hljs-number">6</span>)<br> <span class="hljs-number">6</span> iinc <span class="hljs-number">1</span> by -<span class="hljs-number">1</span><br> <span class="hljs-number">9</span> iinc <span class="hljs-number">1</span> by <span class="hljs-number">1</span><br><span class="hljs-number">12</span> <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure>
<p>上面各个指令的含义：</p>
<ul>
<li>iconst_0：将常量 0 压入操作数栈</li>
<li>istore_1：弹出当前操作数栈顶元素，存储在当前栈帧中，局部变量表 1 号索引处。</li>
<li>iload_1：将当前栈帧中，局部变量表 1 号索引处的元素 <strong>拷贝</strong> 到操作数组栈。</li>
<li>ifne 9 (+6)：将操作数栈顶元素与 0 比较，如果相等则跳到 9 号位置执行，否则继续向下执行。</li>
<li>iinc 1 by -1：将局部变量表中 1 号索引处的元素减 1。</li>
<li>iinc 1 by 1：将局部变量表中 1 号索引处的元素加 1。</li>
<li>return：返回。</li>
</ul>
<p>·在加载阶段，虚拟机将字节码文件中的指令读取到内存后，将原来字节码文件中的偏移量转换为实际的内存地址。</p>
<p>在代码执行过程中，程序计数器会记录下一行字节码指令的地址，执行完当前指令之后，虚拟机的执行引擎根据程序计数器中的地址值执行下一行指令。</p>
<p><strong>2）在多线程执行时，JVM 需要通过程序计数器记录 CPU 切换时解释执行到的指令的内存地址。</strong></p>
<p>在多线程的情况下， CPU 在执行过程中，不是一致执行一个线程，它会在多个线程之间来的切换。</p>
<p>如果 CPU 从线程 a 切换到线程 b 就需要知道线程 b 的解释器解释到了哪一行指令，而程序计数器保存了接下来要执行的指令地址，那么只需要根据该地址取出指令，解释器就可以继续工作。</p>
<h4 id="2-3-会内存溢出吗">2.3 会内存溢出吗</h4>
<p>程序计数器在运行过程中会内存溢出吗？</p>
<p>内存溢出，指的是程序在使用某一块内存区域时，存放数据占用的内存超过了虚拟机能够提供的内存上限。</p>
<p>那么在程序计数器中，是不会发生内存溢出的，程序计数器只会保存一个固定长度的内存地址，也就是字节码指令的地址，那自然就不会发生内存的溢出。</p>
<h3 id="3-Java-虚拟机栈">3. Java 虚拟机栈</h3>
<h4 id="3-1-概述">3.1 概述</h4>
<p>Java 虚拟机栈，采用先进先出的栈作为数据结构，保存每一个方法调用时对应的信息，每一个方法的调用会使用一个栈帧（Stack Frame）来保存。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StackTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        method01();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method01</span><span class="hljs-params">()</span> &#123;<br>        method02();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method02</span><span class="hljs-params">()</span> &#123;<br>        method03();<br>        System.out.println(<span class="hljs-string">&quot;method02&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method03</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;method03&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在 Idea 中通过 debug 调试可以查看每个方法的栈帧</p>
<p><img src="/java/jvm-a1fb6fd89ac6/image-20231104203312875.png" srcset="/img/loading.gif" lazyload alt="debug"></p>
<p>虚拟机栈的特点：</p>
<ol>
<li>每一个线程都拥有自己的栈，在栈中可以存放栈帧对应的数据。</li>
<li>虚拟机栈和线程的生命周期一致，当线程被销毁，则对应的栈空间也会被回收释放。</li>
<li>虚拟机栈中每一个栈帧都有 3 部分组成，<strong>局部变量表、操作数栈和帧数据</strong>。</li>
</ol>
<h4 id="3-2-局部变量表">3.2 局部变量表</h4>
<p>局部变量表：在运行过程中存放所有的局部变量，方法参数，若为实例方法则还存放 this 变量，在编译为字节码时，就可以确定局部变量表中的内容。</p>
<p>如，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LocalVarTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>其局部变量表中的内容：</p>
<p><img src="/java/jvm-a1fb6fd89ac6/image-20231104204559115.png" srcset="/img/loading.gif" lazyload alt="局部变量表"></p>
<ul>
<li>保存了 3 个变量：<code>this</code>、<code>j</code> 和 <code>i</code>。</li>
<li>Nr. 表示：局部变量的编号。</li>
<li>起始 PC 和长度：限制了该局部变量在字节码指令中有效的范围。</li>
<li>序号：局部变量表本质是一个数组，数组的每一个位置称为 slot 槽，在 Java 中，long 和 double 类型会占用 2 个槽，而其他包括引用类型的引用都只占 1 个槽，如上面 <code>j</code> 是 long 型变量会占据 1、2 号槽。</li>
<li>在局部变量表中还可以存放 this 变量和方法参数，存放顺序是：this 变量、方法参数、局部变量。</li>
<li>在局部变量表中，还存在复用性，一旦某个局部变量不再使用，则存放该变量的槽在方法运行时也可以被其他变量占用。</li>
</ul>
<p>示例：下面的方法中，在局部变量表中会占用几个槽？6 个。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> m)</span> &#123;<br>    &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>    &#125;<br>    &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="/java/jvm-a1fb6fd89ac6/image-20231104205457240.png" srcset="/img/loading.gif" lazyload alt="槽数"></p>
<h4 id="3-3-操作数栈">3.3 操作数栈</h4>
<p>操作数栈（栈结构）是栈帧中虚拟机在执行指令的过程中，用来存放中间数据的一块内存区域。</p>
<p>在编译器就可以确定操作数栈的最大深度，从而在执行时正确的分配内存。</p>
<h4 id="3-4-帧数据">3.4 帧数据</h4>
<p>局部变量表和操作数栈，每一个虚拟机都是按照虚拟机规范去实现的。但帧数据与之不同，每一个虚拟机可以添加任意所需的数据，只介绍重要部分。</p>
<p>1）动态链接</p>
<p>当类的字节码指令引用了其他类的属性或者方法时，需要将符号引用（编号）转换为对应的运行时常量池中的内存地址，而动态链接就保存了 <strong>符号引用</strong> 到 <strong>运行时常量池的内存地址的映射关系</strong>。</p>
<p>2）方法出口</p>
<p>方法出口指的是方法在正确或者异常结束时，当前栈帧会被弹出，同时程序计数器应该指向上一个栈帧中的下一条指令的地址，所以在当前栈帧中，需要存储此方法出口的地址。</p>
<p>3）异常表的引用</p>
<p>异常表，存放是代码中异常的处理信息，这块信息在编译期就可以确定，主要包含的是 try、catch 代码块，在异常发生以及异常不发生的情况下，代码跳转的位置，JVM 在执行字节码指令的过程中就可以快速跳转。</p>
<h4 id="3-5-栈内存溢出">3.5 栈内存溢出</h4>
<p>Java 虚拟机栈中，如果栈帧过多，占用的内存超过栈内存可以分配的最大大小就会出现内存溢出，抛出 StackOverflowError 错误。</p>
<p>如果不知道栈的大小 ，则 JVM 将创建一个具有默认大小的栈，该大小取决于操作系统和计算机的体系结构。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StackOverTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recursion</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(++count);<br>        recursion();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        recursion();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="/java/jvm-a1fb6fd89ac6/image-20231104211342232.png" srcset="/img/loading.gif" lazyload alt="栈内存溢出"></p>
<p>在 10691 次发生了栈内存溢出。</p>
<p><strong>可以使用虚拟机参数设置虚拟机栈的大小</strong></p>
<p>命令：<code>-Xss栈大小</code> 或者 <code>-XX:ThreadStackSize=栈大小</code></p>
<p>单位：字节（默认，必须是 1024 的倍数）、k 或者 K、m 或者 M、g 或者 G。</p>
<p>注意：</p>
<ol>
<li>HotSpot 虚拟机对栈大小的最大值和最小值的要求：
<ul>
<li>Windows（64 位）下 JDK 8 最小值为 180k，最大值为 1024m。</li>
</ul>
</li>
<li>局部变量过多，操作数栈深度过大都可能会导致栈的溢出。</li>
<li>一般情况，即使使用递归，栈的深度最多也只能到几百左右，不会出现栈的溢出，故可设置为 <code>-Xss256k</code> 以节省内存。</li>
</ol>
<h3 id="4-本地方法栈">4. 本地方法栈</h3>
<p>本地方法栈（Native Method Stack）与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务，也就是为 Java 虚拟机调用本地方法所提供的内存空间，就是本地方法栈。</p>
<p>在虚拟机规范中对本地方法栈中方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如 HotSpot 虚拟机）直接就把本地方法栈和虚拟机栈合二为一。</p>
<p>本地方法栈区域也会抛出 StackOverflowError 和 OutOfMemoryError 异常。</p>
<h3 id="5-堆区">5. 堆区</h3>
<h4 id="5-1-概述">5.1 概述</h4>
<p>在一般的 Java 程序，堆内存应该是空间占用最大的一块内存区域。</p>
<p>我们在程序中创建出来的对象都位于堆上，而栈中的局部变量表上存放了堆中对象的引用，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HeapTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Teacher</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>();<br>        t1.setName(<span class="hljs-string">&quot;张三&quot;</span>);<br>        t1.setAge(<span class="hljs-number">20</span>);<br>        t1.setId(<span class="hljs-number">1</span>);<br><br>        <span class="hljs-type">Teacher</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>();<br>        t2.setName(<span class="hljs-string">&quot;李四&quot;</span>);<br>        t2.setAge(<span class="hljs-number">23</span>);<br>        t2.setId(<span class="hljs-number">2</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>其内存划分：</p>
<p><img src="/java/jvm-a1fb6fd89ac6/image-20240121142220376.png" srcset="/img/loading.gif" lazyload alt="内存划分"></p>
<p>而静态变量也可以存放堆对象的引用，那么通过静态变量就可以实现对象在线程之间进行共享。</p>
<h4 id="5-2-堆内存溢出">5.2 堆内存溢出</h4>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HeapOver</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        ArrayList&lt;Object&gt; objects = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            objects.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">5</span>]);<br>            Thread.sleep(<span class="hljs-number">10</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="/java/jvm-a1fb6fd89ac6/image-20231104214126404.png" srcset="/img/loading.gif" lazyload alt="堆内存溢出"></p>
<h4 id="5-3-堆内存的管理">5.3 堆内存的管理</h4>
<p>在堆内存中，需要关注 3 个值：used、total 和 max</p>
<ol>
<li>used：当前已经使用的堆内存。</li>
<li>total：Java 虚拟机已经分配的可用的堆内存。</li>
<li>max：Java 虚拟机可以分配的最大堆内存。</li>
</ol>
<blockquote>
<p>在 arthas 中，通过命令：dashboard 或者 memory 可以查看这 3 个值。</p>
</blockquote>
<p>used、total 和 max 的变化情况：</p>
<ol>
<li>随着堆中的对象增多，当 used 大于 total 时，Java 虚拟将会继续为堆分配内存，即增大 total 的值。</li>
<li>随着 total 的增大，当 total 增大到某个阈值，就会出现堆内存溢出（堆内存溢出的判断条件较为复杂，在垃圾回收器中解释）。</li>
</ol>
<p>如果不设置任何虚拟机参数，max 默认是系统内存的 1/4，total 默认是系统内存的 1/64。如何设置这两个值？</p>
<p>使用虚拟机参数：<code>-Xmx值</code> 设置 max 值，<code>-Xms值</code> 设置初始 total 值。</p>
<ul>
<li>单位：字节（默认，必须是 1024 的整数倍）、k 或者 K、m 或者 M、g 或者 G</li>
<li>限制：Xmx 必须大鱼板 2Mb，Xms 必须大于 1Mb。</li>
</ul>
<p>如：设置如下虚拟机参数，然后在 arthas 中使用 memory 命令查看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">-Xmx2g -Xms2g<br></code></pre></td></tr></table></figure>
<p><img src="/java/jvm-a1fb6fd89ac6/image-20231104220843375.png" srcset="/img/loading.gif" lazyload alt="memory"></p>
<p>但是为什么设置了 2g 内存，在 arthas 中只有 1963m？</p>
<ul>
<li>arthas 中的获取堆内存的技术是 JMX，这种方法与垃圾回收器有关，计算的是 <strong>可分配对象的内存</strong>，而不是整个内存。</li>
</ul>
<p>在 Java 服务端程序开发时，建议将 <code>-Xmx</code> 和 <code>-Xms</code> 设置为相同的值，这样程序启动之后可使用的总内存就是最大内存，而无需向虚拟机再次申请，减少了申请并分配内存的时间开销，同时也不会出现内存过剩之后堆收缩的情况。</p>
<h3 id="6-方法区">6. 方法区</h3>
<h4 id="6-1-概述">6.1 概述</h4>
<p>方法区是一块线程共享的区域，每一个线程都可以去获取方法区中共享的数据。</p>
<p>主要存放，</p>
<ol>
<li>类的元信息，即类的基本信息。</li>
<li>运行时常量池，保存了字节码文件中的常量池。</li>
<li>字符串常量池（不同版本有差异）。</li>
</ol>
<p><strong>方法区的具体实现</strong></p>
<p>方法区只是 JVM 规范中设计的一个虚拟的概念，每一款 JVM 在实现上都各不相同，甚至对于 HotSpot 这款虚拟机来说，它的不同版本在实现方法区上用到的技术都有可能是不同的。</p>
<ul>
<li>在 JDK 7 及之前的版本，方法区位于堆中，这块空间被称为 <strong>永久代</strong>，堆的大小由虚拟机参数控制。</li>
<li>在 JDK 8 及之后的版本，方法区位于元空间，而元空间位于操作系统所维护的 <strong>直接内存</strong> 中，默认情况下只要不超过操作系统的上限就可以一直分配，可以使用 <code>-XX:MaxMetaspaceSize=值</code> 将元空间最大内存进行限制。</li>
</ul>
<p>所以，方法区是一个虚拟的概念，在 HotSpot 中实现的方式有两种，一种是永久代，另外一种就是元空间。</p>
<p>注意：静态变量的存放位置</p>
<ul>
<li>在 JDK 6 及之前的版本，静态变量存放在方法区中，也就是永久代。</li>
<li>在 JDK 7 及之后的版本，静态变量存放在堆中的 Class 对象中，脱离了永久代。</li>
</ul>
<h4 id="6-2-方法区内存溢出">6.2 方法区内存溢出</h4>
<p>通过 ByteBuddy 框架动态生成字节码数据，加载到内存中，观察方法区是否会出现内存溢出的情况。</p>
<p>1）引入依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>net.bytebuddy<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>byte-buddy<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.12.23<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>2）示例</p>
<p>JDK 8</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodOver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ClassLoader</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">MethodOver</span> <span class="hljs-variable">methodOver</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MethodOver</span>();<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Class&quot;</span> + count;<br>            <span class="hljs-type">ClassWriter</span> <span class="hljs-variable">classWriter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassWriter</span>(<span class="hljs-number">0</span>);<br>            classWriter.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC, name, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;java/lang/Object&quot;</span>, <span class="hljs-literal">null</span>);<br>            <span class="hljs-type">byte</span>[] bytes = classWriter.toByteArray();<br>            methodOver.defineClass(name, bytes, <span class="hljs-number">0</span>, bytes.length);<br>            System.out.println(++count);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/java/jvm-a1fb6fd89ac6/image-20231104224349006.png" srcset="/img/loading.gif" lazyload alt="方法区内存溢出"></p>
<p>JDK 7</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodOver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ClassLoader</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">MethodOver</span> <span class="hljs-variable">methodOver</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MethodOver</span>();<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Class&quot;</span> + count;<br>            <span class="hljs-type">ClassWriter</span> <span class="hljs-variable">classWriter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassWriter</span>(<span class="hljs-number">0</span>);<br>            classWriter.visit(Opcodes.V1_7, Opcodes.ACC_PUBLIC, name, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;java/lang/Object&quot;</span>, <span class="hljs-literal">null</span>);<br>            <span class="hljs-type">byte</span>[] bytes = classWriter.toByteArray();<br>            methodOver.defineClass(name, bytes, <span class="hljs-number">0</span>, bytes.length);<br>            System.out.println(++count);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/java/jvm-a1fb6fd89ac6/image-20231104230352005.png" srcset="/img/loading.gif" lazyload alt="永久代内存溢出"></p>
<p>从两个结果对比可以看出：</p>
<ol>
<li>JDK 8 的方法区由于在操作系统维护的直接内存，那么可分配的内存很大，足足执行了上百万次才发生内存溢出，同时可以看出方法区在元空间。</li>
<li>JDK 7 的方法是在堆中，可分配的内存较操作系统更少，故执行就发生了内存溢出，同时可以看出方法区在永久代。</li>
</ol>
<p>在 JDK 8 中，虽然可用的内存很多，但是可能由于不正确代码导致方法区占用内存过大，导致达到操作系统的内存上限，可能把其他程序的内存资源占用，会影响整个服务器上程序的运行。</p>
<p>所以建议在启动程序的时候，给元空间设置一个最大的内存。</p>
<h4 id="6-3-类的元信息">6.3 类的元信息</h4>
<p>在类的加载阶段，JVM 通过类加载器将类的字节码信息读取到内存中，并且创建了 instanceKlass 对象，将字节码信息中的基本信息、常量池、字段和方法以及多态的基础，虚方法表等全部存放在该对象中。</p>
<p>当然，真正虚拟机在实现时，会将常量池和方法单独使用一块内存存放，而在 instanceKlass 中只是存放这两者的引用。</p>
<h4 id="6-4-运行时常量池">6.4 运行时常量池</h4>
<p>在字节码信息中，其中一块就是常量池，在类的加载阶段会被读取到内存中，这时由原来的静态常量池就变为了运行时常量池。</p>
<p>字节码文件中通过编号查表的方式找到常量，这种常量池称为静态常量池。当常量池加载到内存中之后，可以通过内存地址快速的定位到常量池中的内容，这种常量池称为运行时常量池，这种通过内存地址去访问数据的方式性能会比较好。</p>
<h4 id="6-5-字符串常量池">6.5 字符串常量池</h4>
<blockquote>
<p>StringTable</p>
</blockquote>
<h5 id="概述-2">概述</h5>
<p>字符串常量池（StringTable），存放的就是在源代码中定义的常量字符串。</p>
<p>StringTable 实际上是一个固定大小的 HashTable。因此被称为 StringTable。</p>
<p>其长度不能像 HashMap 那样动态扩容。因此，如果 hash 冲突，那么它只能采取拉链法来解决，那么这样带来的坏处就是，随着链表长度的增加，StringTable 中检索的时间复杂度会增加。这样会造成其性能急剧下降。</p>
<p>虽然在 JDK 8 版本中默认长度为 60013，但是如果某些特殊应用造成 StringTable 中链表的长度不断增加的话，势必会影响性能。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringTableTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;abc&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;<br>        System.out.println(s1 == s2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>在上述代码编译为字节码后，“abc” 会直接加入常量池（字节码文件中的），而当该字节码被读取到内存后，“abc” 字符串就会被加入到 StringTable 中。</li>
<li>而由于该字符串对象是通过 new 关键字创建，所以该对象也会放在堆中，在栈中使用 S1 这个局部变量保存堆中的地址。</li>
<li>那么第二句代码并没有通过 new 关键字去创建新的对象，所以 S2 这个局部变量存放的是 StringTable 中的 “abc” 的地址。</li>
<li>输出结果应该为 false。</li>
</ul>
<p>所以，StringTable 中存放的内容，其实就是通过字节码文件读取到的静态常量池中的字符串。</p>
<h5 id="StringTable-和运行时常量池的关系">StringTable 和运行时常量池的关系</h5>
<p>在最早的时候，StringTable 是属于运行时常量池的一部分，因为运行时常量池除了存放字符串的常量外，还会存放如类名的常量、整数的常量，它们存储的位置是一样的。</p>
<p>但在后续的 JDK 版本过程中做出了调整，将 StringTable 和运行时常量池做了拆分。大致分为 3 个阶段。</p>
<ol>
<li>在 JDK 7 之前，运行时常量池包含了 StringTable，所以这两部分内容应该位于永久代。</li>
<li>在 JDK 7 时，StringTable 从运行时常量池中分离，单独存放在堆中。</li>
<li>在 JDK 7 之后，由于永久代不再使用，而是用元空间替代，所以 StringTable 还在堆中，而运行时常量时被移动到元空间，所以现在可以认为 StringTable 和运行时常量池不是一个东西了。</li>
</ol>
<h5 id="面试题">面试题</h5>
<p>1）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringTableTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;2&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;12&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> a + b;<br>        System.out.println(c == d); <span class="hljs-comment">// false</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>其字节码指令：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-number">0</span> ldc #<span class="hljs-number">2</span> &lt;<span class="hljs-number">1</span>&gt;<br> <span class="hljs-number">2</span> astore_1<br> <span class="hljs-number">3</span> ldc #<span class="hljs-number">3</span> &lt;<span class="hljs-number">2</span>&gt;<br> <span class="hljs-number">5</span> astore_2<br> <span class="hljs-number">6</span> ldc #<span class="hljs-number">4</span> &lt;<span class="hljs-number">12</span>&gt;<br> <span class="hljs-number">8</span> astore_3<br> <span class="hljs-number">9</span> <span class="hljs-keyword">new</span> #<span class="hljs-number">5</span> &lt;java/lang/StringBuilder&gt;<br><span class="hljs-number">12</span> dup<br><span class="hljs-number">13</span> invokespecial #<span class="hljs-number">6</span> &lt;java/lang/StringBuilder.&lt;init&gt; : ()V&gt;<br><span class="hljs-number">16</span> aload_1<br><span class="hljs-number">17</span> invokevirtual #<span class="hljs-number">7</span> &lt;java/lang/StringBuilder.append : (Ljava/lang/String;)Ljava/lang/StringBuilder;&gt;<br><span class="hljs-number">20</span> aload_2<br><span class="hljs-number">21</span> invokevirtual #<span class="hljs-number">7</span> &lt;java/lang/StringBuilder.append : (Ljava/lang/String;)Ljava/lang/StringBuilder;&gt;<br><span class="hljs-number">24</span> invokevirtual #<span class="hljs-number">8</span> &lt;java/lang/StringBuilder.toString : ()Ljava/lang/String;&gt;<br><span class="hljs-number">27</span> astore <span class="hljs-number">4</span><br><span class="hljs-number">29</span> getstatic #<span class="hljs-number">9</span> &lt;java/lang/System.out : Ljava/io/PrintStream;&gt;<br><span class="hljs-number">32</span> aload_3<br><span class="hljs-number">33</span> aload <span class="hljs-number">4</span><br><span class="hljs-number">35</span> if_acmpne <span class="hljs-number">42</span> (+<span class="hljs-number">7</span>)<br><span class="hljs-number">38</span> iconst_1<br><span class="hljs-number">39</span> goto <span class="hljs-number">43</span> (+<span class="hljs-number">4</span>)<br><span class="hljs-number">42</span> iconst_0<br><span class="hljs-number">43</span> invokevirtual #<span class="hljs-number">10</span> &lt;java/io/PrintStream.println : (Z)V&gt;<br><span class="hljs-number">46</span> <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure>
<ul>
<li>源代码被加载后，“1”、“2”、“12” 就被加入到了 StringTable，所以 c 是 StringTable 中 “12” 的地址。</li>
<li>而 <code>d = a + b</code> 底层会调用 StringBuilder 创建一个新的对象，d 是该对象在堆中的地址。</li>
<li>所以结果为 false。</li>
</ul>
<p>解答类似题目时，需要分析清楚在局部变量表中存放的对象的地址是在 StringTable 中还是在堆中。</p>
<p>2）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringTableTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;2&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;12&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1&quot;</span> + <span class="hljs-string">&quot;2&quot;</span>;<br>        System.out.println(c == d); <span class="hljs-comment">// true</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>其字节码指令：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-number">0</span> ldc #<span class="hljs-number">2</span> &lt;<span class="hljs-number">1</span>&gt;<br> <span class="hljs-number">2</span> astore_1<br> <span class="hljs-number">3</span> ldc #<span class="hljs-number">3</span> &lt;<span class="hljs-number">2</span>&gt;<br> <span class="hljs-number">5</span> astore_2<br> <span class="hljs-number">6</span> ldc #<span class="hljs-number">4</span> &lt;<span class="hljs-number">12</span>&gt;<br> <span class="hljs-number">8</span> astore_3<br> <span class="hljs-number">9</span> ldc #<span class="hljs-number">4</span> &lt;<span class="hljs-number">12</span>&gt;<br><span class="hljs-number">11</span> astore <span class="hljs-number">4</span><br><span class="hljs-number">13</span> getstatic #<span class="hljs-number">5</span> &lt;java/lang/System.out : Ljava/io/PrintStream;&gt;<br><span class="hljs-number">16</span> aload_3<br><span class="hljs-number">17</span> aload <span class="hljs-number">4</span><br><span class="hljs-number">19</span> if_acmpne <span class="hljs-number">26</span> (+<span class="hljs-number">7</span>)<br><span class="hljs-number">22</span> iconst_1<br><span class="hljs-number">23</span> goto <span class="hljs-number">27</span> (+<span class="hljs-number">4</span>)<br><span class="hljs-number">26</span> iconst_0<br><span class="hljs-number">27</span> invokevirtual #<span class="hljs-number">6</span> &lt;java/io/PrintStream.println : (Z)V&gt;<br><span class="hljs-number">30</span> <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure>
<ul>
<li>这一次 c 和 d 都是常量池中 “12” 的地址，所以输出 true。</li>
</ul>
<p>3）关于 intern 方法</p>
<p>之前 StringTable 中的内容都是通过源代码中的常量来进行定义的，而 intern 方法允许手动将字符串放入到 StringTable 中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringTableTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>().append(<span class="hljs-string">&quot;think&quot;</span>).append(<span class="hljs-string">&quot;123&quot;</span>).toString();<br>        System.out.println(s1.intern() == s1);<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>().append(<span class="hljs-string">&quot;ja&quot;</span>).append(<span class="hljs-string">&quot;va&quot;</span>).toString();<br>        System.out.println(s2.intern() == s2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>结果：</p>
<ul>
<li>在 JDK 6 中结果为 false、false。</li>
<li>在 JDK 8 中结果为 true、false。</li>
</ul>
<p>造成的原因：</p>
<ul>
<li>在 JDK 6 时，使用 intern 方法会将该字符串对象尝试放入 StringTable，如果有则并不会放入，如果没有则会把此对象 <strong>拷贝</strong> 一份放入 StringTable，然后将 StringTable 中的对象返回。</li>
<li>而在 JDK 8 时，由于字符串常量池在堆中，为了节省空间，使用 intern 方法会将该字符串对象尝试放入 StringTable，如果有则并不会放入，如果没有则仅仅会放入该对象的 <strong>引用</strong> 到 StringTable。</li>
<li>区别在于：将堆中新创建的字符串对象拷贝到 StringTable 还是放入其引用。</li>
</ul>
<h5 id="StringTable-的回收">StringTable 的回收</h5>
<p>StringTable 会受到垃圾回收器管理的，当内存空间不足时，StringTable 中那些没有被引用的字符串常量也会被回收。</p>
<p>先来看几个虚拟机参数的设置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">-Xmxsize -- 用来指定虚拟机堆内存的最大值;<br>-XX:+PrintStringTableStatistics -- 打印字符串表的统计信息，可以看到串池中的字符串的个数等信息;<br>-XX:+PrintGCDetails -verbose:gc -- 打印垃圾回收的详细信息，包括次数，时间等;<br></code></pre></td></tr></table></figure>
<p>下面的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 演示垃圾回收</span><br><span class="hljs-comment">// JVM 参数：-Xmx10m -XX:+PrintStringTableStatistics -XX:+PrintGCDetails -verbose:gc</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringTableTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            System.out.println(i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>那么来解读一下控制台打印的内容：</p>
<p><img src="/java/jvm-a1fb6fd89ac6/image-20230707140735001.png" srcset="/img/loading.gif" lazyload alt="控制台输出"></p>
<p>StringTable 底层 HashTable 的实现，是由数组 + 链表的结构，每个数组就称为一个桶，那么根据上面的信息，默认的桶（buckets）个数是 60013，entries 就是其中的键值对的个数为 1755，而 literals 就是其中的字符串常量的个数，也就是 1789，后面还展示了一些占用的字节大小信息。</p>
<p>上面的代码什么也没有做，但在 StringTable 里面就已经有了 1755 个字符串对象，这是因为 Java 程序在运行时的一些类名、方法名等也会存入 StringTable。</p>
<p>改动代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 演示垃圾回收</span><br><span class="hljs-comment">// JVM 参数：-Xmx10m -XX:+PrintStringTableStatistics -XX:+PrintGCDetails -verbose:gc</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringTableTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 循环 100 次, 产生 100 个字符串对象存入串池中</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">100</span>; j++) &#123;<br>                String.valueOf(j).intern();<br>                i++;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            System.out.println(i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="/java/jvm-a1fb6fd89ac6/image-20230707140844654.png" srcset="/img/loading.gif" lazyload alt="控制台输出"></p>
<p>此时 entries 和 literals 的数量变为了 1870，这是因为在串池中新加了 100 个字符串对象，此时也不会引发垃圾回收。</p>
<p>接着将 <code>j</code>  变量的循环次数改为 10000 次，再次运行查看结果：</p>
<p><img src="/java/jvm-a1fb6fd89ac6/image-20230707141002927.png" srcset="/img/loading.gif" lazyload alt="控制台输出"></p>
<p>注意：</p>
<ol>
<li>首先循环 10000 次，就是在串池中新加了 10000 个字符串对象。</li>
<li>那么正常来说 entries 和 literals 应该是 10000+，但此时却是 7849，因为触发了垃圾回收（见打印信息），将一些无用的字符串对象回收了。</li>
</ol>
<h5 id="StringTable-性能调优">StringTable 性能调优</h5>
<p>1）设置桶的个数</p>
<p>StringTable 的底层是一种 HashTable 的结构，那么 HashTable 的性能是跟它的桶的个数密切相关的，如果桶的个数比较多，元素相对分散，那么发生哈希碰撞的几率就会减少，查找的效率就会很快，反之，如果桶的个数较少，那么发的哈希碰撞的几率会增大，导致链表较长，从而查找的速率就会很慢。</p>
<p>所以可以通过设置 JVM 参数 <code>-XX:StringTableSize=桶个数</code> 来更改桶的个数，从而加快查找效率。</p>
<p>总结：如果程序里面字符串常量比较多的话，那么就可以适当增多桶的个数，让其有一个更好的哈希分布，减少哈希冲突。</p>
<p>2）考虑将字符串对象入池</p>
<p>对于程序中一些大量的重复的字符串对象，可以考虑将这些字符串对象存入串池，去除重复的对象，减少字符串对内存的占用。</p>
<h3 id="7-直接内存">7. 直接内存</h3>
<h4 id="7-1-概述">7.1 概述</h4>
<p>直接内存（Direct Memory）：并不属于 JVM 虚拟机的内存管理，而是属于操作系统的内存</p>
<ul>
<li>常见于 NIO 操作时，用于数据缓冲区，比如 ByteBuffer 被分配的内存就是直接内存</li>
<li>分配回收成本较高，但读写性能高，因为直接内存属于操作系统的内存，Java 程序分配或者释放直接内存就会慢一些，但是其读写性能非常高。</li>
<li>不受 JVM 内存回收管理</li>
</ul>
<h4 id="7-2-直接内存的读写效率">7.2 直接内存的读写效率</h4>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DirectMemory</span> &#123;<br>    <span class="hljs-comment">// 视频文件大小约 2.55 GB</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">FROM</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;D:\\movie.mp4&quot;</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">TO</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;D:\\jvm\\movie.mp4&quot;</span>;<br>    <span class="hljs-comment">// 读写缓冲区的大小都设为 1MB</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">_1MB</span> <span class="hljs-operator">=</span> <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        io();<br>        directBuffer();<br>    &#125;<br><br>    <span class="hljs-comment">// 使用 ByteBuffer 分配直接内存</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">directBuffer</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.nanoTime();<br>        <span class="hljs-keyword">try</span> (<br>                <span class="hljs-type">FileChannel</span> <span class="hljs-variable">from</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(FROM).getChannel();<br>                <span class="hljs-type">FileChannel</span> <span class="hljs-variable">to</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(TO).getChannel()<br>        ) &#123;<br>            <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">bb</span> <span class="hljs-operator">=</span> ByteBuffer.allocateDirect(_1MB);<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> from.read(bb);<br>                <span class="hljs-keyword">if</span> (len == -<span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                bb.flip();<br>                to.write(bb);<br>                bb.clear();<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.nanoTime();<br>        System.out.println(<span class="hljs-string">&quot;directBuffer 用时：&quot;</span> + (end - start) / <span class="hljs-number">1000_000.0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 传统的 IO 读写</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">io</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.nanoTime();<br>        <span class="hljs-keyword">try</span> (<br>                <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">from</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(FROM);<br>                <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">to</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(TO)<br>        ) &#123;<br>            <span class="hljs-type">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[_1MB];<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> from.read(buf);<br>                <span class="hljs-keyword">if</span> (len == -<span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                to.write(buf, <span class="hljs-number">0</span>, len);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.nanoTime();<br>        System.out.println(<span class="hljs-string">&quot;io 用时：&quot;</span> + (end - start) / <span class="hljs-number">1000_000.0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">directBuffer 用时：<span class="hljs-number">5812.7709</span><br>io 用时：<span class="hljs-number">6182.531</span><br></code></pre></td></tr></table></figure>
<p>使用直接内存进行读写的效率是要高于传统的阻塞 IO 的（特别是在较大的文件的读写上）</p>
<p>原理：</p>
<p>Java 语言并不具备磁盘读写的能力，它必须调用操作系统提供的函数，需要从 <strong>用户态</strong> 切换到了 <strong>内核态</strong>，调用本地方法。</p>
<p>而内存这边也会进行一些操作，当切换到内核态以后，就会由操作系统的函数去读取磁盘文件中的内容，放入系统内存中的一块系统缓冲区，而在系统缓冲区中，Java 代码是不能操作系统缓冲区的，所以 Java 会在堆内存中分出一块 Java 缓冲区（就是代码中的 <code>new byte[]</code>），然后从系统缓冲区中读取数据放入 Java 缓冲区，这一系列操作完了之后，就会从内核态又切换回用户态，去对 Java 缓冲区的数据进行一些输出流的写入操作。</p>
<p>而经过反反复复的上面的过程就完成了一个磁盘文件的读写。</p>
<p>而这样进行磁盘文件的读写是有一个问题的，因为现在存在两块缓冲区，那么就必然涉及到从磁盘文件中拷贝数据到系统缓冲区，而 Java 不能操作系统缓冲区，那么又要把数据拷贝到 Java 缓冲区，这样就造成了不必要的数据的拷贝，所以效率不是很高。</p>
<p><img src="/java/jvm-a1fb6fd89ac6/image-20240121143406072.png" srcset="/img/loading.gif" lazyload alt="不使用直接内存"></p>
<p>而如果使用 Direct Memory</p>
<p><img src="/java/jvm-a1fb6fd89ac6/image-20240121143515843.png" srcset="/img/loading.gif" lazyload alt="直接内存"></p>
<p>当调用 <code>ByteBuffer.allocateDirect()</code> 方法时会在操作系统内存里分配一个指定大小的 <strong>直接内存</strong>，而对于这块 <strong>直接内存</strong>，在 Java 堆中维护了该内存的引用，所以可以直接操作，即对于 Java 和操作系统来说是一个共享的区域。</p>
<p>那么当操作系统的函数从磁盘文件中读取数据后会放入直接内存，Java 代码就可以直接操作，不需要经过系统缓冲区的一次拷贝，自然效率就高了（尤其是在大文件的读写上极为明显）。</p>
<h4 id="7-3-直接内存溢出">7.3 直接内存溢出</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DirectMemoryOver</span> &#123;<br>    <span class="hljs-comment">// 演示直接内存溢出</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">_100MB</span> <span class="hljs-operator">=</span> <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">100</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;ByteBuffer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">byteBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocateDirect(_100MB);<br>                list.add(byteBuffer);<br>                i++;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            System.out.println(i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>输出结果：Direct Momery 也会引发内存溢出，Direct buffer memory</p>
<p><img src="/java/jvm-a1fb6fd89ac6/image-20231105091535983.png" srcset="/img/loading.gif" lazyload alt="直接内存溢出"></p>
<p>在 arthas 中，通过 memory 可以查看直接内存的大小。</p>
<p><img src="/java/jvm-a1fb6fd89ac6/image-20231105091803795.png" srcset="/img/loading.gif" lazyload alt="memory"></p>
<h4 id="7-3-释放原理">7.3 释放原理</h4>
<blockquote>
<p>直接内存不是 JVM 管理的，而是操作系统管理的内存，所以在 Windows 下需要打开任务管理器（Ctrl + Shift + Esc）来查看</p>
</blockquote>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 演示直接内存释放</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DirectMemory</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">_1GB</span> <span class="hljs-operator">=</span> <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">byteBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocateDirect(_1GB);<br>        System.out.println(<span class="hljs-string">&quot;直接内存分配完毕&quot;</span>);<br>        System.in.read();<br>        System.out.println(<span class="hljs-string">&quot;直接内存开始释放&quot;</span>);<br>        byteBuffer = <span class="hljs-literal">null</span>;<br>        System.gc();<br>        System.in.read();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行：</p>
<p><img src="/java/jvm-a1fb6fd89ac6/image-20230707143335506.png" srcset="/img/loading.gif" lazyload alt="任务管理器"></p>
<p>在直接内存分配完毕之后，任务管理器就多了一个约 1 Gb 的 Java 进程，而敲入回车之后，直接内存被释放，该 Java 进程就只有 15.9 MB 的内存。</p>
<p><img src="/java/jvm-a1fb6fd89ac6/image-20230707143512479.png" srcset="/img/loading.gif" lazyload alt="任务管理器"></p>
<p>而上面的代码有两个是直接内存回收可能的原因：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">byteBuffer = <span class="hljs-literal">null</span>;<br>System.gc();<br></code></pre></td></tr></table></figure>
<p>是 byteBuffer 置空导致的直接内存回收还是 JVM 垃圾回收导致的呢？直接内存不受 JVM 内存回收管理，所以是 byteBuffer 置空导致的直接内存回收，那么具体的原理是怎样的呢？看下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用 Unsafe 分配直接内存</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UnsafeTest</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">_1Gb</span> <span class="hljs-operator">=</span> <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">Unsafe</span> <span class="hljs-variable">unsafe</span> <span class="hljs-operator">=</span> getUnsafe();<br>        <span class="hljs-comment">// 调用 Unsafe 对象的方法来分配内存</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">base</span> <span class="hljs-operator">=</span> unsafe.allocateMemory(_1Gb); <span class="hljs-comment">// 返回值就是分配的直接内存的地址</span><br>        unsafe.setMemory(base, _1Gb, (<span class="hljs-type">byte</span>) <span class="hljs-number">0</span>);<br>        System.out.println(<span class="hljs-string">&quot;开始分配内存&quot;</span>);<br>        System.in.read();<br>        <span class="hljs-comment">// 调用 Unsafe 对象的方法来释放内存</span><br>        System.out.println(<span class="hljs-string">&quot;开始释放内存&quot;</span>);<br>        unsafe.freeMemory(base); <span class="hljs-comment">// 根据上面的直接内存的地址来释放内存</span><br>        System.in.read();<br>    &#125;<br><br>    <span class="hljs-comment">// 通过反射获取 Unsafe 对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Unsafe <span class="hljs-title function_">getUnsafe</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> Unsafe.class.getDeclaredField(<span class="hljs-string">&quot;theUnsafe&quot;</span>);<br>            field.setAccessible(<span class="hljs-literal">true</span>);<br>            <span class="hljs-keyword">return</span> (Unsafe) field.get(<span class="hljs-literal">null</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在 Java 中，有一个比较底层的类，Unsafe 类就可以做一些分配内存、释放内存的操作，运行上面的代码：</p>
<p><img src="/java/jvm-a1fb6fd89ac6/image-20230707143856544.png" srcset="/img/loading.gif" lazyload alt="任务管理器"></p>
<p>敲入回车开始释放内存</p>
<p><img src="/java/jvm-a1fb6fd89ac6/image-20230707143953741.png" srcset="/img/loading.gif" lazyload alt="任务管理器"></p>
<p>就说明了，直接内存的管理不是通过 JVM 垃圾回收来管理的，而是通过底层一个 Unsafe 类的方法来进行分配和释放内存的。</p>
<p><strong>ByteBuffer 和 Unsafe 的关联</strong></p>
<p>进入 ByteBuffer 类的 allocateDirect()，在 DirectByteBuffer 构造器里面就调用了 Unsafe 的 allocateMemory 方法和 setMemory 方法来分配直接内存。</p>
<p><img src="/java/jvm-a1fb6fd89ac6/image-20231105092409968.png" srcset="/img/loading.gif" lazyload alt="DirectByteBuffer"></p>
<p>而对于直接内存释放，必须主动调用 Unsafe 对象的 freeMemory 方法，那是怎样实现的呢？</p>
<p>在 DirectByteBuffe 类有一个 Deallocator 回调任务对象（实现了 Runnable 接口），其内部的 run 方法就执行了释放内存的操作。</p>
<p><img src="/java/jvm-a1fb6fd89ac6/image-20231105092846027.png" srcset="/img/loading.gif" lazyload alt="回调对象"></p>
<p>在 DirectByteBuffer 的构造器中有一个虚引用对象 Cleaner，那么在 DirectByteBuffer 的构造器中的这一行代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">cleaner = Cleaner.create(<span class="hljs-built_in">this</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Deallocator</span>(base, size, cap));<br></code></pre></td></tr></table></figure>
<p>当前对象（ByteBuffer，它也是 Java 对象，放在堆中，受 JVM 垃圾回收管理）如果被 JVM 垃圾回收掉了，那么会执行 Cleaner 对象的一个 clean 方法，而这个 clean 方法就会开启一个新的线程来执行 Deallocator 回调任务对象中的 run 方法来释放直接内存。</p>
<p><img src="/java/jvm-a1fb6fd89ac6/image-20231105092710615.png" srcset="/img/loading.gif" lazyload alt="run"></p>
<p>总结：</p>
<ul>
<li>在 ByteBuffer 的实现类内部，使用了 Cleaner（虚引用）来监测 ByteBuffer 对象。</li>
<li>一旦 ByteBuffer 对象被垃圾回收，就会由 ReferenceHandler 线程通过 Cleaner 中的 clean 方法调用 freeMemory 来释放直接内存。</li>
</ul>
<h4 id="7-4-禁用显式回收对直接内存的影响">7.4 禁用显式回收对直接内存的影响</h4>
<p>在做 JVM 调优的时候经常会加一个这样的参数 <code>-XX:+DisableExplicitGC</code> 来禁止显式的垃圾回收。下面的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DirectMemory</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">_1Gb</span> <span class="hljs-operator">=</span> <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br><br>    <span class="hljs-comment">// -XX:+DisableExplicitGC 禁用显式的垃圾回收</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">byteBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocateDirect(_1Gb);<br>        System.out.println(<span class="hljs-string">&quot;直接内存分配完毕&quot;</span>);<br>        System.in.read();<br>        System.out.println(<span class="hljs-string">&quot;直接内存开始释放&quot;</span>);<br>        byteBuffer = <span class="hljs-literal">null</span>;<br>        System.gc(); <span class="hljs-comment">// 无效 FullGC</span><br>        System.in.read();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>对于禁用显式的垃圾回收，就是让代码中的 <code>System.gc()</code> 无效，因为 <code>System.gc()</code> 触发的是一次 Full GC。</p>
<p>这是一种比较影响性能的垃圾回收，不光影响新生代还会影响老年代。而加上上面的参数可能会对直接内存的回收机制造成一定的影响。运行上面的代码：</p>
<p><img src="/java/jvm-a1fb6fd89ac6/image-20230707145459334.png" srcset="/img/loading.gif" lazyload alt="任务管理器"></p>
<p>在敲入回车将 byteBuffer 置空之后，这个 Java 进程的所分配的直接内存并没有被释放，这是因为代码中的 <code>System.gc()</code> 已经无效，那么堆中的内存充足，没有触发垃圾回收机制，所以 byteBuffer 对象没有被回收，那么自然直接内存就得不到释放，这样就会造成直接内存占用较大，长时间得不到释放。</p>
<p>这时只有主动使用 Unsafe 的 freeMemory 方法来手动释放直接内存。</p>
<h2 id="垃圾回收">垃圾回收</h2>
<h3 id="1-概述-3">1. 概述</h3>
<p>Java 中的自动垃圾回收机制，称为 GC（Garbage Collection），通过垃圾回收器来对不再使用的对象完成自动回收。</p>
<p><strong>内存泄漏</strong>：指的是不再使用的对象，在系统中未被回收，而内存泄漏的积累可能会导致 <strong>内存溢出</strong>。</p>
<p>对比于 C/C++ 的手动垃圾回收，</p>
<ol>
<li>自动垃圾回收，降低了程序员编码难度，降低对象回收 bug 的可能性，但是开发人员无法控制内存回收的及时性。</li>
<li>而手动垃圾回收，回收及时性高，由开发人员把控回收的时机，但是编码不当易造成悬空指针、重复释放、内存泄漏等问题。</li>
</ol>
<p>当然并不是说自动垃圾回收机制就不会出现内存泄露，由于开发人员无法控制内存回收的及时性，在某些特定情况下也可能出现内存泄漏。</p>
<p>在垃圾回收中，主要考虑 3 个问题：哪些内存需要回收，什么时候回收以及如何回收。</p>
<p>在 JVM 的内存结构中，程序计数器、虚拟机栈、本地方法栈 3 个区域随线程而生，随线程而灭，栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作，每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的（尽管在运行期会由 JIT 编译器进行一些优化，但大体上可以认为是编译期可知的），因此这几个区域的内存分配和回收都具备确定性，在这几个区域内就不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了。</p>
<p>而堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，只有在程序处于运行期间时才能知道会创建哪些对象，这部分 <strong>内存的分配和回收都是动态</strong> 的，所以垃圾回收所关注的是这部分内存。</p>
<h3 id="2-方法区的回收">2. 方法区的回收</h3>
<p>方法的垃圾回收主要回收两部分内容：废弃常量和无用的类。</p>
<ol>
<li>回收废弃常量与回收 Java 堆中的对象非常类似。以常量池中字面量的回收为例，假如一个字符串 “abc” 已经进入了常量池中，但是当前系统没有任何 String 对象引用常量池中的 “abc” 常量，也没有其他地方引用了这个字面量，如果这时发生内存回收，而且必要的话，这个 “abc” 常量就会被系统清理出常量池。</li>
<li>常量池中的其他类（接口）、方法、字段的符号引用也与此类似。</li>
</ol>
<p>判定一个常量是否是 “废弃常量” 比较简单，而要判定一个类是否是 “无用的类” 的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 “无用的类”：</p>
<ul>
<li>该类所有的实例对象都已经被回收，也就是 Java 堆中不存在该类的任何实例对象以及子类对象。</li>
<li>加载该类的 ClassLoader 已经被回收。</li>
<li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
<p>虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是 “可以”，而并不是和对象一样，不使用了就必然会回收。</p>
<p>是否对类进行回收，HotSpot 虚拟机提供了 <code>-Xnoclassgc</code> 参数进行控制，在大量使用反射、动态代理、CGLib 等 ByteCode 框架、动态生成 JSP 以及 OSGi 这类频繁自定义 ClassLoader 的场景都需要虚拟机具备类卸载的功能，以保证方法区不会溢出。</p>
<p>注意：</p>
<ol>
<li>很多人认为方法区是没有垃圾回收的，在 Java 虚拟机规范中确实说过不要求虚拟机在方法区实现垃圾回收，而且在方法区中进行垃圾回收的 “性价比” 较低，在堆中，尤其是在新生代中，常规应用进行一次垃圾回收一般可以回收 70%～95% 的空间，而方法区的垃圾回收效率远低于此。</li>
<li>两个虚拟机参数
<ul>
<li><code>-XX:+TraceClassLoading</code>：在程序运行时，输出类的加载信息。</li>
<li><code>-XX:+TraceClassUnloading</code>：在类卸载时，输出类的卸载信息。</li>
</ul>
</li>
<li>System.gc() 方法：手动触发垃圾回收，但是调用该方法不一定会立即进行，仅仅向 JVM 发送垃圾回收的请求。</li>
</ol>
<h3 id="3-堆的回收">3. 堆的回收</h3>
<h4 id="3-1-哪些对象可以被回收">3.1 哪些对象可以被回收</h4>
<p>在堆中存放着 Java 中几乎所有的对象实例，垃圾回收器在对堆进行回收前，首先要确定这些对象之中哪些还 “存活” 着，哪些已经 “死去”（即不可能再被任何途径使用的对象）。</p>
<p>在 Java 中，对象是否能被回收，是根据对象是否被 <strong>引用</strong> 来决定的，如果对象被引用了，说明该对象还在使用，则不允许被回收。</p>
<p>常见的有两种判断方法：</p>
<ol>
<li>引用技术法</li>
<li>可达性分析算法</li>
</ol>
<h5 id="引用计数法">引用计数法</h5>
<blockquote>
<p>应用范围：微软 COM 技术、ActionScript 的 Flash Player、Python</p>
</blockquote>
<p>所谓 <strong>引用计数法</strong> （Reference Counting）就是在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一，当引用失效时，计数器值就减一。</p>
<p>任何时刻计数器为零的对象就是不可能再被使用的。</p>
<p>引用计数法占用了一些额外的内存空间来进行计数，但它的原理简单，判定效率也很高，在大多数情况下它都是一个不错的算法。</p>
<p>但是这个看似简单的算法有很多例外情况要考虑，必须要配合大量额外处理才能保证正确地工作，比如单纯的引用计数就很难解决 <strong>对象之间相互循环引用</strong> 的问题。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 引用计数法的循环引用问题</span><br><span class="hljs-comment">// JVM 参数：-XX:+PrintGCDetails -verbose:gc</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReferenceCounting</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">Object</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ReferenceCounting</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceCounting</span>();<br>        <span class="hljs-type">ReferenceCounting</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceCounting</span>();<br><br>        t1.instance = t2;<br>        t2.instance = t1;<br>        t1 = <span class="hljs-literal">null</span>;<br>        t2 = <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">// 发生 GC</span><br>        System.gc();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="/java/jvm-a1fb6fd89ac6/image-20231105113034737.png" srcset="/img/loading.gif" lazyload alt="垃圾回收"></p>
<p>垃圾回收日志中包含 “3906K -&gt; 808K”，意味着虚拟机并没有因为这两个对象互相引用就放弃回收它们，这也从侧面说明了 Java 虚拟机并不是通过引用计数算法来判断对象是否存活的。</p>
<h5 id="可达性分析算法">可达性分析算法</h5>
<p><strong>基本思路</strong></p>
<p>该算法的基本思路就是通过一系列称为 “GC Roots” 的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为 “引用链”（Reference Chain），如果某个对象到 GC Roots 间没有任何引用链相连， 或者用图论的话来说就是从 GC Roots 到这个对象不可达时，则此对象是不可能再被使用的，会被垃圾回收掉。</p>
<p>如图，对象 object 5、object 6、object 7 虽然互有关联，但是它们到 GC Roots 是不可达的， 因此它们将会被判定为可回收的对象。</p>
<p><img src="/java/jvm-a1fb6fd89ac6/image-20240121143829523.png" srcset="/img/loading.gif" lazyload alt="GC Root"></p>
<p><strong>GC Roots 根对象</strong></p>
<p>在 Java 技术体系里面，固定可作为 GC Roots 的对象包括以下几种：</p>
<ul>
<li>线程 Thread 对象，其引用线程栈帧中的方法参数、局部变量等。</li>
<li>系统类加载器加载 java.lang.Class 对象。</li>
<li>监视器对象，用来保存同步锁 synchronized 关键字持有的对象。</li>
<li>本地方法调用时使用的全局对象。</li>
</ul>
<p>除了这些固定的 GC Roots 集合以外，根据用户所选用的垃圾回收器以及当前回收的内存区域不同，还可以有其他对象 “临时性” 地加入，共同构成完整 GC Roots 集合。</p>
<p><strong>查看 GC Root 对象</strong></p>
<p>通过 arthas 和 MAT 工具（eclipse 推出的 Java 堆内存检测工具）可以查看 GC Root。</p>
<ol>
<li>使用 arthas 的 heapdump 命令将堆内存快照保存到本地磁盘。</li>
<li>使用 MAT 工具打开堆内存快照文件。</li>
</ol>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MATTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">A</span> <span class="hljs-variable">a2</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">A</span> <span class="hljs-variable">a1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>();<br>        <span class="hljs-type">B</span> <span class="hljs-variable">b1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">B</span>();<br>        a1.b = b1;<br>        b1.a = a1;<br>        a2 = a1;<br>        System.in.read();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在 MAT 中打开堆内存快照，找到 GC Roots 集合</p>
<p><img src="/java/jvm-a1fb6fd89ac6/image-20231105133903469.png" srcset="/img/loading.gif" lazyload alt="MAT"></p>
<p><strong>循环引用问题</strong></p>
<p>循环引用问题，如果 A 引用 B，B 又引用 A，这 2 个对象是否能被 GC 回收？</p>
<p>关键不是在于 A、B 之间是否有引用，而是 A、B 是否可以一直向上追溯到 GC Roots。如果与 GC Roots 没有关联，则会被回收，否则将继续存活。</p>
<h4 id="3-2-五种引用">3.2 五种引用</h4>
<p>无论是通过引用计数算判断对象的引用数量，还是可达性分析算法判断对象的引用链是否可达，判定对象是否存活都与 “引用” 有关。</p>
<p>在 JDK 1.2 以前，Java 中的引用的定义很传统：如果 reference 类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。这种定义纯粹但太过狭隘，一个对象在这种定义下只有被引用或者没有被引用两种状态，对于如何描述一些可有可无的对象就显得无能为力。</p>
<p>我们希望能描述这样一类对象：当内存空间还足够时，则能保留在内存之中，如果内存空间在进行垃圾回收后还是非常紧张，则可以抛弃这些对象。很多系统的 <strong>缓存</strong> 功能都符合这样的应用场景。</p>
<p>在 JDK 1.2 之后，Java 对引用的概念进行了扩充，将引用分为强引用（Strongly Reference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）4 种，这 4 种引用强度依次逐渐减弱。</p>
<h5 id="强引用">强引用</h5>
<p>强引用是最传统的 “引用” 的定义，是指在程序代码之中普遍存在的引用赋值，即类似 <code>Object obj = new Object()</code> 这种引用关系。</p>
<p>在任何情况下，只要强引用关系还存在，垃圾回收器就永远不会回收掉被引用的对象。</p>
<p>示例：当执行 Strong() 方法，创建了 5 个大小为 4 MB 的 byte 数组，设置堆内存最大为 20MB，强引用的对象在内存回收时不会被回收，所以会出现内存溢出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 演示强引用</span><br><span class="hljs-comment">// JVM 参数：-Xmx20m -XX:+PrintGCDetails -verbose:gc</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StrongReference</span> &#123;<br>    <span class="hljs-comment">// 模拟一些不常用的资源</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">_4MB</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        Strong();<br>    &#125;<br><br>    <span class="hljs-comment">// 强引用</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Strong</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// list ---&gt; 实现的强引用</span><br>        List&lt;<span class="hljs-type">byte</span>[]&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[_4MB]);<br>        &#125;<br>        System.in.read();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/java/jvm-a1fb6fd89ac6/image-20231105151612757.png" srcset="/img/loading.gif" lazyload alt="垃圾回收"></p>
<h5 id="软引用">软引用</h5>
<p>软引用是用来描述一些还有用但非必须的对象，被软引用关联着的对象，在系统将要发生内存溢出前，会把这些对象列进回收范围之中进行垃圾回收，如果这次回收还没有足够的内存， 才会抛出内存溢出异常。</p>
<p>在 JDK 1.2 之后提供了 SoftReference 类来实现软引用。</p>
<p>软应用包含的对象，一定是程序非必要的数据，所以软引用常用于 <strong>缓存</strong> 中，因为缓存一般是为了提升程序访问数据的性能，即便缓存的数据不能再使用，也应该能够通过访问真实的数据继续运行。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 演示软引用</span><br><span class="hljs-comment">// JVM 参数：-Xmx20m -XX:+PrintGCDetails -verbose:gc</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SoftReferenceText</span> &#123;<br>    <span class="hljs-comment">// 模拟一些不常用的资源</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">_4MB</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Soft();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Soft</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// list ---&gt; SoftReference(软引用对象) ---&gt; byte[]</span><br>        List&lt;SoftReference&lt;<span class="hljs-type">byte</span>[]&gt;&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            SoftReference&lt;<span class="hljs-type">byte</span>[]&gt; softReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SoftReference</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[_4MB]);<br>            <span class="hljs-comment">// get() 方法返回 SoftReference 的引用对象即 byte[]</span><br>            <span class="hljs-comment">// 如果该引用对象已被程序或垃圾回收器清除，则此方法返回零</span><br>            <span class="hljs-type">byte</span>[] bytes = softReference.get();<br>            System.out.print(bytes + <span class="hljs-string">&quot; &quot;</span>);<br>            list.add(softReference);<br>            System.out.print(list.size() + <span class="hljs-string">&quot;  &quot;</span>);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;循环结束：&quot;</span> + list.size());<br>        list.forEach(softReference -&gt; System.out.print(softReference.get() + <span class="hljs-string">&quot; &quot;</span>));<br>        System.out.println();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/java/jvm-a1fb6fd89ac6/image-20231105154044849.png" srcset="/img/loading.gif" lazyload alt="垃圾回收"></p>
<p>在创建第 5 个 byte 数组对象的时候分配内存失败进行了一次 Full GC，将软引用所引用的对象进行了回收，所以最后在遍历 list 时，前四个对象为 null。</p>
<p>而此时，前四个 null 对象的软引用本身也没有必要继续存在，因此可以把软引用本身回收掉，更改一下 Soft() 方法，将软引用关联到引用队列，这样当软引用的对象被回收时，该软引用会加入到引用队列，那么我们就可以遍历该队列，将队列中的软引用回收掉。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Soft</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// list ---&gt; SoftReference(软引用对象) ---&gt; byte[]</span><br>    List&lt;SoftReference&lt;<span class="hljs-type">byte</span>[]&gt;&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-comment">// 引用队列</span><br>    ReferenceQueue&lt;<span class="hljs-type">byte</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceQueue</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>        <span class="hljs-comment">// 如果关联了引用队列, 那么当软引用的对象 byte[] 被回收时, 软引用自身会加入 queue 中</span><br>        SoftReference&lt;<span class="hljs-type">byte</span>[]&gt; softReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SoftReference</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[_4MB], queue);<br>        <span class="hljs-comment">// get() 方法返回 SoftReference 的引用对象即 byte[] 如果该引用对象已被程序或垃圾回收器清除，则此方法返回零</span><br>        list.add(softReference);<br>        list.forEach(softRef -&gt; System.out.print(softRef.get() + <span class="hljs-string">&quot; &quot;</span>));<br>        System.out.println();<br>    &#125;<br>    <span class="hljs-comment">// 获取队列中的元素并遍历删除</span><br>    Reference&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">byte</span>[]&gt; poll = queue.poll();<br>    <span class="hljs-keyword">while</span> (poll != <span class="hljs-literal">null</span>) &#123;<br>        list.remove(poll);<br>        poll = queue.poll();<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;循环结束, list 的大小为: &quot;</span> + list.size());<br>    list.forEach(softReference -&gt; System.out.print(softReference.get() + <span class="hljs-string">&quot; &quot;</span>));<br>    System.out.println();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/java/jvm-a1fb6fd89ac6/image-20231105154519274.png" srcset="/img/loading.gif" lazyload alt="垃圾回收"></p>
<h5 id="弱引用">弱引用</h5>
<p>弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾回收发生为止。</p>
<p>当垃圾回收器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。</p>
<p>在 JDK 1.2 之后提供了 WeakReference 类来实现弱引用。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WeakReferenceTest</span> &#123;<br>    <span class="hljs-comment">// 模拟一些不常用的资源</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">_4MB</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Weak();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Weak</span><span class="hljs-params">()</span> &#123;<br>        List&lt;WeakReference&lt;<span class="hljs-type">byte</span>[]&gt;&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">// 引用队列</span><br>        ReferenceQueue&lt;<span class="hljs-type">byte</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceQueue</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            WeakReference&lt;<span class="hljs-type">byte</span>[]&gt; ref = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakReference</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[_4MB], queue);<br>            list.add(ref);<br>            list.forEach(weakRef -&gt; System.out.print(weakRef.get() + <span class="hljs-string">&quot; &quot;</span>));<br>            System.out.println();<br>        &#125;<br>        Reference&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">byte</span>[]&gt; poll = queue.poll();<br>        <span class="hljs-keyword">while</span> (poll != <span class="hljs-literal">null</span>) &#123;<br>            list.remove(poll);<br>            poll = queue.poll();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;循环结束：&quot;</span> + list.size());<br>        list.forEach(weakRef -&gt; System.out.println(weakRef + <span class="hljs-string">&quot; &quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/java/jvm-a1fb6fd89ac6/image-20231105154712603.png" srcset="/img/loading.gif" lazyload alt="垃圾回收"></p>
<p>对于软、弱引用，若没有引用对象，那么自身会进入一个引用队列，我们就可以遍历该队列来删除这些引用。</p>
<h5 id="虚引用">虚引用</h5>
<p>虚引用也称为 “幽灵引用” 或者 “幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。</p>
<p>为一个对象设置虚引用关联的唯一目的是为了能在该对象被垃圾回收时收到一个系统通知。</p>
<p>在 JDK 1.2 版之后提供了 PhantomReference 类来实现虚引用。</p>
<p>如在 ByteBuffer 类中，虚引用的作用体现在 <strong>直接内存</strong> 的释放。</p>
<h5 id="终结器引用">终结器引用</h5>
<p>终结器引用指的是在对象需要被回收时，该引用会关联对象并放置在 Finalizer 类中的引用队列中，在稍后由一条 FinalizerThread 线程从队列中获取对象，然后执行对象的 finalize 方法，在对象第二次被回收时，该对象才真正的被回收。</p>
<p>在这个过程中可以在 finalize 方法中再将自身对象使用强引用关联上，但是不建议这样做，原因在于：</p>
<ul>
<li>对象的 finalize() 只能执行一次。</li>
<li>它的运行代价高昂。</li>
<li>不确定性大。</li>
<li>无法保证各个对象的调用顺序。</li>
</ul>
<h4 id="3-3-垃圾回收算法">3.3 垃圾回收算法</h4>
<h5 id="概述-3">概述</h5>
<p>垃圾回收算法的核心思想：简单来说，垃圾回收主要做两件事，</p>
<ol>
<li>根据可达性分析算法找到堆中存活的对象。</li>
<li>释放不再存活对象的内存，使得程序能再次利用这部分空间。</li>
</ol>
<p>常见的垃圾回收算法主要有 4 种：</p>
<ol>
<li>标记-清除算法（Mark Sweep GC）</li>
<li>复制算法（Copying GC）</li>
<li>标记-整理算法（Mark Compact GC）</li>
<li>分代 GC（Generational GC）</li>
</ol>
<p>这 4 种算法中，标记-清除算法和复制算法是最早诞生的两个算法，本质上后续诞生的垃圾回收算法都是在这两种算法的基础上进行优化，比如标记-整理算法，它就是在标记-清除算法的基础上进行了优化。而分代 GC 算法比较特殊，它会混合使用前 3 种算法。</p>
<p><strong>垃圾回收算法的评价标准</strong></p>
<p>Java 垃圾回收过程会通过单独的 GC 线程来完成，但是不管使用哪一种 GC 算法，都会有部分阶段需要停止所有的用户线程。该过程被称之为 Stop The World（STW），如果 STW 时间过长则会影响用户的使用。</p>
<p>所以判断一个垃圾回收算法是否优秀，可以从 3 个方面考虑：</p>
<ol>
<li>吞吐量：指的是 CPU 用于执行用户代码的时间与 CPU 总执行时间的比值，即吞吐量 = 执行用户代码时间 / (执行用户代码时间 + GC 耗时)，而吞吐量越高，那么垃圾回收的效率就越高。</li>
<li>最大暂停时间：指的是某个时间段在垃圾回收过程中的 STW 时间的最大值。最大暂停时间越短，用户使用系统受到影响就越小。</li>
<li>堆使用效率：不同垃圾回收算法，对堆内存的使用方式是不同的。比如标记-清除算法，可以使用完整的堆内存，而复制算法会将堆内存一分为二，每次只能使用一半内存。从堆使用效率上来说，标记-清除算法要优于复制算法。</li>
</ol>
<p>上述三种评价标准：堆使用效率、吞吐量，以及最大暂停时间不可兼得。 一般来说，堆内存越大，最大暂停时间就越长，想要减少最大暂停时间，就会降低吞吐量。</p>
<p>总之，不同的垃圾回收算法，适用于不同的场景。</p>
<h5 id="标记-清除">标记-清除</h5>
<p>算法分为 “标记” 和 “清除” 两个阶段：</p>
<ol>
<li>首先标记出所有需要回收的对象。</li>
<li>在标记完成后，统一回收掉所有被标记的对象。</li>
<li>也可以反过来，标记存活的对象，统一回收所有未被标记的对象。</li>
</ol>
<p>标记过程就是对象是否属于垃圾的判定过程。 之所以说它是最基础的回收算法，是因为后续的回收算法大多都是以标记清除算法为基础，对其缺点进行改进而得到的。</p>
<p>特点：</p>
<ol>
<li>实现简单。</li>
<li>执行效率不稳定，如果 Java 堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低。</li>
<li>内存空间的碎片化问题，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象（如数组）时无法找到足够的连续内存而不得不提前触发另一次垃圾回收动作。</li>
<li>分配速度慢，由于内存碎片的存在，JVM 需要维护一个空闲链表，极有可能每次需要遍历到链表的最后才能找到合适的空间。</li>
</ol>
<p>图示：</p>
<p><img src="/java/jvm-a1fb6fd89ac6/image-20240121144524842.png" srcset="/img/loading.gif" lazyload alt="垃圾回收"></p>
<h5 id="复制">复制</h5>
<p>算法核心思路：</p>
<ol>
<li>在堆内存中准备两块空间，分别是 From 和 To，每次在对象分配时，只使用其中一块空间（From 空间）</li>
<li>在垃圾回收 GC 阶段，将 From 中存活的对象复制到 To 空间。</li>
<li>将两块空间的引用互换（保证 From 中一定是存活的对象）。</li>
</ol>
<p>特点：</p>
<ol>
<li>吞吐量高：复制算法只需要遍历一次存活对象，将其复制到 To 空间即可，比标记-整理算法少了一次遍历的过程，因而性能较好，但是不如标记-清除算法， 因为标记清除算法不需要进行对象的移动。</li>
<li>不会产生内存碎片问题：复制算法在复制之后就会将对象按顺序放入 To 空间中，所以对象以外的区域都是可用空间，不存在碎片化内存空间。</li>
<li>但是内存使用率低，每次只能使用一半的空间来存放对象。</li>
</ol>
<p>图示：</p>
<p><img src="/java/jvm-a1fb6fd89ac6/image-20240121145047629.png" srcset="/img/loading.gif" lazyload alt="垃圾回收"></p>
<h5 id="标记-整理">标记-整理</h5>
<p>算法分为 “标记” 和 “整理” 两个阶段：</p>
<ol>
<li>标记阶段，使用可达性分析算法，将所有存活的对象进行标记。</li>
<li>整理阶段，将存活的对象移动到堆的另一端，并清理掉剩余的空间。</li>
</ol>
<p>特点：</p>
<ol>
<li>内存利用率高：整个堆内存都可以使用，不会像复制算法只能使用半个堆内存。</li>
<li>不会产生内存碎片化问题：在整理阶段可以将对象往内存的一侧进行移动，剩下的空间都是可以分配对象的有效空间。</li>
<li>但是整理阶段的效率不高：整理算法有很多种，比如 Lisp2 整理算法需要对整个堆中的对象搜索 3 次，性能不佳，可以通过TwoFinger、表格算法、ImmixGC 等高效的整理算法优化此阶段的性能。</li>
</ol>
<p>图示：</p>
<p><img src="/java/jvm-a1fb6fd89ac6/image-20240121145242442.png" srcset="/img/loading.gif" lazyload alt="垃圾回收"></p>
<h5 id="分代-GC">分代 GC</h5>
<p>分代 GC 将整个堆内存划分为 <strong>新生代</strong> 和 <strong>老年代</strong>，在新生代中存放存活时间比较短的对象，而老年代中存放存活时间比较长的对象。</p>
<p>在 <strong>新生代</strong> 中又分为：Eden（伊甸园）、Survivor To（幸存区 To）以及 Survivor From（幸存区 From）。</p>
<p><strong>使用 arthas 查看堆的内存分配</strong></p>
<p>使用的虚拟机参数：</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>参数含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-Xms</td>
<td>设置堆的初始大小，必须是 1024 的整数倍且大于 1M</td>
</tr>
<tr>
<td>-Xmx</td>
<td>设置堆的最大大小，必须是 1024 的整数倍且大于 2M</td>
</tr>
<tr>
<td>-Xmn</td>
<td>设置新生代的大小</td>
</tr>
<tr>
<td>-XX:SurvivorRatio</td>
<td>设置新生代中伊甸园和幸存区的比例，默认为 8</td>
</tr>
<tr>
<td>-XX:+PrintGCDetails -verbose:gc</td>
<td>打印 GC 日志</td>
</tr>
</tbody>
</table>
<p>使用 <code>-Xms60m -Xmx60m -Xmn20m -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc</code>：</p>
<ol>
<li>堆中新生代内存大小为 20M，堆中总大小为 60M，则老年代为 40M。</li>
<li>新生代中幸存区和伊甸园的比例为 8，则伊甸园为 16M，两个 Survivor 区分别为 4M。</li>
</ol>
<p>验证：</p>
<p><img src="/java/jvm-a1fb6fd89ac6/image-20231105172016426.png" srcset="/img/loading.gif" lazyload alt="memory"></p>
<p>分代 GC 算法的过程：</p>
<ol>
<li>在分代回收时，创建出来的对象，首先被放入 Eden 区。</li>
<li>随着对象的增多，Eden 区域满，新创建的对象已经无法放入，就会出发一次年轻的的 GC（Minor GC/Young GC），将 Eden 和 From 区需要回收的对象回收，存活的对象放入 To 区。</li>
<li>接下来，From 和 To 交换引用，并记录对象的年龄（初始值为 0，每次加 1）。</li>
<li>如果在 Minor GC 后对象的年龄达到阈值（最大为 15，默认值与垃圾回收器有关），对象就会晋升至老年代。</li>
<li>当老年代中空间不足，会先尝试一次 Minor GC，若内存还是不足，则会触发 Full GC，对整个堆进行垃圾回收，若 Full GC 后内存依旧不足，则抛出 OutOfMemory 异常。</li>
</ol>
<p>对象进入老年代的情况：</p>
<ul>
<li>超大对象（需要大量连续内存空间的对象，如数组、字符串）直接进入老年代，避免在 Eden 和两个 Survivor 区发生大量的内存复制，使用 <code>-XX:PretenureSizeThreshold</code> 参数设置大对象的阈值，单位为 byte，默认为 0，即不开启。</li>
<li>如果 To 区已满，此时还有对象需要存储，那么会直接晋升老年代。</li>
<li>最后就是上面讲的，长期存活的对象（年龄达到阈值），也会进入老年代。</li>
</ul>
<p>示例：使用下面的程序查看分代 GC 的过程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 虚拟机参数: -Xms60m -Xmx60m -Xmn20m -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MemoryTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        List&lt;Object&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            System.in.read();<br>            System.out.println(++count);<br>            <span class="hljs-comment">// 每次添加 1m 数据</span><br>            list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>为什么分代 GC 把堆分为新生代和老年代？</strong></p>
<p>首先我们要知道，系统中的大部分对象都是 “朝生夕死” 的，即创建出来后很快就不再使用，可以被回收，如用户获取的订单数据，但还有一部分对象需要长期存活，如 Spring 的大部分 bean 对象，在程序启动后就不会被回收。</p>
<p>将堆分为新生代和老年代，那么</p>
<ol>
<li>“朝生夕死” 的对象就可以放入新生代，采用 <strong>复制</strong> 算法，只需要付出少量存活对象的复制成本就可以完成一次垃圾回收。</li>
<li>而存活时间长的对象，就可以放入老年代，使用 <strong>标记-清除</strong> 或者 <strong>标记-整理</strong> 算法进行回收。</li>
<li>在虚拟机的默认设置中，新生代的大小要远小于老年代的大小。</li>
</ol>
<p>这样的好处在于，</p>
<ol>
<li>在分代的设计中，允许只回收新生代（Minor GC），如果能满足对象分配的要求，就不需要对整个堆进行回收（Full GC），STW 的时间就会减少。</li>
<li>可以通过调整新生代和老年代的比例来适应不同类型的应用程序，提高内存的利用率和性能。</li>
</ol>
<h4 id="3-4-垃圾回收器">3.4 垃圾回收器</h4>
<h5 id="概述-4">概述</h5>
<p>垃圾回收算法是内存回收的方法论，那么垃圾回收器就是内存回收的具体实现。</p>
<p>Java 虚拟机规范中对垃圾回收器如何实现并没有任何规定，因此不同的厂商、不同版本的虚拟机所提供的垃圾回收器可能会有很大差别，并且一般都会提供参数供用户根据应用特点和要求组合出各个年代所使用的回收器。</p>
<p>分代 GC 算法将堆分为新生代和老年代，主要目的是降低垃圾回收对系统的影响。在 HotSpot 虚拟机中对垃圾回收算法的实现有多种。</p>
<p>新生代有一批垃圾回收器，老年代也有一批垃圾回收器，且它们之间存在组合关系，不能随意搭配使用。有一个特殊的垃圾回收器 G1，它既可以回收新生代，又可以回收老年代。</p>
<p>图示：</p>
<p><img src="/java/jvm-a1fb6fd89ac6/image-20231105175018931.png" srcset="/img/loading.gif" lazyload alt="垃圾回收器"></p>
<p><strong>如何查看 JVM 默认的垃圾回收器？</strong></p>
<p>1）在终端窗口中输入：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">java -XX:+PrintCommandLineFlags -version<br></code></pre></td></tr></table></figure>
<p>可以查看 JVM 启动时默认添加的参数。</p>
<p><img src="/java/jvm-a1fb6fd89ac6/image-20231105180718625.png" srcset="/img/loading.gif" lazyload alt="查看"></p>
<p>可以看出 JDK 8 默认使用 ParallelScavenge + ParallelOld 回收器。</p>
<p>2）也可以使用下面的命令，查看所有关于 GC 的信息</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">java -XX:+PrintFlagsFinal -version | findstr <span class="hljs-string">&quot;GC&quot;</span><br></code></pre></td></tr></table></figure>
<p>3）在 arthas 中使用 dashboard、memory 命令可以展示垃圾回收信息</p>
<p><img src="/java/jvm-a1fb6fd89ac6/image-20231105181512385.png" srcset="/img/loading.gif" lazyload alt="memory"></p>
<p>可以看出使用的是 Serial + SerialOld 组合的垃圾回收器。</p>
<h5 id="Serial-SerialOld">Serial + SerialOld</h5>
<p><img src="/java/jvm-a1fb6fd89ac6/image-20231105175646598.png" srcset="/img/loading.gif" lazyload alt="Serial + SerialOld"></p>
<h6 id="Serial">Serial</h6>
<p>Serial 是一款新生代垃圾回收器，采用 <strong>复制</strong> 算法，底层是以单线程来串行回收。</p>
<p><strong>单线程</strong> 不仅仅说明它只会使用单个 CPU 或一条回收线程去完成垃圾回收，更重要的是在它进行垃圾回收时，必须暂停其他所有的工作线程，直到它回收结束。</p>
<p>特点：</p>
<ol>
<li>在单 CPU 处理器下吞吐量非常出色。</li>
<li>在用户的桌面应用场景中，分配给虚拟机管理的内存一般不会很大，回收几十或一两百兆的新生代，停顿时间可以控制在几十毫秒到一百多毫秒内，只要不是频繁发生，这点停顿是可以接受的。</li>
<li>但是在多 CPU 下吞吐量不如其他垃圾回收器，堆空间如果偏大，会使用户线程处于长时间的等待。</li>
</ol>
<p>适应场景：Java 编写的客户端程序或者硬件配置有限的场景。</p>
<h6 id="SerialOld">SerialOld</h6>
<p>SerialOld 同样使用单线程串行回收，采用的是 <strong>标记-整理</strong> 算法，特点和 Serial 一致，只不过在某些特殊情况下，CMS 会调用 SerialOld 进行垃圾回收。</p>
<p>通过虚拟机参数：<code>-XX:+UseSerialGC</code>，可以使用 Serial + SerialOld 组合的垃圾回收器。</p>
<h5 id="ParNew-CMS">ParNew + CMS</h5>
<h6 id="ParNew">ParNew</h6>
<p>ParNew 回收器其实就是 Serial 回收器的多线程版本，除了使用多条线程进行垃圾回收外，其余行为包括 Serial 回收器可用的所有控制参数、回收算法、STW、对象分配规则、回收策略等都与 Serial 回收器完全一样，在实现上，这两种回收器也共用了相当多的代码。</p>
<p><img src="/java/jvm-a1fb6fd89ac6/image-20231105181853219.png" srcset="/img/loading.gif" lazyload alt="ParNew"></p>
<p>特点：</p>
<ol>
<li>在多 CPU 下停顿时间较短。</li>
<li>但吞吐量和停顿时间不如 G1，所以在 JDK 9 后不建议使用。</li>
</ol>
<p>适用场景：在 JDK 8 之前的版本，与 CMS 等老年代垃圾回收器搭配使用。</p>
<p>通过虚拟机参数：<code>-XX:+UseParNewGC</code>，可以使用 ParNew + SerialOld 组合的垃圾回收器。</p>
<p>新生代回收器选用 ParNew，老年代选用 CMS 是自 JDK 1.5 以来到 JDK 9，官方一直推荐的服务器端回收器最佳拍档。</p>
<blockquote>
<p>JDK 1.5 发布，HotSpot 推出了一款在强交互应用中几乎可称为具有划时代意义的垃圾回收器——CMS 回收器。这款回收器是 HotSpot 虚拟机中第一款真正意义上<em><strong>支持并发</strong></em>的垃圾回收器，它首次实现了让垃圾回收线程与用户线程（基本上）同时工作。</p>
</blockquote>
<p>自 JDK 9 开始，ParNew + CMS 回收器的组合就不再是官方推荐的服务端模式下的回收器解决方案了。官方希望它能完全被更为先进的，面向全堆的 G1 所取代，甚至还取消了 ParNew + SerialOld 以及 Serial + CMS 这两组回收器组合的支持，从此以后，ParNew 合并入 CMS，成为它专门处理新生代的组成部分。ParNew 可以说是 HotSpot 虚拟机中第一款退出历史舞台的垃圾回收器。</p>
<h6 id="CMS">CMS</h6>
<p>CMS（Concurrent Mark Sweep）垃圾回收器是一种以获取 <strong>最短停顿时间</strong> 为目标的回收器。</p>
<p>目前很大一部分 Java 应用集中在网站或者 B/S 系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。</p>
<p>CMS 回收器就非常符合这类应用的需求，是基于 “标记-清除” 算法实现的，它的运作过程相对于前面几种回收器来说更复杂一些，整个过程分为 4 个步骤，包括：</p>
<ul>
<li>初始标记（initial mark），仅仅只是标记 GC Roots 能直接关联到的对象，会 “STW”，但持续时间很短，速度很快。</li>
<li>并发标记（concurrent mark），从 GC Roots 的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但不需要停顿用户线程，可以与垃圾回收线程一起并发运行。</li>
<li>重新标记（remark），为了修正在并发标记期间，因用户程序继续运作而导致标记产生变动的对象的标记记录（增量更新），这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。</li>
<li>并发清除（concurrent sweep），清理标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以该阶段也可以与用户线程同时并发的。</li>
</ul>
<p>其中 <strong>初始标记</strong> 和 <strong>重新标记</strong> 仍然会 “STW”，但时间较短，所以从总体来说，CMS 回收器的回收过程是与用户线程一起并发执行的。</p>
<p><img src="/java/jvm-a1fb6fd89ac6/image-20230708154652640.png" srcset="/img/loading.gif" lazyload alt="CMS"></p>
<p>通过参数：<code>-XX:+UseConcMarkSweepGC</code>，老年代使用 CMS 垃圾回收器。</p>
<p>缺点：</p>
<p>1）降低总吞吐量</p>
<p>对于面向并发设计的程序，都对处理器资源比较敏感，CMS 在并发标记阶段，虽然不会导致用户线程停顿，但会因为占用了一部分线程而导致应用程序变慢，降低总吞吐量。</p>
<p>CMS 默认启动的回收线程数是 (CPU 数量 + 3) / 4，也就是当 CPU 在 4 个以上时，并发回收时垃圾回收线程不少于 25% 的 CPU 资源，并且随着 CPU 数量的增加而下降。但是当 CPU 不足 4 个（如 2 个）时，CMS 对用户程序的影响就可能变得很大，本来 CPU 负载就比较大，还分出一半的运算能力去执行回收器线程，就可能导致用户程序的执行速度忽然降低了 50%，让人无法接受。</p>
<p>解决方案：升级配置，提升处理器核心数</p>
<p>2）并发失败（Concurrent Mode Failure）问题</p>
<p>CMS 回收器无法处理浮动垃圾（Floating Garbage），可能出现 “Concurrent Mode Failure” 失败而导致另一次 Full GC 的产生。</p>
<blockquote>
<p>执行 CMS GC 的过程中，用户线程也在运行，伴随程序运行自然就会有新的垃圾不断产生，这部分垃圾出现在标记过程之后，CMS 无法在当次回收中处理掉它们，只好留待下一次 GC 时再清理掉。这一部分垃圾就称为 “浮动垃圾”。</p>
</blockquote>
<p>由于在 CMS GC 阶段用户线程还在运行，就需要预留足够的内存给用户线程使用，因此 CMS 回收器不能像其他回收器那样等到老年代几乎完全被填满了再进行回收，需要预留一部分空间提供并发回收时的程序运作使用。</p>
<p>在 JDK 1.5 的默认设置下，CMS 回收器当老年代使用了 68% 的空间后就会被激活，这是一个偏保守的设置，如果在应用中老年代增长不是太快，可以适当调高参数 <code>-XX:CMSInitiatingOccupancyFraction</code> 的值来提高触发百分比，以便降低内存回收次数从而获取更好的性能。</p>
<p>在 JDK 1.6 中，CMS 回收器的启动阈值已经提升至 92%。要是 CMS 运行期间预留的内存无法满足程序需要，就会出现一次 “Concurrent Mode Failure” 失败，这时虚拟机将启动后备预案：临时启用 Serial Old 回收器来重新进行老年代的垃圾回收，这样停顿时间就很长了。</p>
<p>所以参数 <code>-XX:CM SInitiatingOccupancyFraction</code> 设置得太高很容易导致大量 “Concurrent Mode Failure” 失败，性能反而降低。</p>
<p>解决方案：必须预留足够的空间供并发回收时程序运行使用，配置 <code>-XX:CMSInitiatingOccupancyFraction</code> 的值来提高 CMS 的触发百分比，JDK 1.8 默认值是 92%，代表老年代的空间占用率达到 92% 的时候会触发回收过程。</p>
<p>3）内存碎片问题</p>
<p>CMS 是基于 “标记-清除” 算法实现的回收器，这意味着回收结束时会有大量空间碎片产生。空间碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很大空间剩余，但是无法找到足够大的 <strong>连续空间</strong> 来分配当前对象，不得不提前触发一次 Full GC。</p>
<p>解决方案：CMS 回收器提供了一个 <code>-XX:+UseCMSCompactAtFullCollection</code> 开关参数（默认开启），用于在 CMS 回收器不得不进行 Full GC 时开启内存碎片的合并整理过程，由于该过程无法并发，空间碎片的问题没有了，但停顿时间又会变长。虚拟机设计者还提供了另外一个参数 <code>-XX:CMSFullGCsBeforeCompaction</code>（JDK 9 后废除），该参数的作用是要求 CMS 回收器在执行过若干次（数量由参数值决定）不整理空间的 Full GC 之后，下一次进入 Full GC 前会先进行碎片整理（默认值为 0，表示每次进入 Full GC 时都进行碎片整理）。</p>
<p>适用场景：大型的互联网系统中用户请求数据量大、频率高的场景，比如订单接口、商品接口等。</p>
<h5 id="PS-PO">PS + PO</h5>
<h6 id="Parallel-Scavenge">Parallel Scavenge</h6>
<p>Parallel Scavenge 回收器是一个新生代回收器，它也是使用 <strong>复制</strong> 算法的回收器，又是 <strong>并行</strong> 的多线程回收器。</p>
<p>特点：</p>
<ol>
<li>CMS 等回收器的关注点是尽可能地缩短 STW 的时间，而 Parallel Scavenge 回收器的目标则是达到一个 <strong>可控制</strong> 的吞吐量。</li>
<li>由于与吞吐量关系密切，Parallel Scavenge 回收器也经常称为&quot;吞吐量优先&quot;回收器。</li>
<li>优点：可控制的吞吐量、高吞吐量、高效利用 CPU、垃圾回收的自适应的调节策略。</li>
</ol>
<p>STW 时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验，而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</p>
<p>Parallel Scavenge 回收器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾回收停顿时间的 <code>-XX:MaxGCPauseMillis</code> 参数以及直接设置吞吐量大小的 <code>-XX:GCTimeRatio</code> 参数：</p>
<p>1）MaxGCPauseMillis 参数允许的值是一个大于 0 的毫秒数，回收器将尽可能地保证内存回收花费的时间不超过设定值。</p>
<p>2）GCTimeRatio 参数的值应当是一个大于 0 且小于 100 的整数，也就是垃圾回收时间占总时间的比率，相当于是吞吐量的倒数。如果把此参数设置为 19，那允许的最大 GC 时间就占总时间的 5%（即 1 / (1 + 19)），默认值为 99，就是允许最大 1%（即 1 / (1 + 99)）的垃圾回收时间。</p>
<p>Parallel Scavenge 回收器的参数 <code>-XX:+UseAdaptiveSizePolicy</code> 值得关注。这是一个开关参数，当这个参数打开之后，就不需要手动指定新生代的大小（-Xmn）、Eden 与 Survivor 区的比例（-XX:SurvivorRatio）、晋升老年代对象年龄（-XX:PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况回收性能监控信息，动态调整这些参数以提供 <strong>最合适的停顿时间或者最大的吞吐量</strong>，这种调节方式称为 GC 自适应的调节策略（GC Ergonomics）。</p>
<p>如果对于回收器运作原理不太了解，手动优化存在困难的时候，使用 Parallel Scavenge 回收器配合自适应调节策略，把内存管理的调优任务交给虚拟机去完成将是一个不错的选择。</p>
<p>只需要把基本的内存数据设置好（如 -Xmx 设置最大堆），然后使用 MaxGCPauseMillis 参数（更关注最大停顿时间）或 GCTimeRatio（更关注吞吐量）参数给虚拟机设立一个优化目标，那具体细节参数的调节工作就由虚拟机完成了。</p>
<p>自适应调节策略也是 Parallel Scavenge 回收器与 ParNew 回收器的一个重要区别。</p>
<h6 id="ParallelOld">ParallelOld</h6>
<p>Parallel Old 是 Parallel Scavenge 收集器的老年代版本，使用多线程和 “标记-整理” 算法。</p>
<p>这个收集器是在 JDK 1.6 中才开始提供的，在此之前，新生代的 Parallel Scavenge 收集器一直处于比较尴尬的状态，原因是，如果新生代选择了 Parallel Scavenge 收集器，老年代除了 Serial Old 收集器外别无选择（Parallel Scavenge 收集器无法与 CMS 收集器配合工作），由于老年代 Serial Old 收集器在服务端应用性能上的 “拖累”，使用了 Parallel Scavenge 收集器也未必能在整体应用上获得吞吐量最大化的效果，在老年代很大而且硬件比较高级的环境中，这种组合的吞吐量甚至还不一定有 ParNew + CMS 的组合 “给力”。</p>
<p>直到 Parallel Old 收集器出现后，“吞吐量优先” 收集器终于有了比较名副其实的应用组合，在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge + Parallel Old 收集器。</p>
<p>使用参数：<code>-XX:+UseParallelGC</code> 或者 <code>-XX:+UseParallelOldGC</code> 可以使用 PS + PO 的组合。</p>
<h5 id="G1">G1</h5>
<h6 id="概述-5">概述</h6>
<p>在 JDK 9 之后，默认的垃圾回收器就是 G1（Garbage First）。</p>
<ul>
<li>Parallel Scavenge 回收器关注的是吞吐量，允许用户设置最大暂停时间，但是会减少新生代可用空间的大小。</li>
<li>CMS 关注最大暂停时间，但是吞吐量会下降。</li>
</ul>
<p>而 G1 回收器的目标就是融合上面两种垃圾回收器的优点：</p>
<ol>
<li>支持巨大的堆空间回收，并具有较大的吞吐量。</li>
<li>支持多 CPU 并行垃圾回收</li>
<li>允许 用户设置最大暂停时间。</li>
</ol>
<p>G1 垃圾回收器将堆内存划分成了一些大小相等的区域（Region），分为 Eden，Survivor、Old、Humongous 区。</p>
<p>每一个 Region 的大小为：</p>
<ol>
<li>可以通过 (堆空间大小 / 2048) 得到</li>
<li>也可以通过参数 <code>-XX:G1HeapRegionSize=值</code> 指定。取值范围为 1m 到 32m，且只能是 2 的幂数。</li>
</ol>
<p>如：</p>
<p><img src="/java/jvm-a1fb6fd89ac6/image-20240121145637502.png" srcset="/img/loading.gif" lazyload alt="G1"></p>
<h6 id="垃圾回收方式">垃圾回收方式</h6>
<p>G1 垃圾回收器有两种方式：</p>
<ol>
<li>新生代回收（Young GC）</li>
<li>混合回收（Mixed GC）</li>
</ol>
<p>新生代回收，主要是回收 Eden 区和 Survivor 区中不用的对象，该过程会导致 STW。</p>
<p>在 G1 中可以通过参数 <code>-XX:MaxGCPauseMillis=n</code>（默认 200）设置每次垃圾回收时最大暂停时间毫秒数，G1 垃圾回收器会尽量保证暂停时间。</p>
<p>新生代的回收流程：</p>
<ol>
<li>首先新创建的对象会分配到 Eden 区，随着不断的添加，G1 会判断出新生代内存不足，阈值默认是 60%，即当新生代中 Eden 和 Survivor 占了总堆的 60% 以上时，会产生 Young GC。</li>
<li>标记 Eden 和 Survivor 区中的存活对象。</li>
<li>根据配置的最大暂停时间选择某些区域将存活对象复制到新的 Survivor 区中（对象年龄加 1），并清空这些区域，由于使用 “标记-复制” 算法，并不会产生内存碎片。</li>
<li>后续的 Young GC 与上面相同，只是将 Survivor 区中存活的对象搬运到另一个 Survivor 区。</li>
<li>当某个存活对象的年龄达到阈值，将被放入老年代。</li>
<li>注意，对于部分大小超过 Region 一半的大对象，会直接放入老年代，这部分老年代也被称为 Humongous 区（横跨多个 Region）</li>
<li>多次回收后，出现了很多 Old 区，当 Old 区在总堆占有率达到阈值（<code>-XX:InitiatingHeapOccupancePercent</code> 默认 45%）时，会触发混合回收，即 Mixed GC，回收所有新生代、老年代和 Humongous 区的对象，采用复制算法。</li>
</ol>
<p>注意：G1 在进行 Young GC 的过程中会记录每次垃圾回收时每个 Eden 区和 Survivor 区的平均耗时，以作为下次回收时的参考。这样就可以根据配置的最大暂停时间计算出本次回收时最多能回收 Region 区域的数量。</p>
<p>比如 <code>-XX:MaxGCPauseMillis=200</code> 每个 Region 回收耗时 40ms，那么这次回收最多只能回收 4 个 Region 区域。</p>
<p>混合回收，分为四个阶段：</p>
<ol>
<li>初始标记（initial mark）：仅仅只是标记 GC Roots 能直接关联到的对象，会 “STW”，但持续时间很短，速度很快。</li>
<li>并发标记（concurrent mark）：从 GC Roots 的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但不需要停顿用户线程，可以与垃圾回收线程一起并发运行。</li>
<li>重新标记（remark）：为了修正在并发标记期间，由于引用改变而漏标的对象（即由于引用的改变而重新存活的对象），对于引用的改变而变为垃圾的对象，G1 会等到下一次 Mixed GC 再去处理。所以 G1 的重复标记阶段，要远比 CMS 来的快。</li>
<li>并发清理（cleanup）：采用复制算法，不会产生内存碎片，可以和用户线程并行执行，对于该阶段，G1 也做了深层次的优化，它不会将所有的区域全部进行回收，对于老年代， G1 只会选择一些存活率较低的区域来进行回收，这样保证回收效率最高，这也是 G1 名称的由来。</li>
</ol>
<p>注意：如果清理过程中没有足够的空 Region 存放转移的对象，会触发 Full GC，使用单线程执行 “标记-整理” 算法， 此时会导致用户线程的暂停，所以尽量保证堆内存有一定多余的空间。</p>
<h5 id="总结-2">总结</h5>
<p>垃圾回收器的组合关系虽然很多，但是针对几个特定的版本，比较好的组合选择如下：</p>
<ul>
<li>JDK 8 及之前： ParNew + CMS（关注暂停时间）、Parallel Scavenge + Parallel Old（关注吞吐量）、 G1（JDK 8 之前不建议）</li>
<li>JDK 9 之后：G1（默认，较大堆并且关注暂停时间）</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/java/" class="category-chain-item">java</a>
  
  
    <span>></span>
    
  <a href="/categories/java/jvm/" class="category-chain-item">jvm</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/java/" class="print-no-link">#java</a>
      
        <a href="/tags/jvm/" class="print-no-link">#jvm</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>JVM 基础</div>
      <div>http://ocsio.cn/java/jvm-a1fb6fd89ac6/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Ocsio</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年12月30日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/algorithm-8393765408a3/" title="单模式串匹配算法">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">单模式串匹配算法</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/java/redis-75ba9f9c982a/" title="redis 中的 IO 模型">
                        <span class="hidden-mobile">redis 中的 IO 模型</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <div> <span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span> <script src="/js/duration.js"></script> </div><br/> 
    </div>
  
  
  
    <!-- 备案信息 ICP for China -->
    <div class="beian">
  <span>
    <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
      蜀ICP备2023042935号-1
    </a>
  </span>
  
</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
