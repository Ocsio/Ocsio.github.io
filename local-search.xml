<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>代码随想录刷题—双指针</title>
    <link href="/algorithm-06b58ff8b1b5/"/>
    <url>/algorithm-06b58ff8b1b5/</url>
    
    <content type="html"><![CDATA[<h1>双指针</h1>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
      <tag>twoPointer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码随想录刷题—哈希表</title>
    <link href="/algorithm-e91e34dd231e/"/>
    <url>/algorithm-e91e34dd231e/</url>
    
    <content type="html"><![CDATA[<h1>哈希表</h1><h2 id="1-有效的字母异位词">1. 有效的字母异位词</h2><h3 id="1-1-有效的字母异位词">1.1 有效的字母异位词</h3><blockquote><p><a href="https://leetcode.cn/problems/valid-anagram/">242. 有效的字母异位词</a></p></blockquote><p>首先统计 s 串词频，然后在遍历 t 串的过程中，逐步将词频减一，一旦出现字符的出现次数为负数，那么就不是有效的字母异位词。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isAnagram</span><span class="hljs-params">(String s, String t)</span> &#123;<br>    <span class="hljs-keyword">if</span> (s.length() != t.length()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-type">int</span>[] fre = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>        fre[s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; t.length(); i++) &#123;<br>        <span class="hljs-keyword">if</span> (--fre[t.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>] &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度：</p><ul><li>时间：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>空间：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，由于题目中只有 26 个英文字符，所以空间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li></ul><h3 id="1-2-其他题目">1.2 其他题目</h3><h4 id="383-赎金信">383. 赎金信</h4><blockquote><p><a href="https://leetcode.cn/problems/ransom-note/">383. 赎金信</a></p></blockquote><p>该题目和 <a href="https://leetcode.cn/problems/valid-anagram/">242. 有效的字母异位词</a> 非常类似。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canConstruct</span><span class="hljs-params">(String ransomNote, String magazine)</span> &#123;<br>    <span class="hljs-type">int</span>[] fre = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; magazine.length(); i++) &#123;<br>        fre[magazine.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; ransomNote.length(); i++) &#123;<br>        <span class="hljs-keyword">if</span> (--fre[ransomNote.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>] &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度：</p><ul><li>时间：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>空间：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，由于题目中只有 26 个英文字符，所以空间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li></ul><h4 id="49-字母异位词分组">49. 字母异位词分组</h4><blockquote><p><a href="https://leetcode.cn/problems/group-anagrams/">49. 字母异位词分组</a></p></blockquote><p>由于同一组的的字母异位词的字符串的字母相同，所以我们对字符串排序之后得到的字符串一定是相同的，所以将排序后的字符串作为哈希表的键，而值为该字符串应该所在的集合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">groupAnagrams</span><span class="hljs-params">(String[] strs)</span> &#123;<br>    HashMap&lt;String, List&lt;String&gt;&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (String str : strs) &#123;<br>        <span class="hljs-type">char</span>[] chars = str.toCharArray();<br>        Arrays.sort(chars);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(chars);<br>        List&lt;String&gt; list = map.getOrDefault(s, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>        list.add(str);<br>        map.put(s, list);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(map.values());<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度</p><ul><li>时间：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>k</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nklogk)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">nk</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>，n 表示 strs 中的字符数量，k 是 strs 中的字符串的最大长度。</li><li>空间：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nk)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">nk</span><span class="mclose">)</span></span></span></span></li></ul><h4 id="438-找到字符串中所有字母异位词">438. 找到字符串中所有字母异位词</h4><blockquote><p><a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/">438. 找到字符串中所有字母异位词</a></p></blockquote><p>解决方案是使用固定窗口大小为 p 串长度的滑动窗口，不断右滑，比较窗口内的词频和 p 串的词频是否相等，相等则加入窗口左边界的索引到 ans 集合，最后返回该集合即可。</p><p>本题的一个核心思路是，两个互为异位词的字符串的长度一定相等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">findAnagrams</span><span class="hljs-params">(String s, String p)</span> &#123;<br>    List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">if</span> (p.length() &gt; s.length()) &#123;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-type">int</span>[] fre_p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>    <span class="hljs-type">int</span>[] fre_s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; p.length(); i++) &#123;<br>        fre_p[p.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        fre_s[s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (Arrays.equals(fre_s, fre_p)) &#123;<br>        ans.add(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">winL</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">winR</span> <span class="hljs-operator">=</span> p.length(); winR &lt; s.length(); winR++) &#123;<br>        fre_s[s.charAt(winR) - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        fre_s[s.charAt(winL++) - <span class="hljs-string">&#x27;a&#x27;</span>]--;<br>        <span class="hljs-keyword">if</span> (Arrays.equals(fre_s, fre_p)) &#123;<br>            ans.add(winL);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度：</p><ul><li>时间：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m+n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>空间：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li></ul><h2 id="2-两个数组的交集">2. 两个数组的交集</h2><blockquote><p><a href="https://leetcode.cn/problems/intersection-of-two-arrays/">349. 两个数组的交集</a></p></blockquote><h3 id="2-1-两个数组的交集">2.1 两个数组的交集</h3><p>很简单，没啥说的，就两个 Set 去重，再判断是否 contains 即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] intersection(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2) &#123;<br>    HashSet&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>    HashSet&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums1) &#123;<br>        set.add(num);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums2.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (set.contains(nums2[i])) &#123;<br>            ans.add(nums2[i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans.stream().mapToInt(Integer::intValue).toArray();<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度：</p><ul><li>时间：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m+n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>空间：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>，不考虑结果数组</li></ul><h3 id="2-2-其他题目">2.2 其他题目</h3><h4 id="350-两个数组的交集-II">350. 两个数组的交集 II</h4><blockquote><p><a href="https://leetcode.cn/problems/intersection-of-two-arrays-ii/">350. 两个数组的交集 II</a></p></blockquote><p>先遍历 nums1，利用 HashMap 求出数频，然后遍历 nums2，记录结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] intersect(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2) &#123;<br>    HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums1) &#123;<br>        map.put(num, map.getOrDefault(num, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums2) &#123;<br>        <span class="hljs-keyword">if</span> (map.containsKey(num) &amp;&amp; map.get(num) &gt; <span class="hljs-number">0</span>) &#123;<br>            ans.add(num);<br>            map.put(num, map.get(num) - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans.stream().mapToInt(Integer::intValue).toArray();<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度：</p><ul><li>时间：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m+n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>空间：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>，不考虑结果数组</li></ul><h2 id="3-快乐数">3. 快乐数</h2><blockquote><p><a href="https://leetcode.cn/problems/happy-number/">202. 快乐数</a></p></blockquote><p>两种思路：</p><ol><li>使用 set 记录每一个计算结果，当某一次的计算结果已经在 set 中，那么对于这个数，你一直计算下去也是走老路，就会陷入死循环。</li><li>或许你可以联想到弗洛伊德判环算法，判断是否有环，可以定义快慢指针，快指针一次移动两步，慢指针一次移动一步，若两个指针相遇则说明出现了环，就不是快乐数了。</li></ol><p>当然，这道题，还有一个小难点是如何进行各位平方的计算。</p><p>再说一句，这道题的复杂度分析，可以查找力扣的官解。</p><p>思路 1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isHappy</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    HashSet&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">calc</span> <span class="hljs-operator">=</span> calc(n);<br>        <span class="hljs-keyword">if</span> (calc == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (set.contains(calc)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            set.add(calc);<br>            n = calc;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calc</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span>) &#123;<br>        ans += (n % <span class="hljs-number">10</span>) * (n % <span class="hljs-number">10</span>);<br>        n /= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度：</p><ul><li>时间：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>空间：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li></ul><p>思路 2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isHappy</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> n, fast = n;<br>    <span class="hljs-keyword">do</span> &#123;<br>        slow = calc(slow);<br>        fast = calc(fast);<br>        fast = calc(fast);<br>    &#125; <span class="hljs-keyword">while</span> (slow != fast);<br>    <span class="hljs-keyword">return</span> slow == <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calc</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span>) &#123;<br>        ans += (n % <span class="hljs-number">10</span>) * (n % <span class="hljs-number">10</span>);<br>        n /= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度：</p><ul><li>时间：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>空间：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li></ul><h2 id="4-两数之和">4. 两数之和</h2><blockquote><p><a href="https://leetcode.cn/problems/two-sum/">1. 两数之和</a></p></blockquote><p>不说了，简单题，想当年我第一次刷力扣，碰到这道题是多么的狼狈。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>    HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (map.containsKey(target - nums[i])) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;i, map.get(target - nums[i])&#125;;<br>        &#125;<br>        map.put(nums[i], i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度：</p><ul><li>时间：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>空间：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li></ul>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
      <tag>hashmap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis 中的 IO 模型</title>
    <link href="/java/redis-75ba9f9c982a/"/>
    <url>/java/redis-75ba9f9c982a/</url>
    
    <content type="html"><![CDATA[<h1>redis 中的 IO 模型</h1><p>之前我们讨论到 redis 为什么那么快时，提到了 redis 中的 IO 模型，为了说明 redis 中的 IO 模型，又不得不提到那几种 IO 模型。</p><h2 id="五种-IO-模型">五种 IO 模型</h2><p>在《操作系统》这门课中，我们已经知道了什么是用户空间和内核空间、什么是普通指令和特权指令、什么是用户态和内核态。</p><p>在某些情况下，用户程序需要调用一些特权资源或者是调用一些内核空间的操作，那么此时需要在用户态和内核态之间进行切换。</p><p>如 Linux 系统为了提高 IO 效率，会在用户空间和内核空间加入缓冲区：</p><ul><li>写数据（写到磁盘或网卡）时，将用户缓冲数据拷贝到内核缓冲区，然后写入磁盘或网卡。</li><li>读数据（读到内存）时，要从设备读取数据到内核缓冲区，然后拷贝到用户缓冲区。</li></ul><p>所以，用户程序在读写数据时，会向内核态申请，读取内核的数据，而内核数据要等待驱动程序从硬件上读取数据，当从磁盘或网卡上加载到数据之后，内核会将数据写入到内核的缓冲区中，然后再将数据拷贝到用户态的 buffer 中，然后再返回给应用程序。</p><p>这个过程的速度较慢，主要体现在下面两点：</p><ol><li>用户程序在 read 读数据时，如果内核空间没有将数据准备好，写入到 buffer，那么用户进程则需要等待。</li><li>数据的拷贝，数据需要从内核空间向用户空间拷贝。</li></ol><p>为了提升性能，我们希望 read 或者 wait for read 最好不要等待，或者等待的时间尽量的短。</p><p>上面描述的过程如下图所示：</p><p><img src="/java/redis-75ba9f9c982a/image-20240113032829044.png" alt="过程"></p><p>而在《UNIX 网络编程》一书中，描述了 5 种 IO 模型：</p><ul><li>阻塞 IO（Blocking IO）</li><li>非阻塞 IO（Nonblocking IO）</li><li>IO 多路复用（IO Multiplexing）</li><li>信号驱动 IO（Signal Driven IO）</li><li>异步 IO（Asynchronous IO）</li></ul><h3 id="阻塞-IO">阻塞 IO</h3><p>所谓阻塞 IO，是指在用户从发起读请求开始，一直到读取到数据，都是阻塞的状态。</p><p>过程如下图：</p><p><img src="/java/redis-75ba9f9c982a/image-20240113143358701.png" alt="阻塞 IO"></p><p>用户读取数据时，发起 recvform 命令，尝试从内核加载数据，如果内核没有数据，则用户进入阻塞，此时内核从硬件上读取数据，内核读取数据之后，会把数据拷贝到用户态，并且返回，整个过程，都是阻塞的，这就是阻塞 IO。顾名思义，阻塞 IO 就是两个阶段都必须阻塞等待。</p><p>阶段一：用户进程尝试读取数据（如网卡数据、磁盘数据），此时数据尚未到达，内核需要等待数据，用户进程也处于阻塞状态。</p><p>阶段二：数据到达并拷贝到内核缓冲区，代表已就绪，内核将内核数据拷贝到用户缓冲区，拷贝过程中，用户进程依然阻塞，只有当拷贝完成，用户进程重新恢复运行，处理数据。</p><p>在阻塞 IO 模型中，用户进程在两个阶段都是阻塞状态。</p><h3 id="非阻塞-IO">非阻塞 IO</h3><p>非阻塞 IO，就是指 recvfrom 操作会立即返回结果而不是阻塞用户进程。</p><p><img src="/java/redis-75ba9f9c982a/image-20240113143506342.png" alt="非阻塞 IO"></p><p>在非阻塞 IO 模型中，用户进程第一个阶段是非阻塞，而第二个阶段是阻塞状态。</p><p>虽然是非阻塞，但性能并没有得到提高。而且轮询机制会导致 CPU 空转，CPU 使用率暴增。</p><h3 id="IO-多路复用">IO 多路复用</h3><p>无论是阻塞 IO 还是非阻塞 IO，在一阶段，用户程序都需要调用 recvfrom 来获取数据，要么是阻塞，要么是不断轮询，都不能充分发挥 CPU 的作用。</p><p>所以这两种方式性能都不太好。</p><p>而在单线程下，只能依次处理 IO 事件，而像阻塞 IO 和非阻塞 IO 这种需要排队等待，如果正在处理的 IO 事件未就绪（数据不可读或不可写），线程就会被阻塞或者持续 CPU 导致空转，所有其他的 IO 事件都必须等待。</p><p>对于这种情况，我们不妨打个比喻，就像在餐馆点餐，多个顾客和一个服务员：</p><ul><li>阻塞 IO：顾客们排队等待，只能一个接一个的点，服务员也只能一次处理一个顾客的请求。</li><li>非阻塞 IO：顾客们也是排队等待，但是服务员不断询问队头的顾客，直到这个顾客点完为止。</li></ul><p>而现在的餐馆，一般是这样的，顾客进餐馆后，直接找到座位坐下，然后用手机扫描桌上的二维码进行点餐，服务员只需要在点餐台的电脑上查看有哪些顾客点了餐，并将这些交给厨师准备就可以了。</p><p>事实上，这样的流程就类似于 IO 多路复用，其模型如下：</p><p><img src="/java/redis-75ba9f9c982a/image-20240113144131327.png" alt="IO 多路复用"></p><p>在上面的例子中，服务员通过点餐台的电脑知道有顾客点好餐了，那么在 IO 模型中，用户进程是如何知道内核中数据是否就绪呢？</p><p>这个问题的解决依赖于 Linux 中的文件描述符（File Descriptor）简称 FD，它是一个从 0 开始的无符号整数，用来关联 Linux 中的一个文件。在 Linux 中，一切皆文件，如常规文件、视频、硬件设备等，当然也包括网络套接字（Socket）。</p><p>阶段一：用户进程调用 select，指定要监听的 FD 集合，那么内核就会监听 FD 对应的多个 socket，任意一个或多个 socket 数据就绪则返回 readable，这个过程中用户进程阻塞。</p><p>阶段二：用户进程找到就绪的 socket，依次调用 recvfrom 读取数据，内核将数据拷贝到用户空间后，用户进程处理数据。</p><p>当用户进程读取数据时，不再直接调用 recvfrom，而是调用 select 函数，select 函数会将需要监听的 FD 交给内核，由内核去检查 FD 的数据是否就绪了，如果数据就绪，就会通知用户进程数据就绪，然后来读取数据，再从内核中把数据拷贝给用户态，完成数据处理，如果 N 多个 FD 一个都没处理完，此时就进行等待。</p><p>像 select 这样的系统调用，存在多种，常见的有：</p><ul><li>select</li><li>poll</li><li>epoll</li></ul><p>大致说明它们的区别，select 和 poll 在监听的数据准备好后，会将用户进程监听的整个 FD 集合拷贝到用户空间，用户进程需要在其中遍历，找到真正处理好的数据。</p><p>而 epoll，则是在内核将数据准备好后，将准备好的数据直接拷贝到用户空间，避免了遍历的开销。</p><p>IO 复用模式，用户进程阻塞在 select、poll、epoll 等系统调用上，而不是阻塞在 recvfrom 上，可以确保去读数据的时候，数据是一定存在的，其效率比原来的阻塞 IO 和非阻塞 IO 性能都要高。</p><h4 id="select-模式">select 模式</h4><p>select 模式是 Linux 早期使用的 IO 多路复用技术。</p><p>相关源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 类型别名 __fd_mask</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> __fd_mask;<br><br><span class="hljs-comment">/* fd_set 记录要监听的fd集合，及其对应状态 */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-comment">// fds_bits 是 long 类型数组，长度为 1024 / 32 = 32</span><br>    <span class="hljs-comment">// 共 1024 个 bit 位，每个 bit 位代表一个 fd，0 代表未就绪，1 代表就绪</span><br>    <span class="hljs-comment">// bitmap 的形式</span><br>    __fd_mask fds_bits[__FD_SETSIZE / __NFDBITS];<br>    <span class="hljs-comment">// ...</span><br>&#125; fd_set;<br><br><span class="hljs-comment">/* select 函数，用于监听 fd_set，也就是多个 fd 的集合 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">select</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-type">int</span> nfds, <span class="hljs-comment">// 要监视的 fd_set 的最大 fd + 1</span></span><br><span class="hljs-params">    fd_set *readfds,<span class="hljs-comment">// 要监听读事件的 fd 集合</span></span><br><span class="hljs-params">    fd_set *writefds,   <span class="hljs-comment">// 要监听写事件的 fd 集合</span></span><br><span class="hljs-params">    fd_set *exceptfds,  <span class="hljs-comment">// 要监听异常事件的 fd 集合</span></span><br><span class="hljs-params">    <span class="hljs-keyword">struct</span> timeval *timeout <span class="hljs-comment">// 超时时间，null-用不超时；0-不阻塞等待；大于0-固定等待时间</span></span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure><p>将要处理的数据封装为 FD，并在用户空间创建 FD 的数组（大小为监听的 FD 的最大值 + 1，但最大不超过 1023），同时在数组中，需要标识控制哪些数据。</p><p>假设要监听的 socket 连接，其 FD 为 1、2、5，那么此时执行 select 函数，并将整个 fd 数组拷贝到内核空间，内核遍历整个数组，看是否有已经准备就绪的数据，若没有则内核进入阻塞，否则内核向用户进程返回可读条件，此时用户进程发起 recvfrom 系统调用，同时内核将 fd 数组再次拷贝到用户空间，拷贝完成后，向用户进程返回成功指示。</p><p>select 模式存在的问题是：</p><ul><li>整个 fd 数组在用户空间和内核空间需要拷贝两次。</li><li>由于内核将整个 fd 数组拷贝到用户空间，所以用户进程需要遍历整个 fd 数组才能知道哪些数据就绪。</li><li>整个 fd 数组的大小是固定的，是 1024。</li></ul><h4 id="poll-模式">poll 模式</h4><p>poll 模式对 select 模式做了简单改进，但性能提升不明显。</p><p>相关源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// pollfd 中的事件类型</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> POLLIN     <span class="hljs-comment">// 可读事件</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> POLLOUT    <span class="hljs-comment">// 可写事件</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> POLLERR    <span class="hljs-comment">// 错误事件</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> POLLNVAL   <span class="hljs-comment">// fd 未打开</span></span><br>...<br><br><span class="hljs-comment">// pollfd 结构</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pollfd</span> &#123;</span><br>    <span class="hljs-type">int</span> fd;        <span class="hljs-comment">// 要监听的 fd</span><br>    <span class="hljs-type">short</span> <span class="hljs-type">int</span> events;  <span class="hljs-comment">// 要监听的事件类型：读、写、异常</span><br>    <span class="hljs-type">short</span> <span class="hljs-type">int</span> revents; <span class="hljs-comment">// 实际发生的事件类型</span><br>&#125;;<br><br><span class="hljs-comment">// poll 函数</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">poll</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-keyword">struct</span> pollfd *fds, <span class="hljs-comment">// pollfd 数组，可以自定义大小</span></span><br><span class="hljs-params">    <span class="hljs-type">nfds_t</span> nfds,    <span class="hljs-comment">// 数组元素个数</span></span><br><span class="hljs-params">    <span class="hljs-type">int</span> timeout <span class="hljs-comment">// 超时时间</span></span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure><p>具体 IO 流程</p><ul><li>首先创建 pollfd 数组，向其中添加监听的 fd 的信息，由于可以自定义数组大小，所以理论上能够监听的 fd 的数量是无限的。</li><li>接着调用 poll 函数，将 pollfd 数组拷贝到内核空间，转为链表存储，无上限。</li><li>然后内核遍历 fd，判断是否就绪。</li><li>如果数据就绪或超时后，则拷贝 pollfd 数组到用户空间，返回就绪 fd 的数量 n。</li><li>用户进程判断 n 是否大于 0，大于 0 则遍历 pollfd 数组，找到就绪的 fd 进一步处理。</li></ul><p><strong>与 select 对比</strong></p><ul><li>select 模式中的 fd_set 大小固定为 1024，而 pollfd 在内核中采用链表，理论上无上限。</li><li>但是如果监听 fd 越多，每次遍历消耗时间也越久，性能反而会下降，所以实际上 poll 模式中的 fd 个数也不是无限的。</li></ul><h4 id="epoll-模式">epoll 模式</h4><p>epoll 模式是相对于 select 和 poll 的巨大的改进。它主要提供了 3 个函数。相关源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">eventpoll</span> &#123;</span><br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rb_root</span>  <span class="hljs-title">rbr</span>;</span>     <span class="hljs-comment">// 红黑树，记录要监听的 FD</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">rdlist</span>;</span> <span class="hljs-comment">// 链表，记录就绪的 FD</span><br>    <span class="hljs-comment">//...</span><br>&#125;;<br><br><span class="hljs-comment">// 1.创建一个 epoll 实例，内部是 event poll，返回对应的句柄 epfd</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">epoll_create</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span>;<br><br><span class="hljs-comment">// 2.将一个 FD 添加到 epoll 的红黑树中，并设置 ep_poll_callback</span><br><span class="hljs-comment">// callback 触发时，就把对应的 FD 加入到 rdlist 就绪列表中</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">epoll_ctl</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-type">int</span> epfd,     <span class="hljs-comment">// epoll 实例的句柄</span></span><br><span class="hljs-params">    <span class="hljs-type">int</span> op,       <span class="hljs-comment">// 要执行的操作，包括：ADD、MOD、DEL</span></span><br><span class="hljs-params">    <span class="hljs-type">int</span> fd,       <span class="hljs-comment">// 要监听的 FD</span></span><br><span class="hljs-params">    <span class="hljs-keyword">struct</span> epoll_event *event  <span class="hljs-comment">// 要监听的事件类型：读、写、异常等</span></span><br><span class="hljs-params">)</span>;<br><br><span class="hljs-comment">// 3.检查 rdlist 列表是否为空，不为空则返回就绪的 FD 的数量</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">epoll_wait</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-type">int</span> epfd,                   <span class="hljs-comment">// epoll 实例的句柄</span></span><br><span class="hljs-params">    <span class="hljs-keyword">struct</span> epoll_event *events, <span class="hljs-comment">// 空 event 数组，用于接收就绪的 FD</span></span><br><span class="hljs-params">    <span class="hljs-type">int</span> maxevents,              <span class="hljs-comment">// events 数组的最大长度</span></span><br><span class="hljs-params">    <span class="hljs-type">int</span> timeout   <span class="hljs-comment">// 超时时间，-1 用不超时；0 不阻塞；大于 0 为阻塞时间</span></span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure><p>具体 IO 流程：</p><ul><li>用户进程首先调用 epoll_create 创建 epoll 实例，并返回对应的句柄 epfd。</li><li>接着调用 epoll_ctl 将一个 fd 添加到 epoll 实例中的红黑树中，并设置对应的回调 ep_poll_callback。当该回调触发时，就会将对应的 fd 从红黑树中添加到就绪链表中。</li><li>然后调用 epoll_wait，此时会在用户空间创建一个空的 events 数组存放就绪的 fd，并检查就绪链表，该过程需要参考配置的 timeout，看是一直等待、等待指定的时间或者不等待。</li><li>假设此时数据准备完毕，那么就会触发 ep_poll_callback，并将就绪的 fd 添加到就绪队列，恰好此时调用了 epoll_wait，检查就绪队列发现有数据，就会将数据拷贝到 event 数组中，并返回对应就绪的 fd 的数量，用户进程收到响应后，从 events 中获取对应的数据，并处理。</li></ul><p>epoll 相比于 poll 和 select 的优化在什么地方？</p><ul><li>首先，select 模式，它主要做了两件事，即监听 fd，将 fd 拷贝到内核，以及等待这些 fd 就绪。而 epoll 模式将这两个功能拆分为了两个函数，epoll_ctl 就是监听 fd，而 epoll_wait 才是等待 fd 就绪，那么如果监听一个 fd，epoll 模式中只需要 <strong>执行一次</strong> epoll_ctl 将 fd 加入到红黑树即可，以后都是循环执行 epoll_wait，所以这就避免了在 select 模式中不断将整个 fd 数组在内核空间和用户空间的来回拷贝的情况。</li><li>其次，在 select 模式和 poll 模式中，每一次需要把内核中的所有 fd 都拷贝回用户空间，无论是就绪还是没就绪，而 epoll 模式只需要拷贝就绪的 fd，这也提升了性能，同时，用户进程也无需像在 select 和 poll 模式那样遍历整个 fd 数组，找到就绪的 fd，因为 epoll 模式中拷贝到用户空间的都是就绪的 fd，那么用户进程可以直接获取使用。</li><li>最后是 fd 的数量问题，select 模式中，能监听的 fd 数组的最大数量就是 1024，而在 poll 模式中，底层采用链表存储这些 fd，虽然允许监听的 fd 的数量没有上限，但是如果 fd 数量过多，遍历链表的性能不可忽略，而在 epoll 模式中，使用红黑树存储监听的 fd，而红黑树的性能是很稳定的，不会因为节点的增多导致查询性能的下降，所以 epoll 模式是真的可以尽可能多的监听 fd。</li></ul><h4 id="事件通知机制">事件通知机制</h4><p>当 fd 可读时，调用 epoll_wait 可以得到通知，但是通知的模式有两种：</p><ul><li>LevelTriggered：LT，当 fd 有数据可读时，会重复通知用户进程多次，每调用一次 epoll_wait 则通知一次，直到数据处理完毕，这是 epoll 的默认模式。</li><li>EdgeTriggered：ET，当 fd 有数据可读时，无论数据是否处理完毕，用户进程都只会被通知一次。</li></ul><p>一个例子：</p><ul><li>假设一个客户端 socket 对应的 fd 已经注册到了 epoll 实例中。</li><li>客户端 socket 发送了 2kb 的数据。</li><li>服务端调用 epoll_wait，并得到内核的可读通知。</li><li>那么服务端从 fd 读取了 1kb 数据。</li><li>由于数据没有读完毕，所以需要再次调用 epoll_wait 循环读取。</li></ul><p>如果采用 LT 模式，因为 fd 中仍有 1kb 数据未读，则循环调用 epoll_wait，此时用户进程会再一次得到可读通知。而如果采用 ET 模式，那么在第一次调用 epoll_wait 时，用户进程已经得到一次可读通知，后续即使数据没有读完，也不会再接受到可读通知。</p><p>采用 LT 模式，那么通知频率很高，会存在很多重复通知，影响性能，同时可能出现惊群现象，而 ET 模式只会通知一次，效率高，我们可以基于非阻塞 IO 循环读取解决数据读取不完整问题。</p><h3 id="信号驱动-IO">信号驱动 IO</h3><p>信号驱动 IO 是与内核建立 SIGIO 的信号处理程序并设置回调，当内核有 FD 就绪时，会发出 SIGIO 信号通知用户，期间用户应用可以执行其它业务，无需阻塞等待。</p><p>阶段一：用户进程调用 sigaction，注册信号处理函数，此时用户进程不进入阻塞，可以执行其它业务，当内核数据就绪后，回调用户进程的 SIGIO 处理函数。</p><p>阶段二：用户进程收到 SIGIO 回调信号，则调用 recvfrom，内核将数据拷贝到用户空间，接着用户进程处理数据。</p><p>但是当有大量 IO 操作时，信号较多，SIGIO 处理函数不能及时处理可能导致信号队列溢出，而且内核空间与用户空间的频繁信号交互性能也较低。</p><p><img src="/java/redis-75ba9f9c982a/image-20240113144831625.png" alt="信号驱动 IO"></p><h3 id="异步-IO">异步 IO</h3><p>用户进程先内核发起 aio_read 系统调用，该系统调用立即返回，并且在等待 IO 期间，用户进程不会阻塞，当内核将将数据从内核空间拷贝到用户空间后，由内核通知用户进程数据准备完毕。</p><p>与信号驱动 IO 的区别：</p><ul><li>信号驱动 IO 是由内核通知用户进程何时启动一个 IO 操作。</li><li>异步 IO 是由内核通知用户进程何时 IO 操作完成。</li></ul><p><img src="/java/redis-75ba9f9c982a/image-20240113145231698.png" alt="异步 IO"></p><h3 id="几种-IO-模型的对比">几种 IO 模型的对比</h3><p>前 4 种模型的主要区别在于阶段一的处理，因为它们的阶段二是一致的，都是在数据从内核复制到用户空间，进程阻塞于 recvfrom 调用。而异步 IO 没有阻塞阶段。</p><p>这里就可以描述同步 IO 和异步 IO：</p><ul><li>同步 IO：导致请求进程阻塞，直到 IO 操作完成。</li><li>异步 IO：不会导致请求进程阻塞。</li></ul><p>所以只有异步 IO 模型是一种异步 IO 操作。</p><p><img src="/java/redis-75ba9f9c982a/image-20240113145915698.png" alt="对比"></p><h2 id="redis-中的-IO-模型">redis 中的 IO 模型</h2>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-938c4142" role="button" aria-expanded="false" aria-controls="collapse-938c4142">        <div class="fold-arrow">▶</div>源码下载      </div>      <div class="fold-collapse collapse" id="collapse-938c4142">        <div class="fold-content">          <p><a href="https://github.com/redis/redis/releases">下载 redis 6.2.6</a></p>        </div>      </div>    </div>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-9997dce9" role="button" aria-expanded="false" aria-controls="collapse-9997dce9">        <div class="fold-arrow">▶</div>了解 java nio      </div>      <div class="fold-collapse collapse" id="collapse-9997dce9">        <div class="fold-content">          <p><a href="/java/javase-beb1cfdacc32/" title="java nio">java nio</a></p>        </div>      </div>    </div><p>我们在上面已经说明了五种 IO 模型，那么接下来说说在 redis 中的 IO 模型。</p><p>在 redis 中，通过 IO 多路复用来提高网络性能，并且支持各种不同的多路复用实现，如 epoll、evport、kqueue、select，并对这些实现进行了封装，提供了统一的高性能时间 API 库：</p><p>通过判断当前系统来选择具体的 IO 多路复用的实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Include the best multiplexing layer supported by this system.</span><br><span class="hljs-comment"> * The following should be ordered by performances, descending. */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> HAVE_EVPORT</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ae_evport.c&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> HAVE_EPOLL</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ae_epoll.c&quot;</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>        <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> HAVE_KQUEUE</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ae_kqueue.c&quot;</span></span><br>        <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>        <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ae_select.c&quot;</span></span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>并提供了统一的封装的 API（在 src/ae.c）。</p><p>下面主要来看看 ae_epoll.c 文件，重要方法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 创建多路复用程序</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">aeApiCreate</span><span class="hljs-params">(aeEventLoop *eventLoop)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    state-&gt;epfd = epoll_create(<span class="hljs-number">1024</span>);<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// 注册 fd</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">aeApiAddEvent</span><span class="hljs-params">(aeEventLoop *eventLoop, <span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> mask)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">if</span> (epoll_ctl(state-&gt;epfd,op,fd,&amp;ee) == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// 删除 fd</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">aeApiDelEvent</span><span class="hljs-params">(aeEventLoop *eventLoop, <span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> delmask)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">if</span> (mask != AE_NONE) &#123;<br>        epoll_ctl(state-&gt;epfd,EPOLL_CTL_MOD,fd,&amp;ee);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">/* Note, Kernel &lt; 2.6.9 requires a non null event pointer even for</span><br><span class="hljs-comment">         * EPOLL_CTL_DEL. */</span><br>        epoll_ctl(state-&gt;epfd,EPOLL_CTL_DEL,fd,&amp;ee);<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// 等待 fd 就绪</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">aeApiPoll</span><span class="hljs-params">(aeEventLoop *eventLoop, <span class="hljs-keyword">struct</span> timeval *tvp)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    retval = epoll_wait(state-&gt;epfd,state-&gt;events,eventLoop-&gt;setsize,<br>        tvp ? (tvp-&gt;tv_sec*<span class="hljs-number">1000</span> + (tvp-&gt;tv_usec + <span class="hljs-number">999</span>)/<span class="hljs-number">1000</span>) : <span class="hljs-number">-1</span>);<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>那么接下来通过源码流程来看一下 redis 的 IO 模型到底是怎样运行的。</p><p>首先你需要找到 redis 的启动函数 main 函数，在 server.c 文件中，源码如下，这里我只给出了有关 IO 模型的重点源码部分：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">// 初始化服务</span><br>    initServer();<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">// 开始监听事件循环</span><br>    aeMain(server.el);<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们继续看 initServer 函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">initServer</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">// aeCreateEventLoop 内部会调用 aeApiCreate</span><br>    server.el = aeCreateEventLoop(server.maxclients+CONFIG_FDSET_INCR);<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">/* Open the TCP listening socket for the user commands. */</span><br>    <span class="hljs-comment">// 监听 TCP 端口，创建 ServerSocket，并得到 FD</span><br>    <span class="hljs-keyword">if</span> (server.port != <span class="hljs-number">0</span> &amp;&amp;<br>        listenToPort(server.port,&amp;server.ipfd) == C_ERR) &#123;<br>        serverLog(LL_WARNING, <span class="hljs-string">&quot;Failed listening on port %u (TCP), aborting.&quot;</span>, server.port);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">/* Create an event handler for accepting new connections in TCP and Unix</span><br><span class="hljs-comment">     * domain sockets. */</span><br>    <span class="hljs-comment">// 创建一个事件处理器，处理客户端连接，内部调用 aeApiAddEvent 监听当前 serverSocket FD</span><br>    <span class="hljs-comment">// 而 acceptTcpHandler 就是一个接受 TCP 请求的处理器</span><br>    <span class="hljs-comment">// 当有客户端连接到 ServerSocket，那么就会触发 acceptTcpHandler，这类似于回调机制</span><br>    <span class="hljs-keyword">if</span> (createSocketAcceptHandler(&amp;server.ipfd, acceptTcpHandler) != C_OK) &#123;<br>        serverPanic(<span class="hljs-string">&quot;Unrecoverable error creating TCP socket accept handler.&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">/* Register before and after sleep handlers (note this needs to be done</span><br><span class="hljs-comment">     * before loading persistence since it is used by processEventsWhileBlocked. */</span><br>    <span class="hljs-comment">// 设置 epoll_wait 前的处理器</span><br>    aeSetBeforeSleepProc(server.el,beforeSleep);<br>    aeSetAfterSleepProc(server.el,afterSleep);<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>所以，initServer 函数，主要就做这么几件事，我们以 epoll 模式来说明：</p><ol><li>创建 epoll 实例，在内核中，相当于已经准备好了红黑树和链表。</li><li>接下来创建 ServerSocket，得到 FD，即上面代码中的 listenToPort。</li><li>然后将调用 createSocketAcceptHandler 函数，内部调用 aeApiAddEvent 监听当前的 server.ipfd，并绑定对应的回调处理方法，即 acceptTcpHandler，用于当客户端连接到 ServerSocket 时，触发该函数处理连接事件。</li><li>接下来你会发现调用了一个 aeSetBeforeSleepProc 函数，这是因为，在监听 FD 后，用户进程就会调用 epoll_wait 函数，等待 FD 就绪，这里就是在设置调用 epoll_wait 之前的处理器。</li></ol><p>当 initServer 调用完毕，那么准备工作就做好了，但是还没有开始真正调用 epoll_wait。</p><p>接下来看 aeMain 函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">aeMain</span><span class="hljs-params">(aeEventLoop *eventLoop)</span> &#123;<br>    eventLoop-&gt;stop = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (!eventLoop-&gt;stop) &#123;<br>        aeProcessEvents(eventLoop, AE_ALL_EVENTS|<br>                                   AE_CALL_BEFORE_SLEEP|<br>                                   AE_CALL_AFTER_SLEEP);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>继续跟进 aeProcessEvents</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">aeProcessEvents</span><span class="hljs-params">(aeEventLoop *eventLoop, <span class="hljs-type">int</span> flags)</span><br>&#123;<br>    <span class="hljs-comment">// 调用 epoll_wait 的前置处理器</span><br>    <span class="hljs-keyword">if</span> (eventLoop-&gt;beforesleep != <span class="hljs-literal">NULL</span> &amp;&amp; flags &amp; AE_CALL_BEFORE_SLEEP)<br>        eventLoop-&gt;beforesleep(eventLoop);<br><br>    <span class="hljs-comment">/* Call the multiplexing API, will return only on timeout or when</span><br><span class="hljs-comment">     * some event fires. */</span><br>    <span class="hljs-comment">// 等待 FD 就绪或者超时，返回就绪的 FD 的数量</span><br>    numevents = aeApiPoll(eventLoop, tvp);<br><br>    <span class="hljs-comment">/* After sleep callback. */</span><br>    <span class="hljs-comment">// 调用 epoll_wait 的后置处理器</span><br>    <span class="hljs-keyword">if</span> (eventLoop-&gt;aftersleep != <span class="hljs-literal">NULL</span> &amp;&amp; flags &amp; AE_CALL_AFTER_SLEEP)<br>        eventLoop-&gt;aftersleep(eventLoop);<br><br>    <span class="hljs-comment">// 循环处理就绪的 FD，调用对应的处理器</span><br>    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; numevents; j++) &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>此时一旦有客户端连接上来，那么 aeApiPoll 函数返回就绪 FD 的数量，并调用相应的处理器，对于 ServerSocket 来说，就是上面的 acceptTcpHandler 处理器，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">acceptTcpHandler</span><span class="hljs-params">(aeEventLoop *el, <span class="hljs-type">int</span> fd, <span class="hljs-type">void</span> *privdata, <span class="hljs-type">int</span> mask)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">while</span>(max--) &#123;<br>        <span class="hljs-comment">// 返回客户端连接的 FD</span><br>        cfd = anetTcpAccept(server.neterr, fd, cip, <span class="hljs-keyword">sizeof</span>(cip), &amp;cport);<br>        <span class="hljs-comment">// ... </span><br>        <span class="hljs-comment">// 接受连接的处理器</span><br>        acceptCommonHandler(connCreateAcceptedSocket(cfd),<span class="hljs-number">0</span>,cip);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 acceptCommonHandler 函数中的的一个重要函数是 createClient，创建客户端：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">client *<span class="hljs-title function_">createClient</span><span class="hljs-params">(connection *conn)</span> &#123;<br>    client *c = zmalloc(<span class="hljs-keyword">sizeof</span>(client));<br>    <span class="hljs-keyword">if</span> (conn) &#123;<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-comment">// 注册读处理器 readQueryFromClient，并在连接可读的时候被触发</span><br>        connSetReadHandler(conn, readQueryFromClient);<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">return</span> c;<br>&#125;<br></code></pre></td></tr></table></figure><p>整个服务端的注册和监听流程基本就是这样。</p><p>下面来看看客户端发送命令后的执行流程：</p><p>紧接着上面的 readQueryFromClient 函数，这是在客户端连接可读时触发的回调函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">readQueryFromClient</span><span class="hljs-params">(connection *conn)</span> &#123;<br>    <span class="hljs-comment">// 获取当前客户端，在客户端中有读写缓冲区</span><br>    client *c = connGetPrivateData(conn);<br><span class="hljs-comment">/* Check if we want to read from the client later when exiting from</span><br><span class="hljs-comment">     * the event loop. This is the case if threaded I/O is enabled. */</span><br>    <span class="hljs-comment">// 在 postponeClientRead 函数中，会调用 listAddNodeHead 函数将客户端添加到 server.clients_pending_read</span><br>    <span class="hljs-comment">// 队列，等待被写出</span><br>    <span class="hljs-keyword">if</span> (postponeClientRead(c)) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">// 获取查询缓冲区 querybuf 的大小</span><br>    qblen = sdslen(c-&gt;querybuf);<br>    <span class="hljs-keyword">if</span> (c-&gt;querybuf_peak &lt; qblen) c-&gt;querybuf_peak = qblen;<br>    c-&gt;querybuf = sdsMakeRoomFor(c-&gt;querybuf, readlen);<br>    <span class="hljs-comment">// 读取请求数据到 querybuf 缓冲区</span><br>    nread = connRead(c-&gt;conn, c-&gt;querybuf+qblen, readlen);<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">// 解析客户端中缓冲区字符串，转换为 redis 命令存入 c-&gt;argv 数组</span><br>    processInputBuffer(c);<br>&#125;<br></code></pre></td></tr></table></figure><p>跟入 processInputBuffer：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">processInputBuffer</span><span class="hljs-params">(client *c)</span> &#123;<br>    <span class="hljs-comment">// </span><br>    <span class="hljs-comment">/* We are finally ready to execute the command. */</span><br>    <span class="hljs-comment">// 真正开始执行命令</span><br>    <span class="hljs-keyword">if</span> (processCommandAndResetClient(c) == C_ERR) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>跟入 processCommandAndResetClient：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">processCommandAndResetClient</span><span class="hljs-params">(client *c)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">if</span> (processCommand(c) == C_OK) &#123;<br>        commandProcessed(c);<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>跟入 processCommand：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">processCommand</span><span class="hljs-params">(client *c)</span> &#123;<br>    <span class="hljs-comment">// 根据命令名称，查找命令对应的 command</span><br>    <span class="hljs-comment">/* Now lookup the command and check ASAP about trivial error conditions</span><br><span class="hljs-comment">     * such as wrong arity, bad command name and so forth. */</span><br>    c-&gt;cmd = c-&gt;lastcmd = lookupCommand(c-&gt;argv[<span class="hljs-number">0</span>]-&gt;ptr);<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">/* Exec the command */</span><br>    <span class="hljs-comment">// 执行命令</span><br>    <span class="hljs-keyword">if</span> (c-&gt;flags &amp; CLIENT_MULTI &amp;&amp;<br>        c-&gt;cmd-&gt;proc != execCommand &amp;&amp; c-&gt;cmd-&gt;proc != discardCommand &amp;&amp;<br>        c-&gt;cmd-&gt;proc != multiCommand &amp;&amp; c-&gt;cmd-&gt;proc != watchCommand &amp;&amp;<br>        c-&gt;cmd-&gt;proc != resetCommand)<br>    &#123;<br>        queueMultiCommand(c);<br>        <span class="hljs-comment">// 将执行结果写出</span><br>        addReply(c,shared.queued);<br>    &#125; <br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>跟入 addReply：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">addReply</span><span class="hljs-params">(client *c, robj *obj)</span> &#123;<br>    <span class="hljs-comment">// ... </span><br>    <span class="hljs-keyword">if</span> (sdsEncodedObject(obj)) &#123;<br>        <span class="hljs-comment">// 尝试将结果写入 c-&gt;buf 客户端写缓冲区，若 c-&gt;buf 写不下则写入 c-&gt;reply</span><br>        <span class="hljs-keyword">if</span> (_addReplyToBuffer(c,obj-&gt;ptr,sdslen(obj-&gt;ptr)) != C_OK)<br>            _addReplyProtoToList(c,obj-&gt;ptr,sdslen(obj-&gt;ptr));<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (obj-&gt;encoding == OBJ_ENCODING_INT) &#123;<br>        <span class="hljs-comment">/* For integer encoded strings we just convert it into a string</span><br><span class="hljs-comment">         * using our optimized function, and attach the resulting string</span><br><span class="hljs-comment">         * to the output buffer. */</span><br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">32</span>];<br>        <span class="hljs-type">size_t</span> len = ll2string(buf,<span class="hljs-keyword">sizeof</span>(buf),(<span class="hljs-type">long</span>)obj-&gt;ptr);<br>        <span class="hljs-keyword">if</span> (_addReplyToBuffer(c,buf,len) != C_OK)<br>            _addReplyProtoToList(c,buf,len);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        serverPanic(<span class="hljs-string">&quot;Wrong obj-&gt;encoding in addReply()&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么此时，结果就已经保存到了客户端的写缓冲区中，并且已经添加到了一个名为 server.clients_pending_read 的队列中，但是结果还没有写到 socket。</p><p>那么将结果写到 socket，这就要靠 beforeSleep 函数了，在这个函数中，有很多处理函数，用来处理不同的问题，其中与写结果相关的函数是 handleClientsWithPendingWritesUsingThreads</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">beforeSleep</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> aeEventLoop *eventLoop)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br> <span class="hljs-comment">/* Handle writes with pending output buffers. */</span><br>    handleClientsWithPendingWritesUsingThreads();<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>跟入 handleClientsWithPendingWritesUsingThreads：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">handleClientsWithPendingWritesUsingThreads</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">// 将迭代器指向 server.clients_pending_write 的队头</span><br>    listRewind(server.clients_pending_write,&amp;li);<br>    <span class="hljs-keyword">while</span>((ln = listNext(&amp;li))) &#123;<br>        client *c = listNodeValue(ln);<br>        <span class="hljs-keyword">if</span> (clientHasPendingReplies(c) &amp;&amp;<br>            <span class="hljs-comment">// 内部调用 aeApiAddEvent 监听 socket 的 FD 读事件</span><br>            <span class="hljs-comment">// 并绑定写处理器 sendReplyToClient，将响应写到客户端 socket</span><br>                connSetWriteHandler(c-&gt;conn, sendReplyToClient) == AE_ERR)<br>        &#123;<br>            freeClientAsync(c);<br>        &#125;<br>    &#125;<br>    listEmpty(server.clients_pending_write);<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>那么 sendReplyToClient 处理器就会调用 writeToClient 将结果写回到客户端。</p><p>最后再来看一下 redis 底层 IO 模型的整个流程：</p><p><img src="/java/redis-75ba9f9c982a/image-20240114145235824.png" alt="流程"></p><ul><li>首先会创建一个 ServerSocket，并将其 FD 注册到 EventLoop 上，这个 EventLoop 可以理解为一个 epoll 实例。</li><li>接着为 ServerSocket 绑定一个处理器 tcpAccpetHandler 来处理 ServerSocket 上的可读事件。</li><li>接下来执行 beforeSleep，执行完成如果还没有客户端连接上来，那么就调用 aeApiPoll 去等待就绪。</li><li>此时有客户端连接上来，就会触发 ServerSocket 上的读事件，并调用对应的处理器，将客户端 socket 的 FD 注册到 EventLoop 上。</li><li>此时 EventLoop 已经注册了 ServerSocket 和 Socket 的 FD，那么此时如果客户端 socket 可读，就会触发 socket 上的读事件，此时就会调用 readQueryFromClient 处理器，将请求数据写到客户端的查询缓冲区，并将其解析为 redis 命令，执行命令后将结果写到 buf 或者 reply，写好后将客户端加入到 server.clients_pending_write 队列。</li><li>然后在 beforeSleep 函数中，调用 handleClientsWithPendingWritesUsingThreads 函数，遍历 server.clients_pending_write 队列为每一个客户端绑定一个 sendReplyToClient 处理器，而 EventLoop 会监听 socket 连接的写事件，并在可写时调用这个处理器，真正的将客户端缓冲区的数据写到客户端的 socket 中。</li></ul><p>而实际上，你将整体看的简单一点，redis 的 IO 模型主要是上图中灰色的部分，它整体上就是 <strong>IO 多路复用和事件派发</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis 中有哪些高效的数据结构</title>
    <link href="/java/redis-25334f7a71a2/"/>
    <url>/java/redis-25334f7a71a2/</url>
    
    <content type="html"><![CDATA[<h1>redis 中有哪些高效的数据结构</h1><p>redis 性能如此优秀和高效的数据结构也离不开关系。</p><p>redis 中，数据是按键值对的方式存储的，而键值对又是按照一定的数据结构来组织的，操作键值对就是对数据结果进行 CRUD 操作。</p><p>所以高效的数据结构是 redis 快速处理数据的基础。</p><p>在 redis 中，值的数据类型有 String（字符串）、List（列表）、Hash（哈希）、Set（集合）和 Sorted Set（有序集合），而这些数据类型的底层则是由简单动态字符串、双向链表、压缩列表、哈希表、跳表以及整数数组构成的，它们的对应关系如下：</p><p><img src="/java/redis-25334f7a71a2/image-20240116172332248.png" alt="数据结构"></p><p>可以看到，String 类型的底层实现只有一种数据结构，也就是简单动态字符串。而 List、Hash、Set 和 Sorted Set 这四种数据类型，都有两种底层实现结构。通常情况下，我们会把这四种类型称为集合类型，它们的特点是 <strong>一个键对应了一个集合的数据</strong>。</p><p>而 redis 中的键则总是一个字符串对象 String。</p><p>为了实现客户端的键值访问，redis 使用一个全局哈希表来保存所有的键值对，而对于集合类型的值，则全局哈希表中存储的是指向该集合的指针（redis 用 c 写的）。</p><p><img src="/java/redis-25334f7a71a2/image-20240116173049145.png" alt="全局哈希表"></p><p>下面我们一一来看这些数据结构。</p>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-938c4142" role="button" aria-expanded="false" aria-controls="collapse-938c4142">        <div class="fold-arrow">▶</div>源码下载      </div>      <div class="fold-collapse collapse" id="collapse-938c4142">        <div class="fold-content">          <p><a href="https://github.com/redis/redis/releases">下载 redis 6.2.6</a></p>        </div>      </div>    </div><h2 id="1-简单动态字符串-SDS">1. 简单动态字符串 SDS</h2>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-076edf11" role="button" aria-expanded="false" aria-controls="collapse-076edf11">        <div class="fold-arrow">▶</div>源码位置      </div>      <div class="fold-collapse collapse" id="collapse-076edf11">        <div class="fold-content">          <figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">src</span><span class="hljs-punctuation">:</span><br>   <span class="hljs-bullet">-</span> <span class="hljs-string">sds.c</span><br>   <span class="hljs-bullet">-</span> <span class="hljs-string">sds.h</span><br></code></pre></td></tr></table></figure>        </div>      </div>    </div><p>redis 中保存的 key 是字符串，value 往往是字符串或者字符串的集合。所以字符串是 redis 中最常用的一种数据结构。</p><p>不过 redis 没有直接使用 c 语言中的字符串，因为 c 语言字符串存在很多问题：</p><ul><li>获取字符串长度的需要通过运算</li><li>非二进制安全</li><li>不可修改</li></ul><p>redis 构建了一种新的字符串结构，称为简单动态字符串（Simple Dynamic String），简称 SDS</p><p>例如，执行命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">set</span> name ocsio<br></code></pre></td></tr></table></figure><p>那么 redis 将在底层创建两个 SDS，其中一个是包含 “name” 的 SDS，另一个是包含 “ocsio” 的 SDS。</p><p>SDS 的结构体如下：以 sdshdr8 为例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">attribute__</span> ((__<span class="hljs-title">packed__</span>)) <span class="hljs-title">sdshdr8</span> &#123;</span><br>    <span class="hljs-type">uint8_t</span> len;  <span class="hljs-comment">/* buf[] 已经使用的长度 */</span><br>    <span class="hljs-type">uint8_t</span> alloc;  <span class="hljs-comment">/* 除去头信息和结束符的长度，申请的 buf 数组的长度*/</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> flags; <span class="hljs-comment">/* 其中 3bit 表示类型，剩余 5bit 未使用 */</span><br>    <span class="hljs-type">char</span> buf[];  <span class="hljs-comment">/* 字符数组 */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>值得说明的是，SDS 的结构体虽然包含 4 部分，但是 SDS 的指针是指向 buf 数组的，而不是结构体头部，这样的实现的好处在于：</p><ol><li>与 c 语言的字符串结构兼容</li><li>通过 SDS 的指针再向前就可以获取结构体头的大小（flag 字段），又可以进一步实际字符串的长度，这样保证了字符串的二进制安全。</li></ol><p>一些核心方法：</p><table><thead><tr><th>方法名称</th><th>含义</th></tr></thead><tbody><tr><td>sdsHdrSize</td><td>计算 SDS 头部的大小（将 type 与 7 进行与运算）</td></tr><tr><td>sdsReqType</td><td>根据字符串长度获取 SDS 的类型</td></tr><tr><td>sdsnewlen</td><td>根据初始值和初始长度创建 SDS</td></tr><tr><td>sdsfree</td><td>释放 SDS</td></tr><tr><td>sdsupdatelen</td><td>对第一个 \0 终止符进行截取</td></tr><tr><td>sdsclear</td><td>清除 buf 数组，并将 \0 终止符设置到字符串的第一个位置</td></tr><tr><td>sdsMakeRoomFor</td><td>将字符串扩容到指定长度</td></tr><tr><td>sdsRemoveFreeSpace</td><td>压缩 SDS，移除冗余的空间，即让 len = alloc</td></tr><tr><td>sdsAllocPtr</td><td>返回 SDS 结构体的大小</td></tr><tr><td>sdsAllocPtr</td><td>获取 SDS 的头指针</td></tr></tbody></table><p>下面主要来看一下 SDS 扩容的过程：</p><ol><li>首先判断 SDS 预留的空间是否大于 addlen，若大于则直接返回。</li><li>计算新的 SDS 需要占用的空间大小，若 newlen 小于 SDS_MAX_PREALLOC（1m），那么扩容为原来的 2 倍，否则在 newlen 的基础上加 1m 即可。</li><li>根据 newlen 计算新的 SDS 的类型，若新类型和原来的 SDS 类型一致，则进行 s_realloc_usable 扩容，否则申请新的空间对 SDS 将进行重构，并释放原来的 SDS 内存空间。</li><li>最后返回 SDS。</li></ol><p>源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c">sds <span class="hljs-title function_">sdsMakeRoomFor</span><span class="hljs-params">(sds s, <span class="hljs-type">size_t</span> addlen)</span> &#123;<br>    <span class="hljs-type">void</span> *sh, *newsh;<br>    <span class="hljs-type">size_t</span> avail = sdsavail(s);<br>    <span class="hljs-type">size_t</span> len, newlen, reqlen;<br>    <span class="hljs-type">char</span> type, oldtype = s[<span class="hljs-number">-1</span>] &amp; SDS_TYPE_MASK;<br>    <span class="hljs-type">int</span> hdrlen;<br>    <span class="hljs-type">size_t</span> usable;<br><br>    <span class="hljs-comment">/* Return ASAP if there is enough space left. */</span><br>    <span class="hljs-keyword">if</span> (avail &gt;= addlen) <span class="hljs-keyword">return</span> s;<br><br>    len = sdslen(s);<br>    sh = (<span class="hljs-type">char</span>*)s-sdsHdrSize(oldtype);<br>    reqlen = newlen = (len+addlen);<br>    assert(newlen &gt; len);   <span class="hljs-comment">/* Catch size_t overflow */</span><br>    <span class="hljs-keyword">if</span> (newlen &lt; SDS_MAX_PREALLOC)<br>        newlen *= <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">else</span><br>        newlen += SDS_MAX_PREALLOC;<br><br>    type = sdsReqType(newlen);<br><br>    <span class="hljs-comment">/* Don&#x27;t use type 5: the user is appending to the string and type 5 is</span><br><span class="hljs-comment">     * not able to remember empty space, so sdsMakeRoomFor() must be called</span><br><span class="hljs-comment">     * at every appending operation. */</span><br>    <span class="hljs-keyword">if</span> (type == SDS_TYPE_5) type = SDS_TYPE_8;<br><br>    hdrlen = sdsHdrSize(type);<br>    assert(hdrlen + newlen + <span class="hljs-number">1</span> &gt; reqlen);  <span class="hljs-comment">/* Catch size_t overflow */</span><br>    <span class="hljs-keyword">if</span> (oldtype==type) &#123;<br>        newsh = s_realloc_usable(sh, hdrlen+newlen+<span class="hljs-number">1</span>, &amp;usable);<br>        <span class="hljs-keyword">if</span> (newsh == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        s = (<span class="hljs-type">char</span>*)newsh+hdrlen;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">/* Since the header size changes, need to move the string forward,</span><br><span class="hljs-comment">         * and can&#x27;t use realloc */</span><br>        newsh = s_malloc_usable(hdrlen+newlen+<span class="hljs-number">1</span>, &amp;usable);<br>        <span class="hljs-keyword">if</span> (newsh == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-built_in">memcpy</span>((<span class="hljs-type">char</span>*)newsh+hdrlen, s, len+<span class="hljs-number">1</span>);<br>        s_free(sh);<br>        s = (<span class="hljs-type">char</span>*)newsh+hdrlen;<br>        s[<span class="hljs-number">-1</span>] = type;<br>        sdssetlen(s, len);<br>    &#125;<br>    usable = usable-hdrlen<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">if</span> (usable &gt; sdsTypeMaxSize(type))<br>        usable = sdsTypeMaxSize(type);<br>    sdssetalloc(s, usable);<br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-整数数组-IntSet">2. 整数数组 IntSet</h2>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-9d3fcfc2" role="button" aria-expanded="false" aria-controls="collapse-9d3fcfc2">        <div class="fold-arrow">▶</div>源码位置      </div>      <div class="fold-collapse collapse" id="collapse-9d3fcfc2">        <div class="fold-content">          <figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">src</span><span class="hljs-punctuation">:</span><br>   <span class="hljs-bullet">-</span> <span class="hljs-string">intset.c</span><br>   <span class="hljs-bullet">-</span> <span class="hljs-string">intset.h</span><br></code></pre></td></tr></table></figure>        </div>      </div>    </div><p>IntSet 是 redis 中的 Set 集合的一种实现方式，基于整数数组实现，并且具备长度可变、有序等高级特性，适用于去重，并且数据量较小的场景。</p><p>IntSet 的结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">intset</span> &#123;</span><br>    <span class="hljs-type">uint32_t</span> encoding;<br>    <span class="hljs-type">uint32_t</span> length;<br>    <span class="hljs-type">int8_t</span> contents[];<br>&#125; intset;<br></code></pre></td></tr></table></figure><p>其中 encoding 包含 3 种模式，表示存储的整数大小不同：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> INTSET_ENC_INT16 (sizeof(int16_t))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INTSET_ENC_INT32 (sizeof(int32_t))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INTSET_ENC_INT64 (sizeof(int64_t))</span><br></code></pre></td></tr></table></figure><p>redis 保证在 contents 数组的每一个元素的编码方式一致。</p><p>一些核心方法：</p><table><thead><tr><th>方法名称</th><th>含义</th></tr></thead><tbody><tr><td>intsetNew</td><td>创建一个空的 IntSet</td></tr><tr><td>intsetAdd</td><td>向 IntSet 中插入一个数</td></tr><tr><td>intsetRemove</td><td>从 IntSet 中删除一个数</td></tr><tr><td>intsetFind</td><td>一个数是否属于当前 IntSet</td></tr><tr><td></td><td></td></tr></tbody></table><p>下面主要来看一下 IntSet 的创建、新增、编码升级并新增、删除、查找的源码。</p><p>创建：</p><ul><li>分配内存，将编码设置为 int16 以节省内存，length 置为 0 并返回。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Create an empty intset. */</span><br>intset *<span class="hljs-title function_">intsetNew</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    intset *is = zmalloc(<span class="hljs-keyword">sizeof</span>(intset));<br>    is-&gt;encoding = intrev32ifbe(INTSET_ENC_INT16);<br>    is-&gt;length = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> is;<br>&#125;<br></code></pre></td></tr></table></figure><p>新增：</p><ul><li>判断编码，看是否需要升级</li><li>若不升级则找到应该插入的位置，利用二分查找</li><li>插入到正确的位置后更新 length</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c">intset *<span class="hljs-title function_">intsetAdd</span><span class="hljs-params">(intset *is, <span class="hljs-type">int64_t</span> value, <span class="hljs-type">uint8_t</span> *success)</span> &#123;<br>    <span class="hljs-comment">// _intsetValueEncoding 方法：获取当前 value 的编码</span><br>    <span class="hljs-type">uint8_t</span> valenc = _intsetValueEncoding(value);<br>    <span class="hljs-type">uint32_t</span> pos;<br>    <span class="hljs-keyword">if</span> (success) *success = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">/* Upgrade encoding if necessary. If we need to upgrade, we know that</span><br><span class="hljs-comment">     * this value should be either appended (if &gt; 0) or prepended (if &lt; 0),</span><br><span class="hljs-comment">     * because it lies outside the range of existing values. */</span><br>    <span class="hljs-comment">// 如果当前 value 的编码大于当前 IntSet 的编码则需要编码升级并新增</span><br>    <span class="hljs-keyword">if</span> (valenc &gt; intrev32ifbe(is-&gt;encoding)) &#123;<br>        <span class="hljs-comment">/* This always succeeds, so we don&#x27;t need to curry *success. */</span><br>        <span class="hljs-keyword">return</span> intsetUpgradeAndAdd(is,value);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">/* Abort if the value is already present in the set.</span><br><span class="hljs-comment">         * This call will populate &quot;pos&quot; with the right position to insert</span><br><span class="hljs-comment">         * the value when it cannot be found. */</span><br>        <span class="hljs-comment">// 查找当前 value 是否存在，同时将小于 value 的最大值赋值给 pos</span><br>        <span class="hljs-keyword">if</span> (intsetSearch(is,value,&amp;pos)) &#123;<br>            <span class="hljs-keyword">if</span> (success) *success = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">return</span> is;<br>        &#125;<br>        <span class="hljs-comment">// 保证插入时内存足够</span><br>        is = intsetResize(is,intrev32ifbe(is-&gt;length)+<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// value 应该插入在 IntSet 中间，则让后面的值依次后移</span><br>        <span class="hljs-keyword">if</span> (pos &lt; intrev32ifbe(is-&gt;length)) intsetMoveTail(is,pos,pos+<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">// 将 value 插入到 pos</span><br>    _intsetSet(is,pos,value);<br>    <span class="hljs-comment">// 更新 length</span><br>    is-&gt;length = intrev32ifbe(intrev32ifbe(is-&gt;length)+<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> is;<br>&#125;<br></code></pre></td></tr></table></figure><p>编码升级并新增：</p><ul><li>首先设置新的编码并重新申请内存空间</li><li>接着倒序遍历，将原来的数依次加入到新的位置</li><li>设置 value</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Upgrades the intset to a larger encoding and inserts the given integer. */</span><br><span class="hljs-type">static</span> intset *<span class="hljs-title function_">intsetUpgradeAndAdd</span><span class="hljs-params">(intset *is, <span class="hljs-type">int64_t</span> value)</span> &#123;<br>    <span class="hljs-type">uint8_t</span> curenc = intrev32ifbe(is-&gt;encoding);<br>    <span class="hljs-type">uint8_t</span> newenc = _intsetValueEncoding(value);<br>    <span class="hljs-type">int</span> length = intrev32ifbe(is-&gt;length);<br>    <span class="hljs-type">int</span> prepend = value &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/* First set new encoding and resize */</span><br>    is-&gt;encoding = intrev32ifbe(newenc);<br>    is = intsetResize(is,intrev32ifbe(is-&gt;length)+<span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">/* Upgrade back-to-front so we don&#x27;t overwrite values.</span><br><span class="hljs-comment">     * Note that the &quot;prepend&quot; variable is used to make sure we have an empty</span><br><span class="hljs-comment">     * space at either the beginning or the end of the intset. */</span><br>    <span class="hljs-comment">// 倒序遍历，为了不覆盖原来的值</span><br>    <span class="hljs-keyword">while</span>(length--)<br>        _intsetSet(is,length+prepend,_intsetGetEncoded(is,length,curenc));<br><br>    <span class="hljs-comment">/* Set the value at the beginning or the end. */</span><br>    <span class="hljs-comment">// 当前 value 的编码超出了原来的编码，所以 value 要么大于原来 IntSet 的最大值，要么小于原来的 IntSet 的最小值</span><br>    <span class="hljs-keyword">if</span> (prepend)<br>        _intsetSet(is,<span class="hljs-number">0</span>,value);<br>    <span class="hljs-keyword">else</span><br>        _intsetSet(is,intrev32ifbe(is-&gt;length),value);<br>    is-&gt;length = intrev32ifbe(intrev32ifbe(is-&gt;length)+<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> is;<br>&#125;<br></code></pre></td></tr></table></figure><p>删除：</p><ul><li>首先判断 value 的编码，若编码超出此时 IntSet 的编码则什么也不做。</li><li>在删除时，没有进行编码降级处理，由于 IntSet 曾经出现过超大的数，那么再次出现的概率并不低，贸然降级，不仅当前需要处理IntSet 的编码，而且以后升级的概况也很高，所以不降级，以避免麻烦与无用的时间消耗。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Delete integer from intset */</span><br>intset *<span class="hljs-title function_">intsetRemove</span><span class="hljs-params">(intset *is, <span class="hljs-type">int64_t</span> value, <span class="hljs-type">int</span> *success)</span> &#123;<br>    <span class="hljs-comment">// 当前 value 的编码</span><br>    <span class="hljs-type">uint8_t</span> valenc = _intsetValueEncoding(value);<br>    <span class="hljs-type">uint32_t</span> pos;<br>    <span class="hljs-keyword">if</span> (success) *success = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 若当前 value 的编码已经大于 IntSet 的编码，则 value 一定不在 IntSet 中</span><br>    <span class="hljs-keyword">if</span> (valenc &lt;= intrev32ifbe(is-&gt;encoding) &amp;&amp; intsetSearch(is,value,&amp;pos)) &#123;<br>        <span class="hljs-type">uint32_t</span> len = intrev32ifbe(is-&gt;length);<br><br>        <span class="hljs-comment">/* We know we can delete */</span><br>        <span class="hljs-keyword">if</span> (success) *success = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">/* Overwrite value with tail and update length */</span><br>        <span class="hljs-keyword">if</span> (pos &lt; (len<span class="hljs-number">-1</span>)) intsetMoveTail(is,pos+<span class="hljs-number">1</span>,pos);<br>        is = intsetResize(is,len<span class="hljs-number">-1</span>);<br>        is-&gt;length = intrev32ifbe(len<span class="hljs-number">-1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> is;<br>&#125;<br></code></pre></td></tr></table></figure><p>查找：</p><ul><li>二分查找</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 搜索 value 的位置，找到则返回 1，并将 pos 设置为 value 在 IntSet 中的位置</span><br><span class="hljs-comment">// 若 value 在 IntSet 中不存在，则返回 0，并将 pos 设置为 value 在 IntSet 应该插入的位置（小于 value 的最大值）</span><br><span class="hljs-type">static</span> <span class="hljs-type">uint8_t</span> <span class="hljs-title function_">intsetSearch</span><span class="hljs-params">(intset *is, <span class="hljs-type">int64_t</span> value, <span class="hljs-type">uint32_t</span> *pos)</span> &#123;<br>    <span class="hljs-type">int</span> min = <span class="hljs-number">0</span>, max = intrev32ifbe(is-&gt;length)<span class="hljs-number">-1</span>, mid = <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int64_t</span> cur = <span class="hljs-number">-1</span>;<br><br>    <span class="hljs-keyword">if</span> (intrev32ifbe(is-&gt;length) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// IntSet 为空</span><br>        <span class="hljs-keyword">if</span> (pos) *pos = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125; <span class="hljs-keyword">else</span> <br>        <span class="hljs-comment">// _intsetGet 方法返回在 pos 位置的 value 值</span><br>        <span class="hljs-keyword">if</span> (value &gt; _intsetGet(is,max)) &#123;<br>            <span class="hljs-comment">// value 已经大于 IntSet 的最大值</span><br>            <span class="hljs-keyword">if</span> (pos) *pos = intrev32ifbe(is-&gt;length);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value &lt; _intsetGet(is,<span class="hljs-number">0</span>)) &#123;<br>            <span class="hljs-comment">// value 已经小于 IntSet 的最小值</span><br>            <span class="hljs-keyword">if</span> (pos) *pos = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 下面是一个二分查找</span><br>    <span class="hljs-keyword">while</span>(max &gt;= min) &#123;<br>        mid = ((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)min + (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)max) &gt;&gt; <span class="hljs-number">1</span>;<br>        cur = _intsetGet(is,mid);<br>        <span class="hljs-keyword">if</span> (value &gt; cur) &#123;<br>            min = mid+<span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value &lt; cur) &#123;<br>            max = mid<span class="hljs-number">-1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (value == cur) &#123;<br>        <span class="hljs-keyword">if</span> (pos) *pos = mid;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (pos) *pos = min;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-哈希表-Dict">3. 哈希表 Dict</h2>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-2b13d6ba" role="button" aria-expanded="false" aria-controls="collapse-2b13d6ba">        <div class="fold-arrow">▶</div>建议阅读      </div>      <div class="fold-collapse collapse" id="collapse-2b13d6ba">        <div class="fold-content">          <p><a href="/algorithm-53bff467bc4b/" title="哈希表">哈希表</a></p>        </div>      </div>    </div>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis 引入多线程</title>
    <link href="/java/redis-c5d4aef838ce/"/>
    <url>/java/redis-c5d4aef838ce/</url>
    
    <content type="html"><![CDATA[<h1>redis 引入多线程</h1><p>在 redis 6.0 中，就引入了多线程。</p><p>redis 一直被熟知的是它的单线程架构，虽然一些命令操作是后台线程或子进程完成的，但是从网络 IO 到实际的读写命令执行都是由单个线程完成的。</p><p>但随着硬件的性能提升，单个线程处理网络请求的速度跟不上底层网络硬件的速度。</p><p>为了应对这个问题，一般有两种方法。</p><p>第一种是，使用用户态网络协议栈（如 DPDK）取代内核网络协议栈，让网络请求的处理不在内核执行，直接在用户态处理。</p><p>对于 redis 来说，避免频繁让内核进行网络请求处理，可以很好地提升请求处理效率。但，这个方法要求在 redis 的整体架构中，添加对用户态网络协议栈的支持，需要修改 redis 源码中和网络相关的部分（如修改所有的网络收发请求函数），这会带来很多开发工作量，而且新增代码还可能引入新 Bug，导致系统不稳定。所以，redis 6.0 中并没有采用这个方法。</p><p>第二种是，采用多个 IO 线程来处理网络请求，提高网络请求处理的并行度。redis 6.0 就是采用的这种方法。</p><p>但是，redis 的多 IO 线程只是用来处理网络请求的，对于读写命令，redis 仍然使用单线程，这样就不用为了保证 Lua 脚本、事务的原子性，额外开发多线程互斥机制了，redis 线程模型实现就简单了。</p><h2 id="主线程和-IO-线程的协作">主线程和 IO 线程的协作</h2>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-68450473" role="button" aria-expanded="false" aria-controls="collapse-68450473">        <div class="fold-arrow">▶</div>结合这篇文章阅读      </div>      <div class="fold-collapse collapse" id="collapse-68450473">        <div class="fold-content">          <p><a href="/java/redis-75ba9f9c982a/" title="redis 中的 IO 模型">redis 中的 IO 模型</a></p>        </div>      </div>    </div><p>首先，主线程负责接受建立连接请求，当有客户端和实例建立 Socket 连接时，主线程会创建和客户端的连接，并将 Socket 放入全局等待队列 server.clients_pending_read 中，接着，主线程通过轮询的方式将 Socket 连接分配给 IO 线程。</p><p>主线程一旦将 Socket 分配给 IO 线程，那么就会进入阻塞，等待 IO 线程完成客户端的请求读取和解析，由于有多个 IO 线程在并行处理，那么这个过程很快。</p><p>等待 IO 线程解析完请求，主线程还是会以单线程的方式执行命令。</p><p>在源码中方法调用是：</p><p>server.c -&gt; initServer -&gt; acceptTcpHandler -&gt; acceptCommonHandler -&gt; createClient -&gt; readQueryFromClient -&gt; postponeClientRead</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">postponeClientRead</span><span class="hljs-params">(client *c)</span> &#123;<br>    <span class="hljs-keyword">if</span> (server.io_threads_active &amp;&amp;<br>        server.io_threads_do_reads &amp;&amp;<br>        !ProcessingEventsWhileBlocked &amp;&amp;<br>        !(c-&gt;flags &amp; (CLIENT_MASTER|CLIENT_SLAVE|CLIENT_PENDING_READ|CLIENT_BLOCKED))) <br>    &#123;<br>        c-&gt;flags |= CLIENT_PENDING_READ;<br>        <span class="hljs-comment">// 将客户端加入 clients_pending_read 队列中</span><br>        listAddNodeHead(server.clients_pending_read,c);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>将 Socket 连接分配给 IO 线程，方法调用是：server.c -&gt; beforeSleep -&gt; handleClientsWithPendingReadsUsingThreads</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">handleClientsWithPendingReadsUsingThreads</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!server.io_threads_active || !server.io_threads_do_reads) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> processed = listLength(server.clients_pending_read);<br>    <span class="hljs-keyword">if</span> (processed == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/* Distribute the clients across N different lists. */</span><br>    listIter li;<br>    listNode *ln;<br>    listRewind(server.clients_pending_read,&amp;li);<br>    <span class="hljs-type">int</span> item_id = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 通过遍历将 client 加入到 io_threads_list 中</span><br>    <span class="hljs-keyword">while</span>((ln = listNext(&amp;li))) &#123;<br>        client *c = listNodeValue(ln);<br>        <span class="hljs-type">int</span> target_id = item_id % server.io_threads_num;<br>        listAddNodeTail(io_threads_list[target_id],c);<br>        item_id++;<br>    &#125;<br><br>    <span class="hljs-comment">/* Give the start condition to the waiting threads, by setting the</span><br><span class="hljs-comment">     * start condition atomic var. */</span><br>    io_threads_op = IO_THREADS_OP_READ;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; server.io_threads_num; j++) &#123;<br>        <span class="hljs-type">int</span> count = listLength(io_threads_list[j]);<br>        setIOPendingCount(j, count);<br>    &#125;<br><br>    <span class="hljs-comment">/* Also use the main thread to process a slice of clients. */</span><br>    <span class="hljs-comment">// 使用主线程来执行客户端命令</span><br>    listRewind(io_threads_list[<span class="hljs-number">0</span>],&amp;li);<br>    <span class="hljs-keyword">while</span>((ln = listNext(&amp;li))) &#123;<br>        client *c = listNodeValue(ln);<br>        readQueryFromClient(c-&gt;conn);<br>    &#125;<br>    listEmpty(io_threads_list[<span class="hljs-number">0</span>]);<br><br>    <span class="hljs-comment">/* Wait for all the other threads to end their work. */</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> pending = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; server.io_threads_num; j++)<br>            pending += getIOPendingCount(j);<br>        <span class="hljs-keyword">if</span> (pending == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* Run the list of clients again to process the new buffers. */</span><br>    <span class="hljs-keyword">while</span>(listLength(server.clients_pending_read)) &#123;<br>        ln = listFirst(server.clients_pending_read);<br>        client *c = listNodeValue(ln);<br>        c-&gt;flags &amp;= ~CLIENT_PENDING_READ;<br>        listDelNode(server.clients_pending_read,ln);<br><br>        serverAssert(!(c-&gt;flags &amp; CLIENT_BLOCKED));<br>        <span class="hljs-keyword">if</span> (processPendingCommandsAndResetClient(c) == C_ERR) &#123;<br>            <span class="hljs-comment">/* If the client is no longer valid, we avoid</span><br><span class="hljs-comment">             * processing the client later. So we just go</span><br><span class="hljs-comment">             * to the next. */</span><br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        processInputBuffer(c);<br><br>        <span class="hljs-comment">/* We may have pending replies if a thread readQueryFromClient() produced</span><br><span class="hljs-comment">         * replies and did not install a write handler (it can&#x27;t).</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">if</span> (!(c-&gt;flags &amp; CLIENT_PENDING_WRITE) &amp;&amp; clientHasPendingReplies(c))<br>            clientInstallWriteHandler(c);<br>    &#125;<br><br>    <span class="hljs-comment">/* Update processed count on server */</span><br>    server.stat_io_reads_processed += processed;<br><br>    <span class="hljs-keyword">return</span> processed;<br>&#125;<br></code></pre></td></tr></table></figure><p>而当主线程执行完请求操作后，会将返回的结果写到缓冲区，然后主线程阻塞等待 IO 线程将这些结果写回到 Socket 中，并返回给客户端。</p><p>和 IO 线程读取和解析请求一样，IO 线程回写 Socket 时，也是有多个线程在并发执行，所以回写 Socket 的速度也很快。等到 IO 线程回写 Socket 完毕，主线程会清空全局队列，等待客户端的后续请求。</p><p>在源码中方法调用是：server.c -&gt; beforeSleep -&gt; handleClientsWithPendingWritesUsingThreads</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">handleClientsWithPendingWritesUsingThreads</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-type">int</span> processed = listLength(server.clients_pending_write);<br>    <span class="hljs-keyword">if</span> (processed == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">/* Return ASAP if there are no clients. */</span><br><br>    <span class="hljs-comment">/* If I/O threads are disabled or we have few clients to serve, don&#x27;t</span><br><span class="hljs-comment">     * use I/O threads, but the boring synchronous code. */</span><br>    <span class="hljs-comment">// 如果没有启用 IO 线程，那么会执行 handleClientsWithPendingWrites 函数</span><br>    <span class="hljs-keyword">if</span> (server.io_threads_num == <span class="hljs-number">1</span> || stopThreadedIOIfNeeded()) &#123;<br>        <span class="hljs-keyword">return</span> handleClientsWithPendingWrites();<br>    &#125;<br><br>    <span class="hljs-comment">/* Start threads if needed. */</span><br>    <span class="hljs-keyword">if</span> (!server.io_threads_active) startThreadedIO();<br><br>    <span class="hljs-comment">/* Distribute the clients across N different lists. */</span><br>    listIter li;<br>    listNode *ln;<br>    listRewind(server.clients_pending_write,&amp;li);<br>    <span class="hljs-type">int</span> item_id = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>((ln = listNext(&amp;li))) &#123;<br>        client *c = listNodeValue(ln);<br>        c-&gt;flags &amp;= ~CLIENT_PENDING_WRITE;<br><br>        <span class="hljs-comment">/* Remove clients from the list of pending writes since</span><br><span class="hljs-comment">         * they are going to be closed ASAP. */</span><br>        <span class="hljs-keyword">if</span> (c-&gt;flags &amp; CLIENT_CLOSE_ASAP) &#123;<br>            listDelNode(server.clients_pending_write, ln);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> target_id = item_id % server.io_threads_num;<br>        listAddNodeTail(io_threads_list[target_id],c);<br>        item_id++;<br>    &#125;<br><br>    <span class="hljs-comment">/* Give the start condition to the waiting threads, by setting the</span><br><span class="hljs-comment">     * start condition atomic var. */</span><br>    io_threads_op = IO_THREADS_OP_WRITE;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; server.io_threads_num; j++) &#123;<br>        <span class="hljs-type">int</span> count = listLength(io_threads_list[j]);<br>        setIOPendingCount(j, count);<br>    &#125;<br><br>    <span class="hljs-comment">/* Also use the main thread to process a slice of clients. */</span><br>    listRewind(io_threads_list[<span class="hljs-number">0</span>],&amp;li);<br>    <span class="hljs-keyword">while</span>((ln = listNext(&amp;li))) &#123;<br>        client *c = listNodeValue(ln);<br>        writeToClient(c,<span class="hljs-number">0</span>);<br>    &#125;<br>    listEmpty(io_threads_list[<span class="hljs-number">0</span>]);<br><br>    <span class="hljs-comment">/* Wait for all the other threads to end their work. */</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> pending = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; server.io_threads_num; j++)<br>            pending += getIOPendingCount(j);<br>        <span class="hljs-keyword">if</span> (pending == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* Run the list of clients again to install the write handler where</span><br><span class="hljs-comment">     * needed. */</span><br>    listRewind(server.clients_pending_write,&amp;li);<br>    <span class="hljs-keyword">while</span>((ln = listNext(&amp;li))) &#123;<br>        client *c = listNodeValue(ln);<br><br>        <span class="hljs-comment">/* Install the write handler if there are pending writes in some</span><br><span class="hljs-comment">         * of the clients. */</span><br>        <span class="hljs-keyword">if</span> (clientHasPendingReplies(c) &amp;&amp;<br>                connSetWriteHandler(c-&gt;conn, sendReplyToClient) == AE_ERR)<br>        &#123;<br>            freeClientAsync(c);<br>        &#125;<br>    &#125;<br>    listEmpty(server.clients_pending_write);<br><br>    <span class="hljs-comment">/* Update processed count on server */</span><br>    server.stat_io_writes_processed += processed;<br><br>    <span class="hljs-keyword">return</span> processed;<br>&#125;<br></code></pre></td></tr></table></figure><p>大致流程如下图：</p><p><img src="/java/redis-c5d4aef838ce/image-20240114173506524.png" alt="流程"></p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis 为什么那么快</title>
    <link href="/java/redis-8c60558ad544/"/>
    <url>/java/redis-8c60558ad544/</url>
    
    <content type="html"><![CDATA[<h1>redis 为什么那么快</h1><p>redis 之所以性能如此之快，主要有以下几个原因：</p><ol><li><strong>基于内存</strong>：redis 是一种基于内存的数据库，数据是存储在内存中，一般存储介质是 RAM，数据读写非常快，访问速度远超过磁盘读写。</li><li><strong>单线程模型</strong>：redis 使用单线程模型，那么它的所有操作都是在一个线程中进行，无需进行线程上下文切换，大大提高了 redis 的响应速度和运行效率。</li><li><strong>采用 I/O 多路复用模型</strong>：redis 在单线程的基础上，采用了 I/O 多路复用技术，实现了单个线程同时处理多个客户端连接的能力，从而提高 redis 的并发性能。</li><li><strong>redis 基于高效的数据结构</strong>：redis 提高多种高效的数据结构，如哈希表，有序集合，跳表等，多数都能在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 的时间复杂度下完成数据读写，这也是 redis 快速处理数据请求的原因之一。</li><li><strong>引入多线程</strong>：redis 在 6.0 引入了多线程，进一步提升了 I/O 性能，使得网络处理的请求并发进行，大大提升性能，还可以充分利用多核 CPU 的优势。</li></ol><h2 id="基于内存">基于内存</h2><p>内存想必就不用多说了，在计算机中，内存的数据读写速度是远大于磁盘的。</p><h2 id="单线程模型">单线程模型</h2><p>首先需要说明一个事实，我们通常说 redis 基于单线程，主要是指 redis 的网络 I/O 和数据读写是由一个线程完成的，这也是 redis 对外提供数据存储服务的主要流程。但是 redis 的其他功能，比如持久化、异步删除、集群数据同步等，都是由额外的线程进行的。</p><p>redis 为什么使用单线程，这就不得不提到多线程下的开销。</p><p>我们经常听到这样的言论：“使用多线程，可以增加系统吞吐率，提升效率”，对于一个多线程系统来说，如果资源分配合理，可以增加系统中处理请求的线程数，进而提高系统能够同时处理的请求数，也就是提高吞吐率。</p><p>但是在多线程系统中，如果没有良好的系统设计，实际上，随着线程的增多，系统的吞吐率开始增长缓慢，甚至下降。</p><p>主要在于，如果线程过多，那么会有多个并发的线程同时访问系统的共享资源，那么就必须要使用额外的锁机制，来保证资源的互斥访问，这就会带来额外的开销，要么就会进行线程上下文切换，要么会在 CPU 上自旋等待，这都是资源的浪费。</p><p>而且抛开持久化不说，redis 是存内存操作，执行速度非常快，它的性能瓶颈是网络延迟而不是执行速度，因此引入多线程也不会带来巨大的性能提升。</p><p>这也就是为什么 redis 使用单线程模型。</p>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-19c25ed0" role="button" aria-expanded="false" aria-controls="collapse-19c25ed0">        <div class="fold-arrow">▶</div>可能继续问到      </div>      <div class="fold-collapse collapse" id="collapse-19c25ed0">        <div class="fold-content">          <p>redis 为什么引入多线程？<a href="/java/redis-c5d4aef838ce/" title="redis 引入多线程">redis 引入多线程</a></p>        </div>      </div>    </div><h2 id="I-O-多路复用">I/O 多路复用</h2><a href="/java/redis-75ba9f9c982a/" title="redis 中的 IO 模型">redis 中的 IO 模型</a><h2 id="redis-中高效的数据结构">redis 中高效的数据结构</h2><a href="/java/redis-25334f7a71a2/" title="redis 中有哪些高效的数据结构">redis 中有哪些高效的数据结构</a><h2 id="引入多线程">引入多线程</h2><a href="/java/redis-c5d4aef838ce/" title="redis 引入多线程">redis 引入多线程</a>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码随想录刷题—链表</title>
    <link href="/algorithm-1974abcef927/"/>
    <url>/algorithm-1974abcef927/</url>
    
    <content type="html"><![CDATA[<h1>链表</h1><h2 id="1-移除链表元素">1. 移除链表元素</h2><blockquote><p><a href="https://leetcode.cn/problems/remove-linked-list-elements/">203. 移除链表元素</a></p></blockquote><p>这道题和 <a href="https://leetcode.cn/problems/remove-element/">27. 移除元素</a> 类似，都是在一个线性结构中移除指定 val 的元素，由于数组与链表的结构不同，造成了不同的求解方式。</p><p>注意点：</p><ul><li>由于第一个节点就有可能是要删除的节点，所以为了避免对头节点的特殊处理，我们引入了一个 dummy 哨兵节点，这在链表问题中是一种很常见的手段，总而言之，就是结果链表如果有可能变换头节点，那么就可以使用哨兵节点简化处理。</li><li>本身题目很简单，只是简单的引用的指向，举个例子简单理解即可。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeElements</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> val)</span> &#123;<br>    <span class="hljs-comment">// 哑元节点（哨兵节点），可以避免处理头节点为 val 的特殊情况</span><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>, head);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">ListNode</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> dummy; p != <span class="hljs-literal">null</span>; p = p.next) &#123;<br>        <span class="hljs-keyword">while</span> (p.next != <span class="hljs-literal">null</span> &amp;&amp; p.next.val == val) &#123;<br>            p.next = p.next.next;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dummy.next;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度：</p><ul><li>时间：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>空间：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li></ul><h2 id="2-设计链表">2. 设计链表</h2><blockquote><p><a href="https://leetcode.cn/problems/design-linked-list/">707. 设计链表</a></p></blockquote><p>下面我使用的是单链表的形式设计的，有几点注意：</p><ul><li>在 addAtIndex 方法和 deleteAtIndex 方法中，需要检查 index 是否在链表索引的有效范围内，这一点是通过引入 size 变量实现的，这里 size 需要在元素添加和删除时动态变化，不要忘了。</li><li>设计链表时，使用哑元节点（哨兵节点）可以在删除链首节点不做特殊的判断。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyLinkedList</span> &#123;<br>    Node dummy;<br>    <span class="hljs-type">int</span> size;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyLinkedList</span><span class="hljs-params">()</span> &#123;<br>        dummy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(-<span class="hljs-number">1</span>);<br>        size = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dummy.next; cur != <span class="hljs-literal">null</span>; cur = cur.next, count++) &#123;<br>            <span class="hljs-keyword">if</span> (count == index) &#123;<br>                <span class="hljs-keyword">return</span> cur.val;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addAtHead</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        addAtIndex(<span class="hljs-number">0</span>, val);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addAtTail</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        addAtIndex(size, val);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addAtIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt; size) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        size++;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> getIndexPre(index);<br>        pre.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(val, pre.next);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteAtIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= size) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        size--;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> getIndexPre(index);<br>        pre.next = pre.next.next;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取逻辑索引为 index 的节点的前一个节点</span><br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">getIndexPre</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (count &lt; index) &#123;<br>            pre = pre.next;<br>            count++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>        <span class="hljs-type">int</span> val;<br>        Node next;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> val, Node next)</span> &#123;<br>            <span class="hljs-built_in">this</span>.val = val;<br>            <span class="hljs-built_in">this</span>.next = next;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>            <span class="hljs-built_in">this</span>.val = val;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度：</p><ul><li>时间：addAtHead 为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，其余为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>空间：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li></ul><h2 id="3-反转链表">3. 反转链表</h2><blockquote><p><a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a></p></blockquote><p>在反转链表的时候，我们需要知道当前节点的上一个节点，下一个节点，一共需要知道三个节点的信息，所以就有了下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> head;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head.next;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> cur.next;<br>    <span class="hljs-keyword">while</span> (next != <span class="hljs-literal">null</span>) &#123;<br>        cur.next = pre;<br>        pre = cur;<br>        cur = next;<br>        next = next.next;<br>    &#125;<br>    cur.next = pre;<br>    head.next = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">return</span> cur;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是，对于头节点来说，因为它的 next 会在最后置为 null，所以在反转的过程中，我们可以让头节点指向当前节点 cur 的下一个节点，这样可以省略一个变量 next，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> head;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head.next;<br>    head.next = cur.next;<br>    <span class="hljs-keyword">while</span> (cur.next != <span class="hljs-literal">null</span>) &#123;<br>        cur.next = pre;<br>        pre = cur;<br>        cur = head.next;<br>        head.next = cur.next;<br>    &#125;<br>    cur.next = pre;<br>    <span class="hljs-keyword">return</span> cur;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度：</p><ul><li>时间：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>空间：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li></ul><h2 id="4-两两交换链表中的节点">4. 两两交换链表中的节点</h2><blockquote><p><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点</a></p></blockquote><p>正常模拟即可。几点注意：</p><ul><li>使用哨兵节点，简化对头节点的处理。</li><li>一定画图分析，否则指针的指向容易乱，同时也要注意改变指针指向的顺序。</li></ul><p>可以按照下面的代码的执行顺序改变指针指向。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">swapPairs</span><span class="hljs-params">(ListNode head)</span> &#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    <span class="hljs-comment">// 引入哨兵节点</span><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>, head);<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> dummy;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dummy.next;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> cur.next;<br>    <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span> &amp;&amp; next != <span class="hljs-literal">null</span>) &#123;<br>        cur.next = next.next;<br>        pre.next = next;<br>        next.next = cur;<br>        pre = cur;<br>        cur = cur.next;<br>        <span class="hljs-keyword">if</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            next = cur.next;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dummy.next;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度：</p><ul><li>时间：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>空间：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li></ul><h2 id="5-删除链表的倒数第-N-个结点">5. 删除链表的倒数第 N 个结点</h2><blockquote><p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></p></blockquote><p>这道题其实很简单，你可以先遍历一次链表得到链表长度，就可以轻而易举的找到倒数第 n 个节点，也可以将链表反转，删除第 n 个节点后，再将链表反转回去。</p><p>但是题目要求使用一趟扫描完成，所以上面的方式显然不行，对于这种模拟做不了的链表题目，或许可以试试双指针。</p><p>这道题就是使用快慢指针，快、慢指针从头节点出发，快指针先走 n 步，接着快、慢指针同步移动，最后当快指针到达尾节点，慢指针就来到了要删除节点的前一个节点，那么将删除节点删除即可。</p><p>当然，由于头节点也可能被删除，那么引入哨兵节点，简化代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>, head);<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> dummy;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> dummy;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>        fast = fast.next;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (fast.next != <span class="hljs-literal">null</span>) &#123;<br>        fast = fast.next;<br>        slow = slow.next;<br>    &#125;<br>    slow.next = slow.next.next;<br>    <span class="hljs-keyword">return</span> dummy.next;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度：</p><ul><li>时间：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>空间：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li></ul><h2 id="6-链表的中间结点">6. 链表的中间结点</h2><blockquote><p><a href="https://leetcode.cn/problems/middle-of-the-linked-list/">876. 链表的中间结点</a></p></blockquote><p>这道题也是使用快慢指针。</p><p>快、慢指针从头节点出发，快指针每次走两步，慢指针每次走一步，那么当快指针走到尾节点的位置，此时慢指针就处于链表的中间节点。</p><p>注意，由于链表节点的个数可能为偶数，那么下面代码中 while 循环的条件，就决定了是上中点还是下中点，画个图就明白了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">middleNode</span><span class="hljs-params">(ListNode head)</span> &#123;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head, slow = head;<br>    <span class="hljs-comment">// 一定是 fast 先到头</span><br>    <span class="hljs-comment">// 注意 fast != null &amp;&amp; fast.next != null 求的是下中点</span><br>    <span class="hljs-comment">// 若要求上中点则为 fast.next != null &amp;&amp; fast.next.next != null</span><br>    <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">null</span> &amp;&amp; fast.next != <span class="hljs-literal">null</span>) &#123;<br>        fast = fast.next.next;<br>        slow = slow.next;<br>    &#125;<br>    <span class="hljs-comment">// fast 到头了, 此时 slow 就是中间位置</span><br>    <span class="hljs-keyword">return</span> slow;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度：</p><ul><li>时间：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>空间：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li></ul><h2 id="7-环形链表">7. 环形链表</h2><h3 id="7-1-环形链表">7.1 环形链表</h3><blockquote><p><a href="https://leetcode.cn/problems/linked-list-cycle/description/">141. 环形链表</a></p></blockquote><p>弗洛伊德判环算法（Floyd’s Cycle Detection Algorithm），也称为龟兔赛跑算法（Tortoise And Hare Algorithm），是一种用于检测链表中是否存在环的算法。</p><p>这个算法的基本思想是通过两个不同速度的指针在链表上移动，当两个指针相遇时，即可确定链表中存在环。</p><p>阶段一：判断是否有环</p><ol><li>定义两个指针，一个称为慢指针（slow），初始时指向链表的头部；另一个称为快指针（fast），初始时也指向链表的头部。</li><li>进入循环，快指针每次移动两步，慢指针每次移动一步，直到快指针遇到链表的末尾（即指向 null），或者两个指针相遇。</li><li>如果快指针遇到链表的末尾（null），则链表中没有环。</li><li>如果两个指针相遇，即快指针和慢指针指向同一个节点，则链表中存在环。</li></ol><p>阶段二：求出环的入口，一旦确定链表中存在环，我们可以找到环的入口节点。</p><ol><li>让慢指针和快指针相遇，并记录相遇节点。</li><li>让一个指针 ptr1 从链表头开始，另一个指针 ptr2 从相遇节点开始。</li><li>让 ptr1 和 ptr2 同时以相同的速度前进，当它们相遇时，相遇节点即为环的入口节点。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasCycle</span><span class="hljs-params">(ListNode head)</span> &#123;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head, fast = head;<br>    <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">null</span> &amp;&amp; fast.next != <span class="hljs-literal">null</span>) &#123;<br>        fast = fast.next.next;<br>        slow = slow.next;<br>        <span class="hljs-keyword">if</span> (fast == slow) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度</p><ul><li>时间：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>空间：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li></ul><h3 id="7-2-环形链表-II">7.2 环形链表 II</h3><blockquote><p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/description/">142. 环形链表 II</a></p></blockquote><p><strong>弗洛伊德判环算法第 2 阶段</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">detectCycle</span><span class="hljs-params">(ListNode head)</span> &#123;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head, fast = head;<br>    <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">null</span> &amp;&amp; fast.next != <span class="hljs-literal">null</span>) &#123;<br>        fast = fast.next.next;<br>        slow = slow.next;<br>        <span class="hljs-keyword">if</span> (slow == fast) &#123;<br>            slow = head;<br>            <span class="hljs-keyword">while</span> (slow != fast) &#123;<br>                slow = slow.next;<br>                fast = fast.next;<br>            &#125;<br>            <span class="hljs-keyword">return</span> fast;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度</p><ul><li>时间：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>空间：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li></ul><h2 id="8-相交链表">8. 相交链表</h2><blockquote><p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/description/">160. 相交链表</a></p></blockquote><p>第一个思路是先计算出两个链表各自的长度 len1 和 len2，接着使用两个指针分别指向两个链表的头节点，然后指向较长链表的指针先走 len1 - len2 步（假设 len1 较大），最后两个指针同步移动，如遍历时相遇则返回该节点，若链表遍历完还未相遇则返回 null。</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">lenA</span> <span class="hljs-operator">=</span> len(headA);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">lenB</span> <span class="hljs-operator">=</span> len(headB);<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">curA</span> <span class="hljs-operator">=</span> headA;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">curB</span> <span class="hljs-operator">=</span> headB;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> lenA - lenB;<br>    <span class="hljs-keyword">while</span> (flag &gt; <span class="hljs-number">0</span>) &#123;<br>        flag--;<br>        curA = curA.next;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (flag &lt; <span class="hljs-number">0</span>) &#123;<br>        flag++;<br>        curB = curB.next;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (curA != <span class="hljs-literal">null</span> &amp;&amp; curB != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (curA == curB) &#123;<br>            <span class="hljs-keyword">return</span> curA;<br>        &#125;<br>        curA = curA.next;<br>        curB = curB.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">len</span><span class="hljs-params">(ListNode head)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head; cur != <span class="hljs-literal">null</span>; cur = cur.next) &#123;<br>        len++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> len;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度</p><ul><li>时间：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m+n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>空间：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li></ul><p>当然还有一个思路，属实不容易想到。</p><p>只有当链表 headA 和 headB 都不为空时，两个链表才可能相交。因此首先判断链表 headA 和 headB 是否为空，如果其中至少有一个链表为空，则两个链表一定不相交，返回 null。</p><p>当链表 headA 和 headB 都不为空时，创建两个指针 pA 和 pB，初始时分别指向两个链表的头节点 headA 和 headB，然后将两个指针依次遍历两个链表的每个节点。具体做法如下：</p><ul><li>每步操作需要同时更新指针 pA 和 pB</li><li>如果指针 pA 不为空，则将指针 pA 移到下一个节点；如果指针 pB 不为空，则将指针 pB 移到下一个节点</li><li>如果指针 pA 为空（表示链表 A 遍历完毕），则将指针 pA 移到链表 headB 的头节点；如果指针 pB 为空，则将指针 pB 移到链表 headA 的头节点。</li><li>当指针 pA 和 pB 指向同一个节点或者都为空时，返回它们指向的节点或者 null</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> &#123;<br>    <span class="hljs-comment">// 若链表 A 和链表 B 中有一个为空链表则不可能相交</span><br>    <span class="hljs-keyword">if</span> (headA == <span class="hljs-literal">null</span> || headB == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">pa</span> <span class="hljs-operator">=</span> headA;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">pb</span> <span class="hljs-operator">=</span> headB;<br>    <span class="hljs-keyword">while</span> (pa != pb) &#123;<br>        pa = (pa == <span class="hljs-literal">null</span>) ? headB : pa.next;<br>        pb = (pb == <span class="hljs-literal">null</span>) ? headA : pb.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> pa;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度</p><ul><li>时间：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m+n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>空间：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li></ul>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
      <tag>list</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java nio</title>
    <link href="/java/javase-beb1cfdacc32/"/>
    <url>/java/javase-beb1cfdacc32/</url>
    
    <content type="html"><![CDATA[<h1>JavaNIO</h1><p>Nio，non-blocking io 非阻塞 IO。</p><h2 id="1-NIO-三大组件">1. NIO 三大组件</h2><h3 id="1-1-Channel">1.1 Channel</h3><p>channel 类似于 stream，是读写数据的 <strong>双向通道</strong>，可以从 channel 将数据读入 buffer，也可以将 buffer 的数据写入 channel。</p><p>常见的 Channel 有</p><ul><li>FileChannel：文件的传输通道</li><li>DatagramChannel：UDP 编程的数据传输通道</li><li>SocketChannel：TCP 编程的数据传输通道，用于客户端和服务端</li><li>ServerSocketChannel：TCP 编程的数据传输通道，用于服务端</li></ul><h3 id="1-2-Buffer">1.2 Buffer</h3><p>buffer 是用来缓冲读写数据的，常见的 buffer 有：</p><ul><li>ByteBuffer<ul><li>MappedByteBuffer</li><li>DirectByteBuffer</li><li>HeapByteBuffer</li></ul></li><li>ShortBuffer 等</li></ul><h3 id="1-3-Selector">1.3 Selector</h3><p>在 Nio 出现之前，我们是如何开发服务器端的程序？</p><p>第一种思路是采用多线程，</p><p><img src="/java/javase-beb1cfdacc32/image-20240114211341124.png" alt="多线程设计"></p><p>当一个客户端连接到服务器，它表现为一个客户端和服务器之间的 socket 连接，我们针对这个 socket 就可以做一些读写的操作。</p><p>而如果有多个客户端连接，那么服务器可以开启与客户端数量相等的线程来分别处理这些连接。</p><p>这种方式的弊端在于：</p><ol><li>这种服务器无法处理高并发的连接请求，因为创建线程需要消耗一定的内存，随着连接数的增加，内存很有可能不足。</li><li>另外，随着线程数量的增多，而 CPU 的核数只有那么多，势必会导致频繁的线程上下文切换从而造成额外的开销。</li></ol><p>所以这种架构方式只适用于连接数少的服务器。</p><p>第二种思路是采用线程池的方式，</p><p><img src="/java/javase-beb1cfdacc32/image-20240114213119019.png" alt="线程池"></p><p>多线程的设计，由于线程数太多而导致内存占用高，并且过多的线程必然导致线程上下文切换的开销也增大。</p><p>所以线程池的设计主要就是限制了线程的数量。</p><p>但是此时的问题是，socket api 是处于阻塞模式，也就是说，一个线程只有处理完此时的 socket 连接，才能继续处理其他的 socket 连接，如果此时的 socket 连接什么也不做，但就是不断开，那么这个线程也在这里干等着，白白浪费了资源。</p><p>所以这种线程池的设计更加适用于一些短连接的场景，比如 HTTP 请求，你发送了请求，得到响应之后就可以断开了，当前线程又可以去处理其他请求了。</p><p>接下来我们看看 selector 的设计思路，</p><p><img src="/java/javase-beb1cfdacc32/image-20240114213101046.png" alt="selector"></p><p>我们不妨打个比喻，服务器就像是一家餐馆，线程就是餐馆的服务员，那么图中的 channel 就像是顾客。</p><p>而核心就是 selector 选择器就像是一个点餐电脑，一旦顾客扫描餐桌上的二维码点餐或者结账，那么这台电脑就可以收到并通知服务员处理。</p><p>所以 selector，它就是管理多个 channel，并且可以获得这些 channel 上所有发生的事件，具体分为可连接、可读、可写。一旦这些事件触发，selector 就可以让一个线程来处理这些读写操作。</p><p>还有一点是，channel 工作在非阻塞模式下，它不会出现像 socket 连接没断开之前，线程死等的情况，一旦某个 channel 上没有事件，那么线程还可以去处理另一个 channel，这样就大大提升了线程的利用率。</p><p>这种方式就比较适合处理高并发的场景。</p><h2 id="2-ByteBuffer">2. ByteBuffer</h2><h3 id="2-1-基本使用">2.1 基本使用</h3><p>有一普通文本文件 data.txt，内容为</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">1234567890abcd<br></code></pre></td></tr></table></figure><p>使用 FileChannel 来读取文件内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ByteBufferTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">RandomAccessFile</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomAccessFile</span>(<span class="hljs-string">&quot;data.txt&quot;</span>, <span class="hljs-string">&quot;rw&quot;</span>)) &#123;<br>            <span class="hljs-type">FileChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> file.getChannel();<br>            <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">10</span>);<br>            <span class="hljs-keyword">do</span> &#123;<br>                <span class="hljs-comment">// 向 buffer 写</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> channel.read(buffer);<br>                <span class="hljs-keyword">if</span> (len == -<span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">// 切换到 buffer 读模式</span><br>                buffer.flip();<br>                <span class="hljs-keyword">while</span> (buffer.hasRemaining()) &#123;<br>                    log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, (<span class="hljs-type">char</span>) buffer.get());<br>                &#125;<br>                <span class="hljs-comment">// 切换到 buffer 写模式</span><br>                buffer.clear();<br>            &#125; <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, e.toString());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">21</span>:<span class="hljs-number">54</span>:<span class="hljs-number">54</span> [DEBUG] [main] c.o.ByteBufferTest - <span class="hljs-number">1</span><br><span class="hljs-number">21</span>:<span class="hljs-number">54</span>:<span class="hljs-number">54</span> [DEBUG] [main] c.o.ByteBufferTest - <span class="hljs-number">2</span><br><span class="hljs-number">21</span>:<span class="hljs-number">54</span>:<span class="hljs-number">54</span> [DEBUG] [main] c.o.ByteBufferTest - <span class="hljs-number">3</span><br><span class="hljs-number">21</span>:<span class="hljs-number">54</span>:<span class="hljs-number">54</span> [DEBUG] [main] c.o.ByteBufferTest - <span class="hljs-number">4</span><br><span class="hljs-number">21</span>:<span class="hljs-number">54</span>:<span class="hljs-number">54</span> [DEBUG] [main] c.o.ByteBufferTest - <span class="hljs-number">5</span><br><span class="hljs-number">21</span>:<span class="hljs-number">54</span>:<span class="hljs-number">54</span> [DEBUG] [main] c.o.ByteBufferTest - <span class="hljs-number">6</span><br><span class="hljs-number">21</span>:<span class="hljs-number">54</span>:<span class="hljs-number">54</span> [DEBUG] [main] c.o.ByteBufferTest - <span class="hljs-number">7</span><br><span class="hljs-number">21</span>:<span class="hljs-number">54</span>:<span class="hljs-number">54</span> [DEBUG] [main] c.o.ByteBufferTest - <span class="hljs-number">8</span><br><span class="hljs-number">21</span>:<span class="hljs-number">54</span>:<span class="hljs-number">54</span> [DEBUG] [main] c.o.ByteBufferTest - <span class="hljs-number">9</span><br><span class="hljs-number">21</span>:<span class="hljs-number">54</span>:<span class="hljs-number">54</span> [DEBUG] [main] c.o.ByteBufferTest - <span class="hljs-number">0</span><br><span class="hljs-number">21</span>:<span class="hljs-number">54</span>:<span class="hljs-number">54</span> [DEBUG] [main] c.o.ByteBufferTest - a<br><span class="hljs-number">21</span>:<span class="hljs-number">54</span>:<span class="hljs-number">54</span> [DEBUG] [main] c.o.ByteBufferTest - b<br><span class="hljs-number">21</span>:<span class="hljs-number">54</span>:<span class="hljs-number">54</span> [DEBUG] [main] c.o.ByteBufferTest - c<br><span class="hljs-number">21</span>:<span class="hljs-number">54</span>:<span class="hljs-number">54</span> [DEBUG] [main] c.o.ByteBufferTest - d<br></code></pre></td></tr></table></figure><h3 id="2-2-内部结构">2.2 内部结构</h3><p>ByteBuffer 有下面三个重要属性：</p><ul><li>capacity</li><li>position</li><li>limit</li></ul><p>最初</p><p><img src="/java/javase-beb1cfdacc32/image-20240114220422251.png" alt="初始"></p><p>写模式下，position 是写入位置，limit 相当于容量，当向 ByteBuffer 中写入 4 个字节，</p><p><img src="/java/javase-beb1cfdacc32/image-20240114220657700.png" alt="写入 4 个字节"></p><p>当调用 flip，position 切换为读取位置，limit 切换为读取限制，</p><p><img src="/java/javase-beb1cfdacc32/image-20240114220825114.png" alt="读取模式"></p><p>此时读取 4 个字节，</p><p><img src="/java/javase-beb1cfdacc32/image-20240114220913243.png" alt="读取 4 个字节后"></p><p>当调用 clear 方法，</p><p><img src="/java/javase-beb1cfdacc32/image-20240114221020790.png" alt="clear"></p><p>而对于 compact 方法，是将未读取完的部分，向前压缩，并切换为写模式，在 compact 前，</p><p><img src="/java/javase-beb1cfdacc32/image-20240114221142132.png" alt="compact 前"></p><p>在 compact 后，</p><p><img src="/java/javase-beb1cfdacc32/image-20240114221319529.png" alt="compact 后"></p><p>所以对于 ByteBuffer，正确的使用姿势是：</p><ol><li>向 ByteBuffer 写入数据，如调用 channel.read(buffer)</li><li>调用 filp 切换为读模式</li><li>从 buffer 中读取数据，如调用 buffer.get()</li><li>调用 clear 或者 compact 切换到写模式</li><li>重复 1 ~ 4</li></ol>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-5b75660a" role="button" aria-expanded="false" aria-controls="collapse-5b75660a">        <div class="fold-arrow">▶</div>调试方法      </div>      <div class="fold-collapse collapse" id="collapse-5b75660a">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> io.netty.util.internal.StringUtil;<br><br><span class="hljs-keyword">import</span> java.nio.ByteBuffer;<br><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> io.netty.util.internal.MathUtil.isOutOfBounds;<br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> io.netty.util.internal.StringUtil.NEWLINE;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ByteBufferUtil</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">char</span>[] BYTE2CHAR = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">256</span>];<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">char</span>[] HEXDUMP_TABLE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">256</span> * <span class="hljs-number">4</span>];<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String[] HEXPADDING = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">16</span>];<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String[] HEXDUMP_ROWPREFIXES = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">65536</span> &gt;&gt;&gt; <span class="hljs-number">4</span>];<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String[] BYTE2HEX = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">256</span>];<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String[] BYTEPADDING = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">16</span>];<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">char</span>[] DIGITS = <span class="hljs-string">&quot;0123456789abcdef&quot;</span>.toCharArray();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++) &#123;<br>            HEXDUMP_TABLE[i &lt;&lt; <span class="hljs-number">1</span>] = DIGITS[i &gt;&gt;&gt; <span class="hljs-number">4</span> &amp; <span class="hljs-number">0x0F</span>];<br>            HEXDUMP_TABLE[(i &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>] = DIGITS[i &amp; <span class="hljs-number">0x0F</span>];<br>        &#125;<br><br>        <span class="hljs-type">int</span> i;<br><br>        <span class="hljs-comment">// Generate the lookup table for hex dump paddings</span><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; HEXPADDING.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">padding</span> <span class="hljs-operator">=</span> HEXPADDING.length - i;<br>            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(padding * <span class="hljs-number">3</span>);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; padding; j++) &#123;<br>                buf.append(<span class="hljs-string">&quot;   &quot;</span>);<br>            &#125;<br>            HEXPADDING[i] = buf.toString();<br>        &#125;<br><br>        <span class="hljs-comment">// Generate the lookup table for the start-offset header in each row (up to 64KiB).</span><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; HEXDUMP_ROWPREFIXES.length; i++) &#123;<br>            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-number">12</span>);<br>            buf.append(NEWLINE);<br>            buf.append(Long.toHexString(i &lt;&lt; <span class="hljs-number">4</span> &amp; <span class="hljs-number">0xFFFFFFFFL</span> | <span class="hljs-number">0x100000000L</span>));<br>            buf.setCharAt(buf.length() - <span class="hljs-number">9</span>, <span class="hljs-string">&#x27;|&#x27;</span>);<br>            buf.append(<span class="hljs-string">&#x27;|&#x27;</span>);<br>            HEXDUMP_ROWPREFIXES[i] = buf.toString();<br>        &#125;<br><br>        <span class="hljs-comment">// Generate the lookup table for byte-to-hex-dump conversion</span><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; BYTE2HEX.length; i++) &#123;<br>            BYTE2HEX[i] = <span class="hljs-string">&#x27; &#x27;</span> + StringUtil.byteToHexStringPadded(i);<br>        &#125;<br><br>        <span class="hljs-comment">// Generate the lookup table for byte dump paddings</span><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; BYTEPADDING.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">padding</span> <span class="hljs-operator">=</span> BYTEPADDING.length - i;<br>            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(padding);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; padding; j++) &#123;<br>                buf.append(<span class="hljs-string">&#x27; &#x27;</span>);<br>            &#125;<br>            BYTEPADDING[i] = buf.toString();<br>        &#125;<br><br>        <span class="hljs-comment">// Generate the lookup table for byte-to-char conversion</span><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; BYTE2CHAR.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i &lt;= <span class="hljs-number">0x1f</span> || i &gt;= <span class="hljs-number">0x7f</span>) &#123;<br>                BYTE2CHAR[i] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                BYTE2CHAR[i] = (<span class="hljs-type">char</span>) i;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 打印所有内容</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> buffer</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">debugAll</span><span class="hljs-params">(ByteBuffer buffer)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">oldlimit</span> <span class="hljs-operator">=</span> buffer.limit();<br>        buffer.limit(buffer.capacity());<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">origin</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-number">256</span>);<br>        appendPrettyHexDump(origin, buffer, <span class="hljs-number">0</span>, buffer.capacity());<br>        System.out.println(<span class="hljs-string">&quot;+--------+-------------------- all ------------------------+----------------+&quot;</span>);<br>        System.out.printf(<span class="hljs-string">&quot;position: [%d], limit: [%d]\n&quot;</span>, buffer.position(), oldlimit);<br>        System.out.println(origin);<br>        buffer.limit(oldlimit);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 打印可读取内容</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> buffer</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">debugRead</span><span class="hljs-params">(ByteBuffer buffer)</span> &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-number">256</span>);<br>        appendPrettyHexDump(builder, buffer, buffer.position(), buffer.limit() - buffer.position());<br>        System.out.println(<span class="hljs-string">&quot;+--------+-------------------- read -----------------------+----------------+&quot;</span>);<br>        System.out.printf(<span class="hljs-string">&quot;position: [%d], limit: [%d]\n&quot;</span>, buffer.position(), buffer.limit());<br>        System.out.println(builder);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">appendPrettyHexDump</span><span class="hljs-params">(StringBuilder dump, ByteBuffer buf, <span class="hljs-type">int</span> offset, <span class="hljs-type">int</span> length)</span> &#123;<br>        <span class="hljs-keyword">if</span> (isOutOfBounds(offset, length, buf.capacity())) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexOutOfBoundsException</span>(<br>                    <span class="hljs-string">&quot;expected: &quot;</span> + <span class="hljs-string">&quot;0 &lt;= offset(&quot;</span> + offset + <span class="hljs-string">&quot;) &lt;= offset + length(&quot;</span> + length<br>                            + <span class="hljs-string">&quot;) &lt;= &quot;</span> + <span class="hljs-string">&quot;buf.capacity(&quot;</span> + buf.capacity() + <span class="hljs-string">&#x27;)&#x27;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        dump.append(<br>                <span class="hljs-string">&quot;         +-------------------------------------------------+&quot;</span> +<br>                        NEWLINE + <span class="hljs-string">&quot;         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |&quot;</span> +<br>                        NEWLINE + <span class="hljs-string">&quot;+--------+-------------------------------------------------+----------------+&quot;</span>);<br><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">startIndex</span> <span class="hljs-operator">=</span> offset;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">fullRows</span> <span class="hljs-operator">=</span> length &gt;&gt;&gt; <span class="hljs-number">4</span>;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">remainder</span> <span class="hljs-operator">=</span> length &amp; <span class="hljs-number">0xF</span>;<br><br>        <span class="hljs-comment">// Dump the rows which have 16 bytes.</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; row &lt; fullRows; row++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">rowStartIndex</span> <span class="hljs-operator">=</span> (row &lt;&lt; <span class="hljs-number">4</span>) + startIndex;<br><br>            <span class="hljs-comment">// Per-row prefix.</span><br>            appendHexDumpRowPrefix(dump, row, rowStartIndex);<br><br>            <span class="hljs-comment">// Hex dump</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">rowEndIndex</span> <span class="hljs-operator">=</span> rowStartIndex + <span class="hljs-number">16</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> rowStartIndex; j &lt; rowEndIndex; j++) &#123;<br>                dump.append(BYTE2HEX[getUnsignedByte(buf, j)]);<br>            &#125;<br>            dump.append(<span class="hljs-string">&quot; |&quot;</span>);<br><br>            <span class="hljs-comment">// ASCII dump</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> rowStartIndex; j &lt; rowEndIndex; j++) &#123;<br>                dump.append(BYTE2CHAR[getUnsignedByte(buf, j)]);<br>            &#125;<br>            dump.append(<span class="hljs-string">&#x27;|&#x27;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// Dump the last row which has less than 16 bytes.</span><br>        <span class="hljs-keyword">if</span> (remainder != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">rowStartIndex</span> <span class="hljs-operator">=</span> (fullRows &lt;&lt; <span class="hljs-number">4</span>) + startIndex;<br>            appendHexDumpRowPrefix(dump, fullRows, rowStartIndex);<br><br>            <span class="hljs-comment">// Hex dump</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">rowEndIndex</span> <span class="hljs-operator">=</span> rowStartIndex + remainder;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> rowStartIndex; j &lt; rowEndIndex; j++) &#123;<br>                dump.append(BYTE2HEX[getUnsignedByte(buf, j)]);<br>            &#125;<br>            dump.append(HEXPADDING[remainder]);<br>            dump.append(<span class="hljs-string">&quot; |&quot;</span>);<br><br>            <span class="hljs-comment">// Ascii dump</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> rowStartIndex; j &lt; rowEndIndex; j++) &#123;<br>                dump.append(BYTE2CHAR[getUnsignedByte(buf, j)]);<br>            &#125;<br>            dump.append(BYTEPADDING[remainder]);<br>            dump.append(<span class="hljs-string">&#x27;|&#x27;</span>);<br>        &#125;<br><br>        dump.append(NEWLINE +<br>                <span class="hljs-string">&quot;+--------+-------------------------------------------------+----------------+&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">appendHexDumpRowPrefix</span><span class="hljs-params">(StringBuilder dump, <span class="hljs-type">int</span> row, <span class="hljs-type">int</span> rowStartIndex)</span> &#123;<br>        <span class="hljs-keyword">if</span> (row &lt; HEXDUMP_ROWPREFIXES.length) &#123;<br>            dump.append(HEXDUMP_ROWPREFIXES[row]);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            dump.append(NEWLINE);<br>            dump.append(Long.toHexString(rowStartIndex &amp; <span class="hljs-number">0xFFFFFFFFL</span> | <span class="hljs-number">0x100000000L</span>));<br>            dump.setCharAt(dump.length() - <span class="hljs-number">9</span>, <span class="hljs-string">&#x27;|&#x27;</span>);<br>            dump.append(<span class="hljs-string">&#x27;|&#x27;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">short</span> <span class="hljs-title function_">getUnsignedByte</span><span class="hljs-params">(ByteBuffer buffer, <span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">short</span>) (buffer.get(index) &amp; <span class="hljs-number">0xFF</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h3 id="2-3-常用方法">2.3 常用方法</h3><h4 id="分配空间">分配空间</h4><p>使用 allocate 方法为 ByteBuffer 分配空间，其它 buffer 类也有该方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Bytebuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">16</span>);<br></code></pre></td></tr></table></figure><h4 id="向-buffer-写入数据">向 buffer 写入数据</h4><p>主要有两种方式</p><ul><li>调用 channel 的 read 方法，可以理解为从 channel 中读出了数据然后写到 buffer 中</li><li>调用 buffer 的 put 方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">readBytes</span> <span class="hljs-operator">=</span> channel.read(buf);<br></code></pre></td></tr></table></figure><p>和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">buf.put((<span class="hljs-type">byte</span>)<span class="hljs-number">127</span>);<br></code></pre></td></tr></table></figure><h4 id="从-buffer-读取数据">从 buffer 读取数据</h4><p>同样有两种方式</p><ul><li>调用 channel 的 write 方法，可以理解为从 buffer 中读出了数据然后写到 channel 中</li><li>调用 buffer 自己的 get 方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">writeBytes</span> <span class="hljs-operator">=</span> channel.write(buf);<br></code></pre></td></tr></table></figure><p>和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> buf.get();<br></code></pre></td></tr></table></figure><p>get 方法会让 position 读指针向后走，如果想重复读取数据</p><ul><li>可以调用 rewind 方法将 position 重新置为 0</li><li>或者调用 get(int i) 方法获取索引 i 的内容，这个方法不会移动读指针</li></ul><h4 id="mark-和-reset">mark 和 reset</h4><p>mark 是在读取时，做一个标记，即使 position 改变，只要调用 reset 就能回到 mark 的位置，注意 rewind 和 flip 都会清除 mark 位置。</p><h4 id="字符串与-ByteBuffer-互转">字符串与 ByteBuffer 互转</h4><p>字符串转为 ByteBuffer，可以使用 encode 方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf1</span> <span class="hljs-operator">=</span> StandardCharsets.UTF_8.encode(<span class="hljs-string">&quot;你好&quot;</span>);<br><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf2</span> <span class="hljs-operator">=</span> Charset.forName(<span class="hljs-string">&quot;utf-8&quot;</span>).encode(<span class="hljs-string">&quot;你好&quot;</span>);<br></code></pre></td></tr></table></figure><p>而 ByteBuffer 转为字符串，使用 decode 方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">CharBuffer</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> StandardCharsets.UTF_8.decode(buf1);<br><span class="hljs-type">CharBuffer</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> StandardCharsets.UTF_8.decode(buf2);<br>System.out.println(str1);<br>System.out.println(str2);<br></code></pre></td></tr></table></figure><h4 id="分散读取和集中填充">分散读取和集中填充</h4><p>分散读取：使用如下方式读取，可以将数据填充至多个 buffer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">RandomAccessFile</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomAccessFile</span>(<span class="hljs-string">&quot;parts.txt&quot;</span>, <span class="hljs-string">&quot;rw&quot;</span>)) &#123;<br>    <span class="hljs-type">FileChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> file.getChannel();<br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">3</span>);<br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">3</span>);<br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">5</span>);<br>    channel.read(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteBuffer</span>[]&#123;a, b, c&#125;);<br>    a.flip();<br>    b.flip();<br>    c.flip();<br>    debugAll(a);<br>    debugAll(b);<br>    debugAll(c);<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">         +-------------------------------------------------+<br>         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|<span class="hljs-number">00000000</span>| <span class="hljs-number">6f</span> 6e <span class="hljs-number">65</span>                                        |one             |<br>+--------+-------------------------------------------------+----------------+<br>         +-------------------------------------------------+<br>         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|<span class="hljs-number">00000000</span>| <span class="hljs-number">74</span> <span class="hljs-number">77</span> <span class="hljs-number">6f</span>                                        |two             |<br>+--------+-------------------------------------------------+----------------+<br>         +-------------------------------------------------+<br>         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|<span class="hljs-number">00000000</span>| <span class="hljs-number">74</span> <span class="hljs-number">68</span> <span class="hljs-number">72</span> <span class="hljs-number">65</span> <span class="hljs-number">65</span>                                  |three           |<br>+--------+-------------------------------------------------+----------------+<br></code></pre></td></tr></table></figure><p>集中填充：使用如下方式写入，可以将多个 buffer 的数据填充至 channel</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">RandomAccessFile</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomAccessFile</span>(<span class="hljs-string">&quot;parts.txt&quot;</span>, <span class="hljs-string">&quot;rw&quot;</span>)) &#123;<br>    <span class="hljs-type">FileChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> file.getChannel();<br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">4</span>);<br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">4</span>);<br>    channel.position(<span class="hljs-number">11</span>);<br><br>    d.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[]&#123;<span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;u&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>&#125;);<br>    e.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[]&#123;<span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-string">&#x27;v&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>&#125;);<br>    d.flip();<br>    e.flip();<br>    debugAll(d);<br>    debugAll(e);<br>    channel.write(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteBuffer</span>[]&#123;d, e&#125;);<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 66 6f 75 72                                     |four            |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 66 69 76 65                                     |five            |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br></code></pre></td></tr></table></figure><p>文件内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">onetwothreefourfive<br></code></pre></td></tr></table></figure><h2 id="3-Channel-之文件编程">3. Channel 之文件编程</h2><h3 id="3-1-FileChannel">3.1 FileChannel</h3><h4 id="工作模式">工作模式</h4><p>FileChannel 只能工作在阻塞模式下</p><h4 id="获取">获取</h4><p>不能直接打开 FileChannel，必须通过 FileInputStream、FileOutputStream 或者 RandomAccessFile 来获取 FileChannel，它们都有 getChannel 方法</p><ul><li>通过 FileInputStream 获取的 channel 只能读</li><li>通过 FileOutputStream 获取的 channel 只能写</li><li>通过 RandomAccessFile 是否能读写根据构造 RandomAccessFile 时的读写模式决定</li></ul><h4 id="读取">读取</h4><p>会从 channel 读取数据填充 ByteBuffer，返回值表示读到了多少字节，-1 表示到达了文件的末尾</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">readBytes</span> <span class="hljs-operator">=</span> channel.read(buffer);<br></code></pre></td></tr></table></figure><h4 id="写入">写入</h4><p>写入的正确姿势如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ...;<br>buffer.put(...); <span class="hljs-comment">// 存入数据</span><br>buffer.flip();   <span class="hljs-comment">// 切换读模式</span><br><br><span class="hljs-keyword">while</span>(buffer.hasRemaining()) &#123;<br>    channel.write(buffer);<br>&#125;<br></code></pre></td></tr></table></figure><p>在 while 中调用 channel.write 是因为 write 方法并不能保证一次将 buffer 中的内容全部写入 channel</p><h4 id="关闭">关闭</h4><p>channel 必须关闭，不过调用了 FileInputStream、FileOutputStream 或 RandomAccessFile 的 close 方法会间接地调用 channel 的 close 方法。</p><h4 id="位置">位置</h4><p>获取当前位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span> <span class="hljs-variable">pos</span> <span class="hljs-operator">=</span> channel.position();<br></code></pre></td></tr></table></figure><p>设置当前位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span> <span class="hljs-variable">newPos</span> <span class="hljs-operator">=</span> ...;<br>channel.position(newPos);<br></code></pre></td></tr></table></figure><p>设置当前位置时，如果设置为文件的末尾</p><ul><li>这时读取会返回 -1</li><li>这时写入，会追加内容，但要注意如果 position 超过了文件末尾，再写入时在新内容和原末尾之间会有空洞（00）</li></ul><h4 id="大小">大小</h4><p>使用 size 方法获取文件的大小</p><h4 id="强制写入">强制写入</h4><p>操作系统出于性能的考虑，会将数据缓存，不是立刻写入磁盘。可以调用 force(true) 方法将文件内容和元数据（文件的权限等信息）立刻写入磁盘</p><h3 id="3-2-两个-Channel-传输数据">3.2 两个 Channel 传输数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">FROM</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;data.txt&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">TO</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;to.txt&quot;</span>;<br><br><span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.nanoTime();<br><span class="hljs-keyword">try</span> (<br>    <span class="hljs-type">FileChannel</span> <span class="hljs-variable">from</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(FROM).getChannel();<br>    <span class="hljs-type">FileChannel</span> <span class="hljs-variable">to</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(TO).getChannel();<br>) &#123;<br>    from.transferTo(<span class="hljs-number">0</span>, from.size(), to);<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace();<br>&#125;<br><span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.nanoTime();<br>System.out.println(<span class="hljs-string">&quot;transferTo 用时：&quot;</span> + (end - start) / <span class="hljs-number">1000_000.0</span>);<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">transferTo</span> 用时：<span class="hljs-number">8</span>.<span class="hljs-number">2011</span><br></code></pre></td></tr></table></figure><p>超过 2g 大小的文件传输</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestFileChannelTransferTo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> (<br>                <span class="hljs-type">FileChannel</span> <span class="hljs-variable">from</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;data.txt&quot;</span>).getChannel();<br>                <span class="hljs-type">FileChannel</span> <span class="hljs-variable">to</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;to.txt&quot;</span>).getChannel();<br>        ) &#123;<br>            <span class="hljs-comment">// 效率高，底层会利用操作系统的零拷贝进行优化</span><br>            <span class="hljs-type">long</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> from.size();<br>            <span class="hljs-comment">// left 变量代表还剩余多少字节</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> size; left &gt; <span class="hljs-number">0</span>; ) &#123;<br>                System.out.println(<span class="hljs-string">&quot;position:&quot;</span> + (size - left) + <span class="hljs-string">&quot; left:&quot;</span> + left);<br>                left -= from.transferTo((size - left), left, to);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际传输一个超大文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">position:<span class="hljs-number">0</span> left:<span class="hljs-number">7769948160</span><br>position:<span class="hljs-number">2147483647</span> left:<span class="hljs-number">5622464513</span><br>position:<span class="hljs-number">4294967294</span> left:<span class="hljs-number">3474980866</span><br>position:<span class="hljs-number">6442450941</span> left:<span class="hljs-number">1327497219</span><br></code></pre></td></tr></table></figure><h3 id="3-3-Path">3.3 Path</h3><p>jdk7 引入了 Path 和 Paths 类</p><ul><li>Path 用来表示文件路径</li><li>Paths 是工具类，用来获取 Path 实例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Path</span> <span class="hljs-variable">source</span> <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">&quot;1.txt&quot;</span>);     <span class="hljs-comment">// 相对路径，使用 user.dir 环境变量来定位 1.txt</span><br><span class="hljs-type">Path</span> <span class="hljs-variable">source</span> <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">&quot;d:\\1.txt&quot;</span>); <span class="hljs-comment">// 绝对路径，代表了 d:\1.txt</span><br><span class="hljs-type">Path</span> <span class="hljs-variable">source</span> <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">&quot;d:/1.txt&quot;</span>); <span class="hljs-comment">// 绝对路径，代表了 d:\1.txt</span><br><span class="hljs-type">Path</span> <span class="hljs-variable">projects</span> <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">&quot;d:\\data&quot;</span>, <span class="hljs-string">&quot;projects&quot;</span>);  <span class="hljs-comment">// 代表了 d:\data\projects</span><br></code></pre></td></tr></table></figure><ul><li><code>.</code> 代表了当前路径</li><li><code>..</code> 代表了上一级路径</li></ul><p>例如目录结构如下</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs 1c">d:<br><span class="hljs-string">|- data</span><br><span class="hljs-string">|- projects</span><br><span class="hljs-string">|- a</span><br><span class="hljs-string">|- b</span><br></code></pre></td></tr></table></figure><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Path</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">&quot;d:\\data\\projects\\a\\..\\b&quot;</span>);<br>System.out.println(path);<br>System.out.println(path.normalize()); <span class="hljs-comment">// 正常化路径</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">d</span>:\<span class="hljs-class"><span class="hljs-keyword">data</span>\projects\a\..\b</span><br><span class="hljs-title">d</span>:\<span class="hljs-class"><span class="hljs-keyword">data</span>\projects\b</span><br></code></pre></td></tr></table></figure><h3 id="3-4-Files">3.4 Files</h3><p>检查文件是否存在</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Path</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">&quot;helloword/data.txt&quot;</span>);<br>System.out.println(Files.exists(path));<br></code></pre></td></tr></table></figure><p>创建一级目录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Path</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">&quot;helloword/d1&quot;</span>);<br>Files.createDirectory(path);<br></code></pre></td></tr></table></figure><ul><li>如果目录已存在，会抛异常 FileAlreadyExistsException</li><li>不能一次创建多级目录，否则会抛异常 NoSuchFileException</li></ul><p>创建多级目录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Path</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">&quot;helloword/d1/d2&quot;</span>);<br>Files.createDirectories(path);<br></code></pre></td></tr></table></figure><p>拷贝文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Path</span> <span class="hljs-variable">source</span> <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">&quot;helloword/data.txt&quot;</span>);<br><span class="hljs-type">Path</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">&quot;helloword/target.txt&quot;</span>);<br><br>Files.copy(source, target);<br></code></pre></td></tr></table></figure><ul><li>如果文件已存在，会抛异常 FileAlreadyExistsException</li></ul><p>如果希望用 source 覆盖掉 target，需要用 StandardCopyOption 来控制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Files.copy(source, target, StandardCopyOption.REPLACE_EXISTING);<br></code></pre></td></tr></table></figure><p>移动文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Path</span> <span class="hljs-variable">source</span> <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">&quot;helloword/data.txt&quot;</span>);<br><span class="hljs-type">Path</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">&quot;helloword/data.txt&quot;</span>);<br><br>Files.move(source, target, StandardCopyOption.ATOMIC_MOVE);<br></code></pre></td></tr></table></figure><ul><li>StandardCopyOption.ATOMIC_MOVE 保证文件移动的原子性</li></ul><p>删除文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Path</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">&quot;helloword/target.txt&quot;</span>);<br><br>Files.delete(target);<br></code></pre></td></tr></table></figure><ul><li>如果文件不存在，会抛异常 NoSuchFileException</li></ul><p>删除目录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Path</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">&quot;helloword/d1&quot;</span>);<br><br>Files.delete(target);<br></code></pre></td></tr></table></figure><ul><li>如果目录还有内容，会抛异常 DirectoryNotEmptyException</li></ul><p>遍历目录文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">Path</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">&quot;D:\\environment\\jdk8\\jdk1.8.0_91&quot;</span>);<br>    <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">dirCount</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br>    <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">fileCount</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br>    <br>    Files.walkFileTree(path, <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleFileVisitor</span>&lt;Path&gt;()&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> FileVisitResult <span class="hljs-title function_">preVisitDirectory</span><span class="hljs-params">(Path dir, BasicFileAttributes attrs)</span> <br>            <span class="hljs-keyword">throws</span> IOException &#123;<br>            System.out.println(dir);<br>            dirCount.incrementAndGet();<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.preVisitDirectory(dir, attrs);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> FileVisitResult <span class="hljs-title function_">visitFile</span><span class="hljs-params">(Path file, BasicFileAttributes attrs)</span> <br>            <span class="hljs-keyword">throws</span> IOException &#123;<br>            System.out.println(file);<br>            fileCount.incrementAndGet();<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.visitFile(file, attrs);<br>        &#125;<br>    &#125;);<br>    System.out.println(dirCount);<br>    System.out.println(fileCount);<br>&#125;<br></code></pre></td></tr></table></figure><p>统计 jar 的数目</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Path</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">&quot;D:\\environment\\jdk8\\jdk1.8.0_91&quot;</span>);<br><span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">fileCount</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br>Files.walkFileTree(path, <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleFileVisitor</span>&lt;Path&gt;()&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> FileVisitResult <span class="hljs-title function_">visitFile</span><span class="hljs-params">(Path file, BasicFileAttributes attrs)</span> <br>        <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">if</span> (file.toFile().getName().endsWith(<span class="hljs-string">&quot;.jar&quot;</span>)) &#123;<br>            fileCount.incrementAndGet();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.visitFile(file, attrs);<br>    &#125;<br>&#125;);<br>System.out.println(fileCount);<br></code></pre></td></tr></table></figure><p>删除多级目录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Path</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">&quot;d:\\a&quot;</span>);<br>Files.walkFileTree(path, <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleFileVisitor</span>&lt;Path&gt;()&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> FileVisitResult <span class="hljs-title function_">visitFile</span><span class="hljs-params">(Path file, BasicFileAttributes attrs)</span> <br>        <span class="hljs-keyword">throws</span> IOException &#123;<br>        Files.delete(file);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.visitFile(file, attrs);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> FileVisitResult <span class="hljs-title function_">postVisitDirectory</span><span class="hljs-params">(Path dir, IOException exc)</span> <br>        <span class="hljs-keyword">throws</span> IOException &#123;<br>        Files.delete(dir);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.postVisitDirectory(dir, exc);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>拷贝多级目录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br><span class="hljs-type">String</span> <span class="hljs-variable">source</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;D:\\Snipaste-1.16.2-x64&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;D:\\Snipaste-1.16.2-x64aaa&quot;</span>;<br><br>Files.walk(Paths.get(source)).forEach(path -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">targetName</span> <span class="hljs-operator">=</span> path.toString().replace(source, target);<br>        <span class="hljs-comment">// 是目录</span><br>        <span class="hljs-keyword">if</span> (Files.isDirectory(path)) &#123;<br>            Files.createDirectory(Paths.get(targetName));<br>        &#125;<br>        <span class="hljs-comment">// 是普通文件</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Files.isRegularFile(path)) &#123;<br>            Files.copy(path, Paths.get(targetName));<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;);<br><span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>System.out.println(end - start);<br></code></pre></td></tr></table></figure><h2 id="4-Channel-之-TCP-网络编程">4. Channel 之 TCP 网络编程</h2><h3 id="4-1-阻塞-vs-非阻塞">4.1 阻塞 vs 非阻塞</h3><p>首先写一个测试代码来展示什么是阻塞，如下：</p><p>服务端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">16</span>);<br>    <span class="hljs-comment">// 创建服务器</span><br>    <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">ssc</span> <span class="hljs-operator">=</span> ServerSocketChannel.open();<br>    <span class="hljs-comment">// 绑定监听端口</span><br>    ssc.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">8080</span>));<br>    <span class="hljs-comment">// 连接集合</span><br>    List&lt;SocketChannel&gt; channels = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        log.debug(<span class="hljs-string">&quot;connecting&quot;</span>);<br>        <span class="hljs-comment">// accept 方法是阻塞方法，导致线程阻塞</span><br>        <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> ssc.accept();<br>        log.debug(<span class="hljs-string">&quot;connected, &#123;&#125;&quot;</span>, sc);<br>        channels.add(sc);<br>        <span class="hljs-keyword">for</span> (SocketChannel channel : channels) &#123;<br>            log.debug(<span class="hljs-string">&quot;before read &#123;&#125;&quot;</span>, channel);<br>            <span class="hljs-comment">// read 方法是阻塞方法，导致线程阻塞</span><br>            channel.read(buf);<br>            buf.flip();<br>            debugAll(buf);<br>            buf.clear();<br>            log.debug(<span class="hljs-string">&quot;after read &#123;&#125;&quot;</span>, channel);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> SocketChannel.open();<br>    sc.connect(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>));<br>    System.out.println(<span class="hljs-string">&quot;waiting...&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>你可以运行上面的服务端和客户端的代码，自行体会阻塞的含义。</p><p>在阻塞模式下，相关的方法如，accept、read 都会导致线程暂停，不会占用 CPU 资源，在单线程模式下（如上面的代码运行），阻塞方法之间几乎不能正常工作，需要多线程的支持。</p><p>但还是像之前说的，多线程下，有新的问题，体现在以下方面</p><ul><li>32 位 jvm 一个线程 320k，64 位 jvm 一个线程 1024k，如果连接数过多，必然导致 OOM，并且线程太多，反而会因为频繁上下文切换导致性能降低。</li><li>可以采用线程池技术来减少线程数和线程上下文切换，但治标不治本，如果有很多连接建立，但长时间 inactive，会阻塞线程池中所有线程，因此不适合长连接，只适合短连接。</li></ul><p>那如果我们将上面的例子改为非阻塞呢，如下：</p><p>服务端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">16</span>);<br>    <span class="hljs-comment">// 创建了服务器</span><br>    <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">ssc</span> <span class="hljs-operator">=</span> ServerSocketChannel.open();<br>    <span class="hljs-comment">// 设置为非阻塞模式</span><br>    ssc.configureBlocking(<span class="hljs-literal">false</span>);<br>    <span class="hljs-comment">// 绑定监听端口</span><br>    ssc.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">8080</span>));<br>    <span class="hljs-comment">// 连接集合</span><br>    List&lt;SocketChannel&gt; channels = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-comment">// 非阻塞，线程还会继续运行，如果没有连接建立，则 sc 为 null</span><br>        <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> ssc.accept();<br>        <span class="hljs-keyword">if</span> (sc != <span class="hljs-literal">null</span>) &#123;<br>            log.debug(<span class="hljs-string">&quot;connected... &#123;&#125;&quot;</span>, sc);<br>            <span class="hljs-comment">// 设置为非阻塞模式</span><br>            sc.configureBlocking(<span class="hljs-literal">false</span>);<br>            channels.add(sc);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (SocketChannel channel : channels) &#123;<br>            <span class="hljs-comment">// 非阻塞，线程仍然会继续运行，如果没有读到数据，则 read 返回 0</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">read</span> <span class="hljs-operator">=</span> channel.read(buffer);<br>            <span class="hljs-keyword">if</span> (read &gt; <span class="hljs-number">0</span>) &#123;<br>                buffer.flip();<br>                debugAll(buffer);<br>                buffer.clear();<br>                log.debug(<span class="hljs-string">&quot;after read...&#123;&#125;&quot;</span>, channel);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端代码不变，我们运行会发现，好像已经可以正常工作了，但是由于是非阻塞方法，那么线程在不断地运行，CPU 占用率飙升。</p><p>所以在非阻塞模式下，相关方法不会让线程暂停</p><ul><li>在 ServerSocketChannel.accept 在没有连接建立时，会返回 null，继续运行</li><li>在 SocketChannel.read 在没有数据可读时，会返回 0，但线程不必阻塞，可以去执行其它 SocketChannel 的 read 或是去执行 ServerSocketChannel.accept</li><li>写数据时，线程只是等待数据写入 Channel 即可，无需等 Channel 通过网络把数据发送出去</li></ul><p>但非阻塞模式下，即使没有连接建立或者没有可读数据，线程仍然不断运行，白白浪费了 CPU，而在数据复制过程中，线程实际还是阻塞的。</p><h3 id="4-2-Selector">4.2 Selector</h3><p>单线程配合 Selector 完成对多个 Channel 可读写事件的监控，这称之为 <strong>多路复用</strong>。</p><ul><li>多路复用仅针对网络 IO、普通文件 IO 无法利用多路复用</li><li>如果不使用 Selector 的非阻塞模式，线程大部分时间都在做无用功，而一旦使用 Selector 的非阻塞模式，那么 Selector 能够保证<ul><li>有可连接事件时才去连接</li><li>有可读事件才去读取</li><li>有可写事件才去写入，限于网络传输能力，Channel 未必时时可写，一旦 Channel 可写，会触发 Selector 的可写事件</li></ul></li></ul><p><img src="/java/javase-beb1cfdacc32/image-20240114213101046.png" alt="selector"></p><p>好处</p><ul><li>单线程配合 Selector 可以监控多个 Channel 的事件，事件发生线程才去处理。避免非阻塞模式下线程做无用功，白白浪费 CPU 资源</li><li>线程能够被充分利用</li><li>节约了线程的数量</li><li>减少了线程上下文切换</li></ul><h4 id="创建">创建</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Selector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> Selector.open();<br></code></pre></td></tr></table></figure><h4 id="绑定-Channel-事件">绑定 Channel 事件</h4><p>也称之为注册事件，绑定的事件 Selector 才会关心</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">channel.configureBlocking(<span class="hljs-literal">false</span>);<br><span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> channel.register(selector, 绑定事件);<br></code></pre></td></tr></table></figure><ul><li>channel 必须工作在非阻塞模式，而 FileChannel 没有非阻塞模式，因此不能配合 selector 一起使用</li><li>绑定的事件类型可以有<ul><li>connect 事件，客户端连接成功时触发</li><li>accept 事件，服务器端成功接受连接时触发</li><li>read 事件，数据可读入时触发，有因为接收能力弱，数据暂不能读入的情况</li><li>write 事件，数据可写出时触发，有因为发送能力弱，数据暂不能写出的情况</li></ul></li></ul><h4 id="监听-Channel-事件">监听 Channel 事件</h4><p>可以通过下面三种方法来监听是否有事件发生，方法的返回值代表有多少 channel 发生了事件</p><p>方法 1，阻塞直到绑定事件发生</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> selector.select();<br></code></pre></td></tr></table></figure><p>方法 2，阻塞直到绑定事件发生，或是超时（时间单位为 ms）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> selector.select(<span class="hljs-type">long</span> timeout);<br></code></pre></td></tr></table></figure><p>方法 3，不会阻塞，也就是不管有没有事件，立刻返回，自己根据返回值检查是否有事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> selector.selectNow();<br></code></pre></td></tr></table></figure><h4 id="Select-何时不阻塞">Select 何时不阻塞</h4><ul><li>事件发生时<ul><li>客户端发起连接请求，会触发 accept 事件</li><li>客户端发送数据过来，客户端正常、异常关闭时，都会触发 read 事件，另外如果发送的数据大于 buffer 缓冲区，会触发多次读取事件</li><li>channel 可写，会触发 write 事件</li><li>在 linux 下 nio bug 发生时</li></ul></li><li>调用 selector.wakeup()，wakeup 方法类似于 LockSupport.unpark() 方法，可以提前给信号量。</li><li>调用 selector.close()</li><li>selector 所在线程 interrupt</li></ul><h3 id="4-3-处理-accept-事件">4.3 处理 accept 事件</h3><h4 id="注意">注意</h4><ol><li>事件发生之后，要么取消（key.cancel），要么处理，不能什么都不做，否则下次该事件仍会触发，这是因为 Nio 底层使用的是水平触发。</li><li>在处理完事件后，必须将该事件的 key 从 selectionKeys 中删除，由于是在遍历过程中删除，需要使用 iterator 迭代器遍历。</li></ol><h4 id="cancel-的作用">cancel 的作用</h4><p>cancel 会取消注册在 selector 上的 channel，并从 keys 集合中删除 key，后续不会再监听事件。</p><h4 id="示例">示例</h4><p>服务端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">ssc</span> <span class="hljs-operator">=</span> ServerSocketChannel.open()) &#123;<br>        <span class="hljs-comment">// 绑定端口</span><br>        ssc.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">8080</span>));<br>        <span class="hljs-comment">// 创建 Selector</span><br>        <span class="hljs-type">Selector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> Selector.open();<br>        <span class="hljs-comment">// 设置为非阻塞模式</span><br>        ssc.configureBlocking(<span class="hljs-literal">false</span>);<br>        <span class="hljs-comment">// 将 ssc 注册到 selector 并关注可连接事件</span><br>        ssc.register(selector, SelectionKey.OP_ACCEPT);<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">// 阻塞直到监听的事件发生</span><br>            selector.select();<br>            <span class="hljs-comment">// 获取所有事件</span><br>            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();<br>            <span class="hljs-comment">// 遍历所有事件</span><br>            Iterator&lt;SelectionKey&gt; iter = selectionKeys.iterator();<br>            <span class="hljs-keyword">while</span> (iter.hasNext()) &#123;<br>                <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> iter.next();<br>                <span class="hljs-comment">// 判断是否是可连接事件</span><br>                <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;<br>                    <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> (ServerSocketChannel) key.channel();<br>                    <span class="hljs-comment">// 必须处理</span><br>                    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> c.accept();<br>                &#125;<br>                <span class="hljs-comment">// 处理完事件后，必须将事件移除</span><br>                iter.remove();<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> SocketChannel.open();<br>    sc.connect(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>));<br>    System.out.println(<span class="hljs-string">&quot;waiting...&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-4-处理-read-事件">4.4 处理 read 事件</h3><h4 id="为什么要删除事件的-key">为什么要删除事件的 key</h4><p>参考下面的代码，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">ssc</span> <span class="hljs-operator">=</span> ServerSocketChannel.open()) &#123;<br>        <span class="hljs-comment">// 绑定端口</span><br>        ssc.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">8080</span>));<br>        <span class="hljs-comment">// 创建 Selector</span><br>        <span class="hljs-type">Selector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> Selector.open();<br>        <span class="hljs-comment">// 设置为非阻塞模式</span><br>        ssc.configureBlocking(<span class="hljs-literal">false</span>);<br>        <span class="hljs-comment">// 将 ssc 注册到 selector 并关注可连接事件</span><br>        ssc.register(selector, SelectionKey.OP_ACCEPT);<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">// 阻塞直到监听的事件发生</span><br>            selector.select();<br>            <span class="hljs-comment">// 获取所有事件</span><br>            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();<br>            <span class="hljs-comment">// 遍历所有事件</span><br>            Iterator&lt;SelectionKey&gt; iter = selectionKeys.iterator();<br>            <span class="hljs-keyword">while</span> (iter.hasNext()) &#123;<br>                <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> iter.next();<br>                <span class="hljs-comment">// 判断是否是可连接事件</span><br>                <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;<br>                    <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> (ServerSocketChannel) key.channel();<br>                    <span class="hljs-comment">// 必须处理</span><br>                    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> c.accept();<br>                    <span class="hljs-comment">// 设置为非阻塞模式</span><br>                    sc.configureBlocking(<span class="hljs-literal">false</span>);<br>                    <span class="hljs-comment">// 将 sc 注册到 selector 并关注可读事件</span><br>                    sc.register(selector, SelectionKey.OP_READ);<br>                    log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, sc);<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isReadable()) &#123;<br>                    <span class="hljs-comment">// 判断是可读事件</span><br>                    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> (SocketChannel) key.channel();<br>                    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">16</span>);<br>                    c.read(buf);<br>                    buf.flip();<br>                    debugAll(buf);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果不删除处理完事件的 key，那么一旦客户端连接到服务端，并发送一个消息，运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">+--------+-------------------- all ------------------------+----------------+<br>position: [<span class="hljs-number">0</span>], limit: [<span class="hljs-number">2</span>]<br>         +-------------------------------------------------+<br>         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|<span class="hljs-number">00000000</span>| <span class="hljs-number">68</span> <span class="hljs-number">69</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> |hi..............|<br>+--------+-------------------------------------------------+----------------+<br>Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.NullPointerException<br>at cn.ocsio.Server.main(Server.java:<span class="hljs-number">45</span>)<br></code></pre></td></tr></table></figure><p>你可以看到，报了空指针异常。这是怎么回事呢？</p><p>我们来慢慢分析，当执行到 <code>ssc.register(selector, SelectionKey.OP_ACCEPT)</code> 时，会将该 ssckey 加入到一个 keys 集合，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> SelectionKey <span class="hljs-title function_">register</span><span class="hljs-params">(Selector sel, <span class="hljs-type">int</span> ops, Object att)</span> <span class="hljs-keyword">throws</span> ClosedChannelException &#123;<br>    <span class="hljs-keyword">synchronized</span> (regLock) &#123;<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> findKey(sel);<br>        <span class="hljs-keyword">if</span> (k != <span class="hljs-literal">null</span>) &#123;<br>            k.interestOps(ops);<br>            k.attach(att);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// New registration</span><br>            <span class="hljs-keyword">synchronized</span> (keyLock) &#123;<br>                <span class="hljs-comment">// ...</span><br>                k = ((AbstractSelector)sel).register(<span class="hljs-built_in">this</span>, ops, att);<br>                <span class="hljs-comment">// ssc 第一次注册到 Selector，所以进入下面的 addKey 方法</span><br>                <span class="hljs-comment">// 就是将 k 加入到一个 keys 的 SelectionKey 数组中</span><br>                addKey(k);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> k;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着 <code>selector.select()</code>，线程阻塞直到监听的事件发生，假设此时客户端连接到服务端，那么会将发生了事件的 key 即 sscKey 加入到另一个集合 selectedKeys 中，所以后续我们才可以遍历这个集合处理事件，但是这个集合有一个毛病，它只会主动添加而不会主动移除。</p><p>当第一次遍历该 selectedKeys 集合处理完客户端的连接事件后，并没有移除集合中 sscKey，那么当进入下一次循环，又会处理该 sscKey，但是此时已经没有客户端的连接事件了，那么调用 <code>c.accept()</code> 返回的是 null，而后续 <code>null.configureBlocking</code> 自然报空指针了。</p><p>我再用一个动图解释一下：</p><p><img src="/java/javase-beb1cfdacc32/image-20240114213101047.gif" alt="删除事件 Key"></p><h4 id="处理客户端的断开">处理客户端的断开</h4><p>对于客户端来说，可能是异常断开，也可能是调用 sc.close 方法正常断开，而不管是正常断开，还是异常断开，都会触发 sc 的可读事件，所以我们的服务器必须要对这两种情况做出处理。</p><ul><li>异常断开：我们在 catch 块中取消 key 即可。</li><li>正常断开：客户端会触发一次读事件，并且 read 方法返回 -1，所以我们根据这个来判断，并取消 key 即可。</li></ul><p>一旦取消了 key，那么该 key 就会从 keys 集合中移除，那么 Selector 就不会在监听该客户端连接了。</p><p>代码改进如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">ssc</span> <span class="hljs-operator">=</span> ServerSocketChannel.open()) &#123;<br>        <span class="hljs-comment">// 绑定端口</span><br>        ssc.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">8080</span>));<br>        <span class="hljs-comment">// 创建 Selector</span><br>        <span class="hljs-type">Selector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> Selector.open();<br>        <span class="hljs-comment">// 设置为非阻塞模式</span><br>        ssc.configureBlocking(<span class="hljs-literal">false</span>);<br>        <span class="hljs-comment">// 将 ssc 注册到 selector 并关注可连接事件</span><br>        ssc.register(selector, SelectionKey.OP_ACCEPT);<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">// 阻塞直到监听的事件发生</span><br>            selector.select();<br>            <span class="hljs-comment">// 获取所有事件</span><br>            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();<br>            <span class="hljs-comment">// 遍历所有事件</span><br>            Iterator&lt;SelectionKey&gt; iter = selectionKeys.iterator();<br>            <span class="hljs-keyword">while</span> (iter.hasNext()) &#123;<br>                <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> iter.next();<br>                <span class="hljs-comment">// 判断是否是可连接事件</span><br>                <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;<br>                    <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> (ServerSocketChannel) key.channel();<br>                    <span class="hljs-comment">// 必须处理</span><br>                    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> c.accept();<br>                    <span class="hljs-comment">// 设置为非阻塞模式</span><br>                    sc.configureBlocking(<span class="hljs-literal">false</span>);<br>                    <span class="hljs-comment">// 将 sc 注册到 selector 并关注可读事件</span><br>                    sc.register(selector, SelectionKey.OP_READ);<br>                    log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, sc);<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isReadable()) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-comment">// 判断是可读事件</span><br>                        <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> (SocketChannel) key.channel();<br>                        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">16</span>);<br>                        <span class="hljs-type">int</span> <span class="hljs-variable">read</span> <span class="hljs-operator">=</span> c.read(buf);<br>                        <span class="hljs-comment">// 处理客户端正常断开</span><br>                        <span class="hljs-keyword">if</span> (read == -<span class="hljs-number">1</span>) &#123;<br>                            key.cancel();<br>                        &#125; <span class="hljs-keyword">else</span> &#123;<br>                            buf.flip();<br>                            debugAll(buf);<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                        e.printStackTrace();<br>                        <span class="hljs-comment">// 处理客户端异常断开</span><br>                        key.cancel();<br>                    &#125;<br>                &#125;<br>                <span class="hljs-comment">// 处理完事件后，必须将事件移除</span><br>                iter.remove();<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> SocketChannel.open();<br>    sc.connect(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>));<br>    System.out.println(<span class="hljs-string">&quot;waiting...&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="消息边界问题">消息边界问题</h4><p>参考下面的代码：</p><p>服务端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">ssc</span> <span class="hljs-operator">=</span> ServerSocketChannel.open()) &#123;<br>        <span class="hljs-comment">// 绑定端口</span><br>        ssc.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">8080</span>));<br>        <span class="hljs-comment">// 创建 Selector</span><br>        <span class="hljs-type">Selector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> Selector.open();<br>        <span class="hljs-comment">// 设置为非阻塞模式</span><br>        ssc.configureBlocking(<span class="hljs-literal">false</span>);<br>        <span class="hljs-comment">// 将 ssc 注册到 selector 并关注可连接事件</span><br>        ssc.register(selector, SelectionKey.OP_ACCEPT);<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">// 阻塞直到监听的事件发生</span><br>            selector.select();<br>            <span class="hljs-comment">// 获取所有事件</span><br>            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();<br>            <span class="hljs-comment">// 遍历所有事件</span><br>            Iterator&lt;SelectionKey&gt; iter = selectionKeys.iterator();<br>            <span class="hljs-keyword">while</span> (iter.hasNext()) &#123;<br>                <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> iter.next();<br>                <span class="hljs-comment">// 判断是否是可连接事件</span><br>                <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;<br>                    <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> (ServerSocketChannel) key.channel();<br>                    <span class="hljs-comment">// 必须处理</span><br>                    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> c.accept();<br>                    <span class="hljs-comment">// 设置为非阻塞模式</span><br>                    sc.configureBlocking(<span class="hljs-literal">false</span>);<br>                    <span class="hljs-comment">// 将 sc 注册到 selector 并关注可读事件</span><br>                    sc.register(selector, SelectionKey.OP_READ);<br>                    log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, sc);<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isReadable()) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-comment">// 判断是可读事件</span><br>                        <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> (SocketChannel) key.channel();<br>                        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">4</span>);<br>                        <span class="hljs-type">int</span> <span class="hljs-variable">read</span> <span class="hljs-operator">=</span> c.read(buf);<br>                        <span class="hljs-comment">// 处理客户端正常断开</span><br>                        <span class="hljs-keyword">if</span> (read == -<span class="hljs-number">1</span>) &#123;<br>                            key.cancel();<br>                        &#125; <span class="hljs-keyword">else</span> &#123;<br>                            buf.flip();<br>                            <span class="hljs-type">CharBuffer</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> StandardCharsets.UTF_8.decode(buf);<br>                            System.out.println(str);<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                        e.printStackTrace();<br>                        <span class="hljs-comment">// 处理客户端异常断开</span><br>                        key.cancel();<br>                    &#125;<br>                &#125;<br>                <span class="hljs-comment">// 处理完事件后，必须将事件移除</span><br>                iter.remove();<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> SocketChannel.open();<br>    sc.connect(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>));<br>    sc.write(Charsets.UTF_8.encode(<span class="hljs-string">&quot;hello&quot;</span>));<br>    sc.write(Charsets.UTF_8.encode(<span class="hljs-string">&quot;world&quot;</span>));<br>    sc.write(Charsets.UTF_8.encode(<span class="hljs-string">&quot;你好&quot;</span>));<br>    System.in.read();<br>&#125;<br></code></pre></td></tr></table></figure><p>你会发现输出的结果是这样的，出现了乱码，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">hell<br>owor<br>ld�<br>�好<br></code></pre></td></tr></table></figure><p>事实上，由于我们的 buffer 缓冲区只有 4 个字节，而对于汉字的 UTF-8 编码，一个汉字占 3 个字节，所以一个 buffer 显然无法存储 “你好” 这两个汉字，所以会将第二个汉字拆开，就出现了上面的乱码现象。</p><p>如何处理？几种方案：</p><ul><li>一种思路是固定消息长度，数据包大小一样，服务器按预定长度读取，缺点是浪费带宽</li><li>另一种思路是按分隔符，如 \n 进行拆分，缺点是效率低</li><li>TLV 格式，即 Type 类型、Length 长度、Value 数据，类型和长度已知的情况下，就可以方便获取消息大小，分配合适的 buffer，缺点是 buffer 需要提前分配，如果内容过大，则影响 server 吞吐量<ul><li>Http 1.1 是 TLV 格式</li><li>Http 2.0 是 LTV 格式</li></ul></li></ul><p>下面我们按分隔符拆分，来解决黏包半包问题。</p><p>在 Channel 注册到 Selector 上时，除了指定是哪一个 Selector，关注的事件类型，还可以关联一个附件 attachment。</p><p>服务端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">split</span><span class="hljs-params">(ByteBuffer source)</span> &#123;<br>    source.flip();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; source.limit(); i++) &#123;<br>        <span class="hljs-comment">// 找到一条完整消息</span><br>        <span class="hljs-keyword">if</span> (source.get(i) == <span class="hljs-string">&#x27;\n&#x27;</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span> - source.position();<br>            <span class="hljs-comment">// 把这条完整消息存入新的 ByteBuffer</span><br>            <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(length);<br>            <span class="hljs-comment">// 从 source 读，向 target 写</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; length; j++) &#123;<br>                target.put(source.get());<br>            &#125;<br>            target.flip();<br>            <span class="hljs-type">CharBuffer</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> Charsets.UTF_8.decode(target);<br>            System.out.print(str);<br>        &#125;<br>    &#125;<br>    source.compact();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">Selector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> Selector.open();<br>    <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">ssc</span> <span class="hljs-operator">=</span> ServerSocketChannel.open();<br>    ssc.configureBlocking(<span class="hljs-literal">false</span>);<br>    ssc.register(selector, SelectionKey.OP_ACCEPT, <span class="hljs-literal">null</span>);<br>    ssc.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">8080</span>));<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        selector.select();<br>        Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();<br>        <span class="hljs-keyword">while</span> (iter.hasNext()) &#123;<br>            <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> iter.next();<br>            <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;<br>                <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> (ServerSocketChannel) key.channel();<br>                <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> channel.accept();<br>                sc.configureBlocking(<span class="hljs-literal">false</span>);<br>                <span class="hljs-comment">// attachment</span><br>                <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">16</span>);<br>                <span class="hljs-comment">// 将一个 byteBuffer 作为附件关联到 selectionKey 上</span><br>                sc.register(selector, SelectionKey.OP_READ, buffer);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isReadable()) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> (SocketChannel) key.channel();<br>                    <span class="hljs-comment">// 获取 selectionKey 上关联的附件</span><br>                    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> (ByteBuffer) key.attachment();<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">read</span> <span class="hljs-operator">=</span> channel.read(buffer);<br>                    <span class="hljs-keyword">if</span> (read == -<span class="hljs-number">1</span>) &#123;<br>                        key.cancel();<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        split(buffer);<br>                        <span class="hljs-comment">// 需要扩容</span><br>                        <span class="hljs-keyword">if</span> (buffer.position() == buffer.limit()) &#123;<br>                            <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">newBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(buffer.capacity() * <span class="hljs-number">2</span>);<br>                            buffer.flip();<br>                            newBuffer.put(buffer);<br>                            key.attach(newBuffer);<br>                        &#125;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                    key.cancel();<br>                &#125;<br>            &#125;<br>            iter.remove();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> SocketChannel.open();<br>    sc.connect(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>));<br>    sc.write(Charsets.UTF_8.encode(<span class="hljs-string">&quot;hello\n&quot;</span>));<br>    sc.write(Charsets.UTF_8.encode(<span class="hljs-string">&quot;world\n&quot;</span>));<br>    sc.write(Charsets.UTF_8.encode(<span class="hljs-string">&quot;你好\n&quot;</span>));<br>    System.in.read();<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">hello<br>world<br>你好<br></code></pre></td></tr></table></figure><h4 id="ByteBuffer-大小分配">ByteBuffer 大小分配</h4><ul><li>每个 channel 都需要记录可能被切分的消息，因为 ByteBuffer 不能被多个 channel 共同使用，否则会出现消息错乱，因此需要为每个 channel 维护一个独立的 ByteBuffer。</li><li>ByteBuffer 不能太大，比如一个 ByteBuffer 1Mb 的话，要支持百万连接就要 1Tb 内存，因此需要设计大小可变的 ByteBuffer<ul><li>一种思路是首先分配一个较小的 buffer，例如 4k，如果发现数据不够，再分配 8k 的 buffer，将 4k buffer 内容拷贝至 8k buffer，优点是消息连续容易处理，缺点是数据拷贝耗费性能。</li><li>另一种思路是用多个数组组成 buffer，一个数组不够，把多出来的内容写入新的数组，与前面的区别是消息存储不连续解析复杂，优点是避免了拷贝引起的性能损耗。</li></ul></li></ul><h3 id="4-5-处理-write-事件">4.5 处理 write 事件</h3><h4 id="一次无法写完例子">一次无法写完例子</h4><p>参照下面的代码：</p><p>服务端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">ssc</span> <span class="hljs-operator">=</span> ServerSocketChannel.open();<br>    ssc.configureBlocking(<span class="hljs-literal">false</span>);<br>    <span class="hljs-type">Selector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> Selector.open();<br>    ssc.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">8080</span>));<br>    ssc.register(selector, SelectionKey.OP_ACCEPT);<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        selector.select();<br>        Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();<br>        <span class="hljs-keyword">while</span> (iter.hasNext()) &#123;<br>            <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> iter.next();<br>            <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;<br>                <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> ssc.accept();<br>                sc.configureBlocking(<span class="hljs-literal">false</span>);<br>                sc.register(selector, SelectionKey.OP_READ);<br><br>                <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">30000000</span>; i++) &#123;<br>                    sb.append(<span class="hljs-string">&quot;a&quot;</span>);<br>                &#125;<br>                <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> Charset.defaultCharset().encode(sb.toString());<br>                <span class="hljs-keyword">while</span> (buf.hasRemaining()) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">write</span> <span class="hljs-operator">=</span> sc.write(buf);<br>                    System.out.println(write);<br>                &#125;<br>            &#125;<br>            iter.remove();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> SocketChannel.open();<br>    <span class="hljs-type">Selector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> Selector.open();<br>    sc.configureBlocking(<span class="hljs-literal">false</span>);<br>    sc.register(selector, SelectionKey.OP_CONNECT | SelectionKey.OP_READ);<br>    sc.connect(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>));<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        selector.select();<br>        Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();<br>        <span class="hljs-keyword">while</span> (iter.hasNext()) &#123;<br>            <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> iter.next();<br>            <span class="hljs-keyword">if</span> (key.isConnectable()) &#123;<br>                System.out.println(sc.finishConnect());<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isReadable()) &#123;<br>                <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>);<br>                count += sc.read(buf);<br>                buf.clear();<br>                System.out.println(count);<br>            &#125;<br>            iter.remove();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>服务端输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">3538917</span><br><span class="hljs-number">2490349</span><br><span class="hljs-number">3669988</span><br><span class="hljs-number">4194272</span><br><span class="hljs-number">0</span><br><span class="hljs-number">0</span><br><span class="hljs-number">2228207</span><br><span class="hljs-number">1966065</span><br><span class="hljs-number">0</span><br><span class="hljs-number">0</span><br><span class="hljs-number">11912202</span><br></code></pre></td></tr></table></figure><p>由于网络缓冲区有限，服务端无法一次性将这 30000000 个字节数据发给客户端，而输出结果出现 0 表示网络缓冲区满了，已经写不了了，所以又会不断地循环发送。</p><p>但这其实违背了非阻塞的初衷，我们希望的是当缓冲区满了，此时线程可以干其他的事，当可以写数据了，线程再来写，这就需要我们关注写事件了。</p><p>所以我们将代码改进如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">ssc</span> <span class="hljs-operator">=</span> ServerSocketChannel.open();<br>    ssc.configureBlocking(<span class="hljs-literal">false</span>);<br>    <span class="hljs-type">Selector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> Selector.open();<br>    ssc.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">8080</span>));<br>    ssc.register(selector, SelectionKey.OP_ACCEPT);<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        selector.select();<br>        Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();<br>        <span class="hljs-keyword">while</span> (iter.hasNext()) &#123;<br>            <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> iter.next();<br>            <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;<br>                <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> ssc.accept();<br>                sc.configureBlocking(<span class="hljs-literal">false</span>);<br>                <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">scKey</span> <span class="hljs-operator">=</span> sc.register(selector, SelectionKey.OP_READ);<br><br>                <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">30000000</span>; i++) &#123;<br>                    sb.append(<span class="hljs-string">&quot;a&quot;</span>);<br>                &#125;<br>                <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> Charset.defaultCharset().encode(sb.toString());<br>                <span class="hljs-type">int</span> <span class="hljs-variable">write</span> <span class="hljs-operator">=</span> sc.write(buf);<br>                System.out.println(<span class="hljs-string">&quot;实际写入的字节数：&quot;</span> + write);<br>                <span class="hljs-comment">// 如果有剩余字节未写完则关注写事件</span><br>                <span class="hljs-keyword">if</span> (buf.hasRemaining()) &#123;<br>                    <span class="hljs-comment">// 在原有事件的基础关注写事件</span><br>                    scKey.interestOps(scKey.interestOps() | SelectionKey.OP_WRITE);<br>                    scKey.attach(buf);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isWritable()) &#123;<br>                <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> (ByteBuffer) key.attachment();<br>                <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> (SocketChannel) key.channel();<br>                <span class="hljs-type">int</span> <span class="hljs-variable">write</span> <span class="hljs-operator">=</span> sc.write(buf);<br>                System.out.println(<span class="hljs-string">&quot;实际写入的字节数：&quot;</span> + write);<br>                <span class="hljs-comment">// 已经写完了</span><br>                <span class="hljs-keyword">if</span> (!buf.hasRemaining()) &#123;<br>                    key.interestOps(key.interestOps() - SelectionKey.OP_WRITE);<br>                    key.attach(<span class="hljs-literal">null</span>);<br>                &#125;<br>            &#125;<br>            iter.remove();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端不变。</p><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">实际写入的字节数：<span class="hljs-number">4587485</span><br>实际写入的字节数：<span class="hljs-number">2490349</span><br>实际写入的字节数：<span class="hljs-number">3669988</span><br>实际写入的字节数：<span class="hljs-number">6422479</span><br>实际写入的字节数：<span class="hljs-number">1966065</span><br>实际写入的字节数：<span class="hljs-number">2228207</span><br>实际写入的字节数：<span class="hljs-number">2097136</span><br>实际写入的字节数：<span class="hljs-number">131071</span><br>实际写入的字节数：<span class="hljs-number">1966065</span><br>实际写入的字节数：<span class="hljs-number">4325343</span><br>实际写入的字节数：<span class="hljs-number">115812</span><br></code></pre></td></tr></table></figure><p>所以，在非阻塞模式下，无法保证将 buffer 中所有数据都写入 channel，因此需要追踪 write 方法的返回值（代表实际写入字节数），并用 selector 监听所有 channel 的可写事件，每个 channel 都需要一个 key 来跟踪 buffer，但这样又会导致占用内存过多，就有两阶段策略：</p><ul><li>当消息处理器第一次写入消息时，才将 channel 注册到 selector 上</li><li>selector 检查 channel 上的可写事件，如果所有的数据写完了，就取消 channel 的注册</li><li>如果不取消，会每次可写均会触发 write 事件</li></ul><h4 id="write-为何要取消">write 为何要取消</h4><p>只要向 channel 发送数据时，socket 缓冲可写，这个事件会频繁触发，因此应当只在 socket 缓冲区写不下时再关注可写事件，数据写完之后再取消关注。</p><h3 id="4-6-多线程优化">4.6 多线程优化</h3><p>现代计算机，都是多核 CPU，所以我们在设计时需要充分压榨 CPU 的资源。</p><p>前面的代码都只有一个选择器 Selector，并没有充分利用多核 CPU，如何改进？我们可以做：分为两组选择器</p><ul><li>单线程配一个选择器，专门处理 accept 事件。</li><li>创建适当数量的线程，每个线程配一个选择器，轮流处理其他 IO 事件。</li></ul><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MultipleServer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">BossEventLoop</span>().register();<br>    &#125;<br><br>    <span class="hljs-meta">@Slf4j</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BossEventLoop</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br>        <span class="hljs-keyword">private</span> Selector boss;<br>        <span class="hljs-keyword">private</span> WorkerEventLoop[] workers;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>            <span class="hljs-keyword">if</span> (!start) &#123;<br>                <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">ssc</span> <span class="hljs-operator">=</span> ServerSocketChannel.open();<br>                ssc.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">8080</span>));<br>                ssc.configureBlocking(<span class="hljs-literal">false</span>);<br>                boss = Selector.open();<br>                ssc.register(boss, SelectionKey.OP_ACCEPT);<br>                workers = initEventLoops();<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-built_in">this</span>, <span class="hljs-string">&quot;boss&quot;</span>).start();<br>                log.debug(<span class="hljs-string">&quot;boss start...&quot;</span>);<br>                start = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> WorkerEventLoop[] initEventLoops() &#123;<br>            WorkerEventLoop[] workerEventLoops = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WorkerEventLoop</span>[<span class="hljs-number">2</span>];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; workerEventLoops.length; i++) &#123;<br>                workerEventLoops[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WorkerEventLoop</span>(i);<br>            &#125;<br>            <span class="hljs-keyword">return</span> workerEventLoops;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    boss.select();<br>                    Iterator&lt;SelectionKey&gt; iter = boss.selectedKeys().iterator();<br>                    <span class="hljs-keyword">while</span> (iter.hasNext()) &#123;<br>                        <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> iter.next();<br>                        iter.remove();<br>                        <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;<br>                            <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> ((ServerSocketChannel) key.channel()).accept();<br>                            sc.configureBlocking(<span class="hljs-literal">false</span>);<br>                            log.debug(<span class="hljs-string">&quot;&#123;&#125; connected&quot;</span>, sc.getRemoteAddress());<br>                            workers[index.getAndIncrement() % workers.length].register(sc);<br>                        &#125;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Slf4j</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WorkerEventLoop</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ConcurrentLinkedQueue&lt;Runnable&gt; tasks = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentLinkedQueue</span>&lt;&gt;();<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> index;<br>        <span class="hljs-keyword">private</span> Selector worker;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">WorkerEventLoop</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>            <span class="hljs-built_in">this</span>.index = index;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">(SocketChannel sc)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>            <span class="hljs-keyword">if</span> (!start) &#123;<br>                worker = Selector.open();<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-built_in">this</span>, <span class="hljs-string">&quot;worker-&quot;</span> + index).start();<br>                start = <span class="hljs-literal">true</span>;<br>            &#125;<br>            tasks.add(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    sc.register(worker, SelectionKey.OP_READ);<br>                    worker.selectNow();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;);<br>            worker.wakeup();<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    worker.select();<br>                    <span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> tasks.poll();<br>                    <span class="hljs-keyword">if</span> (task != <span class="hljs-literal">null</span>) &#123;<br>                        task.run();<br>                    &#125;<br>                    Set&lt;SelectionKey&gt; keys = worker.selectedKeys();<br>                    Iterator&lt;SelectionKey&gt; iter = keys.iterator();<br>                    <span class="hljs-keyword">while</span> (iter.hasNext()) &#123;<br>                        <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> iter.next();<br>                        <span class="hljs-keyword">if</span> (key.isReadable()) &#123;<br>                            <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> (SocketChannel) key.channel();<br>                            <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">128</span>);<br>                            <span class="hljs-keyword">try</span> &#123;<br>                                <span class="hljs-type">int</span> <span class="hljs-variable">read</span> <span class="hljs-operator">=</span> sc.read(buffer);<br>                                <span class="hljs-keyword">if</span> (read == -<span class="hljs-number">1</span>) &#123;<br>                                    key.cancel();<br>                                    sc.close();<br>                                &#125; <span class="hljs-keyword">else</span> &#123;<br>                                    buffer.flip();<br>                                    log.debug(<span class="hljs-string">&quot;&#123;&#125; message:&quot;</span>, sc.getRemoteAddress());<br>                                    debugAll(buffer);<br>                                &#125;<br>                            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                                e.printStackTrace();<br>                                key.cancel();<br>                                sc.close();<br>                            &#125;<br>                        &#125;<br>                        iter.remove();<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="如何拿到-CPU-个数">如何拿到 CPU 个数</h4><ul><li>Runtime.getRuntime().availableProcessors() 如果工作在 docker 容器下，因为容器不是物理隔离的，会拿到物理 CPU 个数，而不是容器申请时的个数</li><li>这个问题直到 jdk 10 才修复，使用 jvm 参数 UseContainerSupport 配置， 默认开启</li></ul><h2 id="5-Channel-之-UDP-网络编程">5. Channel 之 UDP 网络编程</h2><ul><li>UDP 是无连接的，client 发送数据不会管 server 是否开启</li><li>server 这边的 receive 方法会将接收到的数据存入 byte buffer，但如果数据报文超过 buffer 大小，多出来的数据会被抛弃</li></ul><p>示例：</p><p>服务器端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UdpServer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">DatagramChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> DatagramChannel.open()) &#123;<br>            channel.socket().bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">9999</span>));<br>            System.out.println(<span class="hljs-string">&quot;waiting...&quot;</span>);<br>            <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">32</span>);<br>            channel.receive(buffer);<br>            buffer.flip();<br>            debugAll(buffer);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UdpClient</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">DatagramChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> DatagramChannel.open()) &#123;<br>            <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> StandardCharsets.UTF_8.encode(<span class="hljs-string">&quot;hello&quot;</span>);<br>            <span class="hljs-type">InetSocketAddress</span> <span class="hljs-variable">address</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">9999</span>);<br>            channel.send(buffer, address);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>服务器端输出</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">waiting<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 68 65 6c 6c 6f                                  |hello           |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br></code></pre></td></tr></table></figure><h2 id="6-Nio-vs-Bio">6. Nio vs Bio</h2><h3 id="6-1-stream-vs-channel">6.1 stream vs channel</h3><ul><li>stream 不会自动缓冲数据，channel 会利用系统提供的发送缓冲区、接收缓冲区（更为底层）</li><li>stream 仅支持阻塞 API，channel 同时支持阻塞、非阻塞 API，网络 channel 可配合 selector 实现多路复用</li><li>二者均为全双工，即读写可以同时进行</li></ul><h3 id="6-2-IO-模型">6.2 IO 模型</h3><a href="/java/redis-75ba9f9c982a/" title="redis 中的 IO 模型">redis 中的 IO 模型</a><h3 id="6-3-零拷贝">6.3 零拷贝</h3><h4 id="传统-IO-问题">传统 IO 问题</h4><p>传统的 IO 将一个文件通过 socket 写出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">File</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;data.txt&quot;</span>);<br><span class="hljs-type">RandomAccessFile</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomAccessFile</span>(file, <span class="hljs-string">&quot;r&quot;</span>);<br><br><span class="hljs-type">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[(<span class="hljs-type">int</span>)f.length()];<br>file.read(buf);<br><br><span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> ...;<br>socket.getOutputStream().write(buf);<br></code></pre></td></tr></table></figure><p>内部工作流程是这样的：</p><p><img src="/java/javase-beb1cfdacc32/image-20240116164701069.png" alt="传统 IO"></p><ol><li>Java 本身并不具备 IO 读写能力，因此 read 方法调用后，要从 Java 程序的 <strong>用户态</strong> 切换至 <strong>内核态</strong>，去调用操作系统（Kernel）的读能力，将数据读入 <strong>内核缓冲区</strong>。这期间用户线程阻塞，操作系统使用 DMA（Direct Memory Access）来实现文件读，其间也不会使用 CPU，DMA（Direct Memory Access），无需 CPU 干预的数据拷贝。</li><li>从 <strong>内核态</strong> 切换回 <strong>用户态</strong>，将数据从 <strong>内核缓冲区</strong> 读入 <strong>用户缓冲区</strong>（即 byte[] buf），这期间 CPU 会参与拷贝，无法利用 DMA。</li><li>调用 write 方法，这时将数据从 <strong>用户缓冲区</strong>（byte[] buf）写入 <strong>socket 缓冲区</strong>，CPU 会参与拷贝。</li><li>接下来要向网卡写数据，这项能力 Java 又不具备，因此又得从 <strong>用户态</strong> 切换至 <strong>内核态</strong>，调用操作系统的写能力，使用 DMA 将 <strong>socket 缓冲区</strong> 的数据写入网卡，不会使用 CPU。</li></ol><p>可以看到中间环节较多，Java 的 IO 实际不是物理设备级别的读写，而是缓存的复制，底层的真正读写是操作系统来完成的</p><ul><li>用户态与内核态的切换发生了 3 次，这个操作比较重量级</li><li>数据拷贝了共 4 次</li></ul><h4 id="NIO-优化">NIO 优化</h4><p>通过 DirectByteBuf</p><ul><li>ByteBuffer.allocate(10)  HeapByteBuffer 使用的还是 Java 内存</li><li>ByteBuffer.allocateDirect(10)  DirectByteBuffer 使用的是操作系统内存</li></ul><p><img src="/java/javase-beb1cfdacc32/image-20240116165256948.png" alt="DBB"></p><p>大部分步骤与优化前相同，不再赘述。唯有一点：Java 可以使用 DirectByteBuf 将堆外内存映射到 jvm 内存中来直接访问使用</p><ul><li>这块内存不受 jvm 垃圾回收的影响，因此内存地址固定，有助于 IO 读写</li><li>Java 中的 DirectByteBuf 对象仅维护了此内存的虚引用，内存回收分成两步<ul><li>DirectByteBuf 对象被垃圾回收，将虚引用加入引用队列</li><li>通过专门线程访问引用队列，根据虚引用释放堆外内存</li></ul></li><li>减少了一次数据拷贝，用户态与内核态的切换次数没有减少</li></ul><p>进一步优化（底层采用了 linux 2.1 后提供的 sendFile 方法），Java 中对应着两个 channel 调用 transferTo/transferFrom 方法拷贝数据</p><p><img src="/java/javase-beb1cfdacc32/image-20240116165456610.png" alt="sendFile"></p><ol><li>Java 调用 transferTo 方法后，要从 Java 程序的 <strong>用户态</strong> 切换至 <strong>内核态</strong>，使用 DMA 将数据读入 <strong>内核缓冲区</strong>，不会使用 CPU</li><li>数据从 <strong>内核缓冲区</strong>传输到 <strong>socket 缓冲区</strong>，CPU 会参与拷贝</li><li>最后使用 DMA 将 <strong>socket 缓冲区</strong> 的数据写入网卡，不会使用 CPU</li></ol><p>可以看到</p><ul><li>只发生了一次用户态与内核态的切换</li><li>数据拷贝了 3 次</li></ul><p>进一步优化（linux 2.4）</p><p><img src="/java/javase-beb1cfdacc32/image-20240116165602285.png" alt="进一步优化"></p><ol><li>Java 调用 transferTo 方法后，要从 Java 程序的 <strong>用户态</strong> 切换至 <strong>内核态</strong>，使用 DMA 将数据读入 <strong>内核缓冲区</strong>，不会使用 CPU</li><li>只会将一些 offset 和 length 信息拷入 <strong>socket 缓冲区</strong>，几乎无消耗</li><li>使用 DMA 将 <strong>内核缓冲区</strong> 的数据写入网卡，不会使用 CPU</li></ol><p>整个过程仅只发生了一次用户态与内核态的切换，数据拷贝了 2 次。所谓的零拷贝，并不是真正无拷贝，而是在不会拷贝重复数据到 jvm 内存中，零拷贝的优点有</p><ul><li>更少的用户态与内核态的切换</li><li>不利用 CPU 计算，减少 CPU 缓存伪共享</li><li>零拷贝适合小文件传输</li></ul><h3 id="6-3-AIO">6.3 AIO</h3><p>AIO 用来解决数据复制阶段的阻塞问题</p><ul><li>同步意味着，在进行读写操作时，线程需要等待结果，还是相当于闲置</li><li>异步意味着，在进行读写操作时，线程不必等待结果，而是将来由操作系统来通过回调方式由另外的线程来获得结果</li></ul><blockquote><p>异步模型需要底层操作系统（Kernel）提供支持</p><ul><li>Windows 系统通过 IOCP 实现了真正的异步 IO</li><li>Linux 系统异步 IO 在 2.6 版本引入，但其底层实现还是用多路复用模拟了异步 IO，性能没有优势</li></ul></blockquote><h4 id="文件-AIO">文件 AIO</h4><p>先来看看 AsynchronousFileChannel</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AioDemo1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-type">AsynchronousFileChannel</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> AsynchronousFileChannel.open(Paths.get(<span class="hljs-string">&quot;1.txt&quot;</span>), StandardOpenOption.READ);<br>            <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">2</span>);<br>            log.debug(<span class="hljs-string">&quot;begin...&quot;</span>);<br>            s.read(buffer, <span class="hljs-number">0</span>, <span class="hljs-literal">null</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">CompletionHandler</span>&lt;Integer, ByteBuffer&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">completed</span><span class="hljs-params">(Integer result, ByteBuffer attachment)</span> &#123;<br>                    log.debug(<span class="hljs-string">&quot;read completed...&#123;&#125;&quot;</span>, result);<br>                    buffer.flip();<br>                    debugAll(buffer);<br>                &#125;<br><br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">failed</span><span class="hljs-params">(Throwable exc, ByteBuffer attachment)</span> &#123;<br>                    log.debug(<span class="hljs-string">&quot;read failed...&quot;</span>);<br>                &#125;<br>            &#125;);<br><br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        log.debug(<span class="hljs-string">&quot;do other things...&quot;</span>);<br>        System.in.read();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">13:44:56 [DEBUG] [main] c.i.aio.AioDemo1 - begin...<br>13:44:56 [DEBUG] [main] c.i.aio.AioDemo1 - do other things...<br>13:44:56 [DEBUG] [Thread-5] c.i.aio.AioDemo1 - read completed...2<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 61 0d                                           |a.              |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br></code></pre></td></tr></table></figure><p>可以看到</p><ul><li>响应文件读取成功的是另一个线程 Thread-5</li><li>主线程并没有 IO 操作阻塞</li></ul><h4 id="守护线程">守护线程</h4><p>默认文件 AIO 使用的线程都是守护线程，所以最后要执行 <code>System.in.read()</code> 以避免守护线程意外结束</p><h4 id="网络-AIO">网络 AIO</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AioServer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">AsynchronousServerSocketChannel</span> <span class="hljs-variable">ssc</span> <span class="hljs-operator">=</span> AsynchronousServerSocketChannel.open();<br>        ssc.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">8080</span>));<br>        ssc.accept(<span class="hljs-literal">null</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">AcceptHandler</span>(ssc));<br>        System.in.read();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">closeChannel</span><span class="hljs-params">(AsynchronousSocketChannel sc)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.printf(<span class="hljs-string">&quot;[%s] %s close\n&quot;</span>, Thread.currentThread().getName(), sc.getRemoteAddress());<br>            sc.close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReadHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">CompletionHandler</span>&lt;Integer, ByteBuffer&gt; &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AsynchronousSocketChannel sc;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">ReadHandler</span><span class="hljs-params">(AsynchronousSocketChannel sc)</span> &#123;<br>            <span class="hljs-built_in">this</span>.sc = sc;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">completed</span><span class="hljs-params">(Integer result, ByteBuffer attachment)</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (result == -<span class="hljs-number">1</span>) &#123;<br>                    closeChannel(sc);<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                System.out.printf(<span class="hljs-string">&quot;[%s] %s read\n&quot;</span>, Thread.currentThread().getName(), sc.getRemoteAddress());<br>                attachment.flip();<br>                System.out.println(Charset.defaultCharset().decode(attachment));<br>                attachment.clear();<br>                <span class="hljs-comment">// 处理完第一个 read 时，需要再次调用 read 方法来处理下一个 read 事件</span><br>                sc.read(attachment, attachment, <span class="hljs-built_in">this</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">failed</span><span class="hljs-params">(Throwable exc, ByteBuffer attachment)</span> &#123;<br>            closeChannel(sc);<br>            exc.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WriteHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">CompletionHandler</span>&lt;Integer, ByteBuffer&gt; &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AsynchronousSocketChannel sc;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-title function_">WriteHandler</span><span class="hljs-params">(AsynchronousSocketChannel sc)</span> &#123;<br>            <span class="hljs-built_in">this</span>.sc = sc;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">completed</span><span class="hljs-params">(Integer result, ByteBuffer attachment)</span> &#123;<br>            <span class="hljs-comment">// 如果作为附件的 buffer 还有内容，需要再次 write 写出剩余内容</span><br>            <span class="hljs-keyword">if</span> (attachment.hasRemaining()) &#123;<br>                sc.write(attachment);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">failed</span><span class="hljs-params">(Throwable exc, ByteBuffer attachment)</span> &#123;<br>            exc.printStackTrace();<br>            closeChannel(sc);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AcceptHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">CompletionHandler</span>&lt;AsynchronousSocketChannel, Object&gt; &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AsynchronousServerSocketChannel ssc;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">AcceptHandler</span><span class="hljs-params">(AsynchronousServerSocketChannel ssc)</span> &#123;<br>            <span class="hljs-built_in">this</span>.ssc = ssc;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">completed</span><span class="hljs-params">(AsynchronousSocketChannel sc, Object attachment)</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                System.out.printf(<span class="hljs-string">&quot;[%s] %s connected\n&quot;</span>, Thread.currentThread().getName(), sc.getRemoteAddress());<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">16</span>);<br>            <span class="hljs-comment">// 读事件由 ReadHandler 处理</span><br>            sc.read(buffer, buffer, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReadHandler</span>(sc));<br>            <span class="hljs-comment">// 写事件由 WriteHandler 处理</span><br>            sc.write(Charset.defaultCharset().encode(<span class="hljs-string">&quot;server hello!&quot;</span>), ByteBuffer.allocate(<span class="hljs-number">16</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">WriteHandler</span>(sc));<br>            <span class="hljs-comment">// 处理完第一个 accpet 时，需要再次调用 accept 方法来处理下一个 accept 事件</span><br>            ssc.accept(<span class="hljs-literal">null</span>, <span class="hljs-built_in">this</span>);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">failed</span><span class="hljs-params">(Throwable exc, Object attachment)</span> &#123;<br>            exc.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>javase</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>javase</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码随想录刷题—数组</title>
    <link href="/algorithm-8e5f2f98d9a5/"/>
    <url>/algorithm-8e5f2f98d9a5/</url>
    
    <content type="html"><![CDATA[<h1>数组</h1><h2 id="1-二分查找">1. 二分查找</h2><h3 id="1-1-二分查找">1.1 二分查找</h3><blockquote><p><a href="https://leetcode.cn/problems/binary-search/">704. 二分查找</a></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &lt;= j) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (i + j) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            j = mid - <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            i = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> mid;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 没找到返回 -1</span><br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度：</p><ul><li>时间：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>空间：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li></ul><h3 id="1-2-其他题目">1.2 其他题目</h3><h4 id="35-搜索插入位置">35. 搜索插入位置</h4><blockquote><p><a href="https://leetcode.cn/problems/search-insert-position/">35. 搜索插入位置</a></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">searchInsert</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 记录 target 的候选位置，从 0 开始逐渐增加</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">candidate</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &lt;= j) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (i + j) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            i = mid + <span class="hljs-number">1</span>;<br>            candidate = i;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            j = mid - <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> mid;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> candidate;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度：</p><ul><li>时间：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>空间：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li></ul><h4 id="34-在排序数组中查找元素的第一个和最后一个位置">34. 在排序数组中查找元素的第一个和最后一个位置</h4><blockquote><p><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] searchRange(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>    <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 结果区间左、右边界</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &lt;= j) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (i + j) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &lt;= target) &#123;<br>            <span class="hljs-comment">// 即使 nums[mid] == target，i 还要继续往后找，这样做是为了找到右边界</span><br>            i = mid + <span class="hljs-number">1</span>;<br>            right = mid;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            j = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    i = <span class="hljs-number">0</span>;<br>    j = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &lt;= j) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (i + j) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            i = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt;= target) &#123;<br>            <span class="hljs-comment">// 即使 nums[mid] == target，j 还要继续往前找，这样做是为了找到左边界</span><br>            j = mid - <span class="hljs-number">1</span>;<br>            left = mid;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 若 nums[left] 或者 nums[right] 不等于 target 说明没有这个元素，返回 &#123;-1, -1&#125;</span><br>    <span class="hljs-keyword">return</span> (nums[left] == target) ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;left, right&#125; : <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度：</p><ul><li>时间：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>空间：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li></ul><h4 id="69-x-的平方根">69. x 的平方根</h4><blockquote><p><a href="https://leetcode.cn/problems/sqrtx/">69. x 的平方根</a></p></blockquote><p>该题和 <a href="https://leetcode.cn/problems/search-insert-position/description/">35. 搜索插入位置</a> 类似。</p><p>注意：中间的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>i</mi><mi>d</mi><mo>×</mo><mi>m</mi><mi>i</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">mid \times mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">mi</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">mi</span><span class="mord mathnormal">d</span></span></span></span> 结果转化为 long 型防止溢出导致死循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">mySqrt</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = x;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">candidate</span> <span class="hljs-operator">=</span> i;<br>    <span class="hljs-keyword">while</span> (i &lt;= j) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (i + j) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 由于 mid * mid 可能超出 int 的表示范围而变为负数，导致死循环，所以强转为 long</span><br>        <span class="hljs-keyword">if</span> ((<span class="hljs-type">long</span>) mid * mid &lt;= x) &#123;<br>            candidate = mid;<br>            i = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            j = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> candidate;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度：</p><ul><li>时间：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>空间：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li></ul><h4 id="367-有效的完全平方数">367. 有效的完全平方数</h4><blockquote><p><a href="https://leetcode.cn/problems/valid-perfect-square/">367. 有效的完全平方数</a></p></blockquote><p>和 <a href="https://leetcode.cn/problems/sqrtx/description/">65. x 的平方根</a> 类似，不过更为简单，就是简单的二分查找，找到结果就返回 true，否则返回 false，注意，防止溢出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPerfectSquare</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = num;<br>    <span class="hljs-keyword">while</span> (i &lt;= j) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (i + j) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> ((<span class="hljs-type">long</span>) mid * mid &lt; num) &#123;<br>            i = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((<span class="hljs-type">long</span>) mid * mid &gt; num) &#123;<br>            j = mid - <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度：</p><ul><li>时间：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>空间：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li></ul><h2 id="2-移除元素">2. 移除元素</h2><h3 id="2-1-移除元素">2.1 移除元素</h3><blockquote><p><a href="https://leetcode.cn/problems/remove-element/">27. 移除元素</a></p></blockquote><p>使用快慢指针：</p><ul><li>快指针：寻找新数组的元素，所谓新数组就是不含有目标元素的数组</li><li>慢指针：指向新数组的最后一个元素</li></ul><p>图解：</p><p><img src="/algorithm-8e5f2f98d9a5/%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0.gif" alt="移除元素"></p><p>代码并不复杂，举个例子画个图即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> val)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; fast &lt; nums.length; fast++) &#123;<br>        <span class="hljs-keyword">if</span> (nums[fast] != val) &#123;<br>            nums[slow++] = nums[fast];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> slow;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度：</p><ul><li>时间：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>空间：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li></ul><h3 id="2-2-其他题目">2.2 其他题目</h3><h4 id="26-删除有序数组中的重复项">26. 删除有序数组中的重复项</h4><blockquote><p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">26. 删除有序数组中的重复项</a></p></blockquote><p>和 <a href="https://leetcode.cn/problems/remove-element/">27. 移除元素</a> 类似，只是需要注意一些细节的不同。比如：</p><ul><li>快指针从慢指针的下一个位置开始</li><li>快慢指针指向的元素不同时，慢指针才往后走</li><li>最后返回的是慢指针的索引加一</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeDuplicates</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-keyword">if</span> (nums.length &lt; <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">return</span> nums.length;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; fast &lt; nums.length; fast++) &#123;<br>        <span class="hljs-keyword">if</span> (nums[slow] != nums[fast]) &#123;<br>            nums[++slow] = nums[fast];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> slow + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度：</p><ul><li>时间：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>空间：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li></ul><h4 id="283-移动零">283. 移动零</h4><blockquote><p><a href="https://leetcode.cn/problems/move-zeroes/">283. 移动零</a></p></blockquote><p>还是快慢指针，举个例子理解即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">moveZeroes</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; fast &lt; nums.length; fast++) &#123;<br>        <span class="hljs-keyword">if</span> (nums[fast] != <span class="hljs-number">0</span>) &#123;<br>            nums[slow++] = nums[fast];<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 将 slow 后的所有值置为 0</span><br>    <span class="hljs-keyword">while</span> (slow != nums.length) &#123;<br>        nums[slow++] = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度：</p><ul><li>时间：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>空间：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li></ul><h4 id="844-比较含退格的字符串">844. 比较含退格的字符串</h4><blockquote><p><a href="https://leetcode.cn/problems/backspace-string-compare/">844. 比较含退格的字符串</a></p></blockquote><p>大体的思路是将两个输入的 s 串和 t 串都去掉 # 号，形成最后的字符串，最后通过比较这两个最后的字符串即可。</p><p>那么形成最后的字符串的方法就是使用双指针。</p><p>具体的一个最后的字符串构建过程，图解：</p><p><img src="/algorithm-8e5f2f98d9a5/%E5%90%AB%E9%80%80%E6%A0%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2.gif" alt="含退格的字符串"></p><p>此时只需要截取 0 到 i - 1 的子串即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">backspaceCompare</span><span class="hljs-params">(String s, String t)</span> &#123;<br>    <span class="hljs-keyword">return</span> build(s).equals(build(t));<br>&#125;<br><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">build</span><span class="hljs-params">(String s)</span> &#123;<br>    <span class="hljs-type">char</span>[] arr = s.toCharArray();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (j &lt; arr.length) &#123;<br>        <span class="hljs-keyword">if</span> (arr[j] == <span class="hljs-string">&#x27;#&#x27;</span>) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) &#123;<br>                i--;<br>            &#125;<br>            j++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            arr[i++] = arr[j++];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(arr).substring(<span class="hljs-number">0</span>, i);<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度：</p><ul><li>时间：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n+m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>，遍历 s 串和 t 串各一遍</li><li>空间：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li></ul><h4 id="977-有序数组的平方">977. 有序数组的平方</h4><blockquote><p><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">977. 有序数组的平方</a></p></blockquote><p>使用对撞指针，也就是左、右指针</p><ul><li>分别从数组的左右两侧开始，向中间汇合</li><li>比较左、右指针元素的平方的大小，将较大的放在结果数组的 index 索引处</li><li>由于原数组是非降序排列的，所以结果数组一定要从后往前生成元素</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] sortedSquares(<span class="hljs-type">int</span>[] nums) &#123;<br>    <span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 操作结果数组的索引</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">val1</span> <span class="hljs-operator">=</span> nums[left] * nums[left];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">val2</span> <span class="hljs-operator">=</span> nums[right] * nums[right];<br>        <span class="hljs-keyword">if</span> (val1 &gt;= val2) &#123;<br>            left++;<br>            ans[index--] = val1;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            right--;<br>            ans[index--] = val2;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度：</p><ul><li>时间：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>空间：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li></ul><h2 id="3-长度最小的子数组">3. 长度最小的子数组</h2><h3 id="3-1-长度最小的子数组">3.1 长度最小的子数组</h3><blockquote><p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209. 长度最小的子数组</a></p></blockquote><p>解决方法是使用滑动窗口，其中</p><ul><li>winL 表示滑动窗口左边界</li><li>winR 表示滑动窗口右边界（当然是闭区间）</li></ul><p>图解：</p><p><img src="/algorithm-8e5f2f98d9a5/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.gif" alt="滑动窗口"></p><p>注意，代码中使用了 sum 变量来记录区间的和，在 winR++ 前，sum 需要加 num[winR]，而在 winL++ 前，sum 需要减 nums[winL]。</p><p>当然，也可以使用前缀数组，当然这会导致额外的空间复杂度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target, <span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-comment">// 记录结果，也就是满足条件的最小的区间的元素个数</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>    <span class="hljs-comment">// sum 变量记录区间 [winL, winR] 的和</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, winL = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// winL 和 winR 表示滑动窗口的左右边界</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">winR</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; winR &lt; nums.length; winR++) &#123;<br>        sum += nums[winR];<br>        <span class="hljs-keyword">while</span> (sum &gt;= target) &#123;<br>            ans = Math.min(ans, winR - winL + <span class="hljs-number">1</span>);<br>            sum -= nums[winL++];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans == Integer.MAX_VALUE ? <span class="hljs-number">0</span> : ans;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度：</p><ul><li>时间：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>空间：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li></ul><h3 id="3-2-其他题目">3.2 其他题目</h3><h4 id="904-水果成篮">904. 水果成篮</h4><blockquote><p><a href="https://leetcode.cn/problems/fruit-into-baskets/">904. 水果成篮</a></p></blockquote><p>还是使用滑动窗口，具体举个例子就能明白。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">totalFruit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] fruits)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">winL</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// kind 表示：滑动窗口内的数 =&gt; 该数出现的次数</span><br>    HashMap&lt;Integer, Integer&gt; kind = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">winR</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; winR &lt; fruits.length; winR++) &#123;<br>        kind.put(fruits[winR], kind.getOrDefault(fruits[winR], <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">while</span> (kind.size() &gt; <span class="hljs-number">2</span>) &#123;<br>            kind.put(fruits[winL], kind.get(fruits[winL]) - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (kind.get(fruits[winL]) == <span class="hljs-number">0</span>) &#123;<br>                kind.remove(fruits[winL]);<br>            &#125;<br>            winL++;<br>        &#125;<br>        ans = Math.max(ans, winR - winL + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度：</p><ul><li>时间：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>空间：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，由于 HashMap 内最多只存放 3 个键值对，所以为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li></ul><h4 id="76-最小覆盖子串">76. 最小覆盖子串</h4><blockquote><p><a href="https://leetcode.cn/problems/minimum-window-substring/">76. 最小覆盖子串</a></p></blockquote><p>本题还是使用滑动窗口，下面是图解：</p><p><img src="/algorithm-8e5f2f98d9a5/%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2.gif" alt="最小覆盖子串"></p><p>通过图解可以看出，该题目就是一道典型的滑动窗口题目，但是一个重点在于如何高效的判断窗口内是否包含 t 串。</p><p>我们使用一个哈希表 fre_t 首先记录 t 串的词频，然后在窗口滑动的过程中，使用另一个哈希表 fre_s 动图维护窗口的字符及出现的次数，若 fre_s 中的所有字符都存在于 fre_t 中，且所有字符的个数都不小于 fre_t 中对应字符的个数，那么我们就说窗口内包含该 t 串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">minWindow</span><span class="hljs-params">(String s, String t)</span> &#123;<br>    <span class="hljs-comment">// start 表示最小覆盖子串的起始位置，len 表示最小覆盖子串的长度</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>    <span class="hljs-comment">// 对 t 串进行词频统计</span><br>    HashMap&lt;Character, Integer&gt; fre_t = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; t.length(); i++) &#123;<br>        fre_t.put(t.charAt(i), fre_t.getOrDefault(t.charAt(i), <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">// 对 s 串进行滑动窗口算法</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">winL</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    HashMap&lt;Character, Integer&gt; fre_s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">winR</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; winR &lt; s.length(); winR++) &#123;<br>        fre_s.put(s.charAt(winR), fre_s.getOrDefault(s.charAt(winR), <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">while</span> (check(fre_s, fre_t)) &#123;<br>            <span class="hljs-keyword">if</span> (len &gt; winR - winL + <span class="hljs-number">1</span>) &#123;<br>                len = winR - winL + <span class="hljs-number">1</span>;<br>                start = winL;<br>            &#125;<br>            fre_s.put(s.charAt(winL), fre_s.get(s.charAt(winL)) - <span class="hljs-number">1</span>);<br>            winL++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> (len != Integer.MAX_VALUE) ? s.substring(start, start + len) : <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(HashMap&lt;Character, Integer&gt; s, HashMap&lt;Character, Integer&gt; t)</span> &#123;<br>    <span class="hljs-keyword">for</span> (Map.Entry&lt;Character, Integer&gt; e : t.entrySet()) &#123;<br>        <span class="hljs-keyword">if</span> (!s.containsKey(e.getKey()) || s.get(e.getKey()) &lt; t.get(e.getKey())) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度：</p><ul><li>时间：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m+n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，最坏情况下，需要遍历两次 s 串和一次 t 串，每次 check 时都需要遍历 t 串的词频哈希表，该大小为英文字母的字符集大小，为常数，可以忽略。</li><li>空间：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，由于 s 串和 t 串全为英文字母，为常数，所以为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li></ul><h2 id="4-螺旋矩阵">4. 螺旋矩阵</h2><h3 id="4-1-螺旋矩阵">4.1 螺旋矩阵</h3><blockquote><p><a href="https://leetcode.cn/problems/spiral-matrix/">54. 螺旋矩阵</a></p></blockquote><p>一种宏观调度：将最外层的矩形圈遍历完后再遍历里面的矩形圈，一层一层的遍历。</p><p>图示：</p><p><img src="/algorithm-8e5f2f98d9a5/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5.gif" alt="螺旋矩阵"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">spiralOrder</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>    List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, m = matrix.length - <span class="hljs-number">1</span>, n = matrix[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &lt;= m &amp;&amp; j &lt;= n) &#123;<br>        helper(ans, matrix, i++, j++, m--, n--);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(List&lt;Integer&gt; ans, <span class="hljs-type">int</span>[][] matrix, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">if</span> (i == m) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> j; t &lt;= n; t++) &#123;<br>            ans.add(matrix[i][t]);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j == n) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> i; t &lt;= m; t++) &#123;<br>            ans.add(matrix[t][j]);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ci</span> <span class="hljs-operator">=</span> i;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cj</span> <span class="hljs-operator">=</span> j;<br>        <span class="hljs-comment">// 右移</span><br>        <span class="hljs-keyword">while</span> (cj != n) &#123;<br>            ans.add(matrix[i][cj++]);<br>        &#125;<br>        <span class="hljs-comment">// 下移</span><br>        <span class="hljs-keyword">while</span> (ci != m) &#123;<br>            ans.add(matrix[ci++][cj]);<br>        &#125;<br>        <span class="hljs-comment">// 左移</span><br>        <span class="hljs-keyword">while</span> (cj != j) &#123;<br>            ans.add(matrix[m][cj--]);<br>        &#125;<br>        <span class="hljs-comment">// 上移</span><br>        <span class="hljs-keyword">while</span> (ci != i) &#123;<br>            ans.add(matrix[ci--][cj]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度：</p><ul><li>时间：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m \times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>空间：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，不考虑结果集合</li></ul><h3 id="4-2-其他题目">4.2 其他题目</h3><h4 id="59-螺旋矩阵-II">59. 螺旋矩阵 II</h4><blockquote><p><a href="https://leetcode.cn/problems/spiral-matrix-ii/">59. 螺旋矩阵 II</a></p></blockquote><p>和 <a href="https://leetcode.cn/problems/spiral-matrix/">54. 螺旋矩阵</a> 类似，只是需要一个全局累加器 adder 来填充结果矩阵。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] generateMatrix(<span class="hljs-type">int</span> k) &#123;<br>    <span class="hljs-type">int</span>[][] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k][k];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">adder</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, m = k - <span class="hljs-number">1</span>, n = k - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &lt;= m &amp;&amp; j &lt;= n) &#123;<br>        adder = helper(adder, ans, i++, j++, m--, n--);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(<span class="hljs-type">int</span> adder, <span class="hljs-type">int</span>[][] ans, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">if</span> (i == m) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> j; t &lt;= n; t++) &#123;<br>            ans[i][t] = adder++;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j == n) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> i; t &lt;= m; t++) &#123;<br>            ans[t][j] = adder++;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ci</span> <span class="hljs-operator">=</span> i;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cj</span> <span class="hljs-operator">=</span> j;<br>        <span class="hljs-comment">// 右移</span><br>        <span class="hljs-keyword">while</span> (cj != n) &#123;<br>            ans[i][cj++] = adder++;<br>        &#125;<br>        <span class="hljs-comment">// 下移</span><br>        <span class="hljs-keyword">while</span> (ci != m) &#123;<br>            ans[ci++][cj] = adder++;<br>        &#125;<br>        <span class="hljs-comment">// 左移</span><br>        <span class="hljs-keyword">while</span> (cj != j) &#123;<br>            ans[m][cj--] = adder++;<br>        &#125;<br>        <span class="hljs-comment">// 上移</span><br>        <span class="hljs-keyword">while</span> (ci != i) &#123;<br>            ans[ci--][cj] = adder++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> adder;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度：</p><ul><li>时间：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m \times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>空间：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，不考虑结果数组</li></ul><h2 id="5-总结">5. 总结</h2><p>前面这些题，代表了 4 种不同类型的数组相关的题目。</p><p>第一种是二分查找，必须掌握二分查找的基本版本，以及以二分查找为基础的衍生题目。</p><p>第二种是双指针，在数组、链表等线性结构中，双指针是一个很常用的解题方法，细分来说，还有快慢指针、对撞指针以及分离指针。</p><p>第三种是滑动窗口，一般思路就是在某种条件下，窗口右边界不断右滑，而当满足另一个条件后，窗口左边界不断右滑，这样左、右边界分别在不同的情况下右滑，就能在遍历两次数组的情况下，以时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 的情况下，优化题解。</p><p>最后一种是对二维矩阵相关的模拟问题，需要你站在宏观的角度来考虑问题，不过更多的是考察编码的能力，重点就在于一个模拟。</p>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
      <tag>array</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>跳表</title>
    <link href="/algorithm-efec1a8327be/"/>
    <url>/algorithm-efec1a8327be/</url>
    
    <content type="html"><![CDATA[<h1>跳表</h1><h2 id="概述">概述</h2><p>跳表（Skip List）是一种数据结构，用于在 <strong>有序元素</strong> 的集合中进行 <strong>快速查找、插入和删除操作</strong>。跳表的设计灵感源自平衡树，但相比之下，跳表的实现相对简单，在某些情况下可以在时间复杂度上达到与平衡树类似的性能。</p><p>跳表的核心思想是 <strong>通过在多个层上引入 “跳跃” 操作来加速查找</strong>。每个元素在最底层上都存在，而更高层的节点则通过跳跃链接连接到底层节点，形成类似于塔状的结构。这些跳跃链接允许在查找时跳过一些节点，从而减少查找的时间。</p><p>基本跳表的性质如下：</p><ol><li>每个元素都包含在底层（第 0 层）。</li><li>每一层的元素是从底层元素按照 <strong>某种概率随机提升</strong> 的结果，通常是按照一定的规则或概率选择提升。</li><li>最低层包含所有元素。</li><li>跳表的每一层都是一个有序链表，且相邻元素在不同层次之间具有跳跃链接。</li></ol><p>跳表的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，在某些情况下可以在查找操作上与平衡树（如红黑树）媲美。虽然跳表的实现相对简单，但它需要维护合适的平衡，以确保性能。跳表在高性能的数据结构中被广泛应用，特别是在需要高效查找的情况下。</p><h2 id="基本思想">基本思想</h2><p>跳表是一种类似于链表的数据结构，更加准确的说，跳表是对有序链表的改进。为方便讨论，后续所有有序链表默认为 <strong>升序</strong> 排序。</p><p>一个有序链表的查找操作，从头部开始逐个比较，直到当前节点的值大于或等于目标节点的值。很明显，这个操作的复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</p><p>跳表在有序链表的基础上，引入了 <strong>分层</strong> 的概念。</p><p>首先，跳表的每一层都是一个有序链表，特别地，最底层是完全的有序链表。每个位于第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 层的节点有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span> 的概率出现在第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7429em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 层，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span> 为常数。</p><p>在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个节点的跳表中，包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mi>p</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{p}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3262em;vertical-align:-0.4811em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4811em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 个元素的层为第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 层，易得 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mfrac><mn>1</mn><mi>p</mi></mfrac></msub><mi>n</mi></mrow><annotation encoding="application/x-tex">L(n)=log_{\frac{1}{p}}n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2787em;vertical-align:-0.5842em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.7538em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span style="top:-3.2255em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4829em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5842em;"><span></span></span></span></span></span></span><span class="mord mathnormal">n</span></span></span></span>。</p><p>在跳表中查找，就是从第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 层开始，水平地逐个比较直至当前节点的下一个节点大于等于目标节点，然后移动至下一层。重复这个过程直至到达第一层且无法继续进行操作。此时，若下一个节点是目标节点，则成功查找，反之，则元素不存在。这样一来，查找的过程中会跳过一些没有必要的比较，所以相比于有序链表的查询，跳表的查询更快。可以证明，跳表查询的平均复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</p><h2 id="简单理解">简单理解</h2><p>总的来说，跳表是 <strong>可以实现二分查找的有序链表</strong>。</p><p>下图是一个简单的 <strong>有序单链表</strong>，单链表的特性就是每个元素存放下一个元素的引用。即通过第一个元素可以找到第二个元素，通过第二个元素可以找到第三个元素，依次类推，直到找到最后一个元素。</p><p><img src="/algorithm-efec1a8327be/image-20240116222915643.png" alt="普通链表"></p><p>假设要找上图链表中的 10，只能从头开始遍历链表，直到找到 10。查找路径：1、3、4、5、7、8、9、10。</p><p>查找效率较低，平均时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。如何提高链表的查找速度？如下图所示，从链表中每两个元素抽出来，加一级索引，一级索引指向了原始链表，即通过一级索引 7 的 down 指针可以找到原始链表的 7。那现在怎么查找 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>10</mn></mrow><annotation encoding="application/x-tex">10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">10</span></span></span></span> 这个元素呢？</p><p><img src="/algorithm-efec1a8327be/image-20240116223304203.png" alt="一级索引"></p><p>先在第一级索引找 1、4、7、9，遍历到一级索引的 9 时，发现 9 的后继节点是 13，比 10 大，停止向后，通过 9 找到原始链表的 9，然后再往后遍历找到了要找的 10，遍历结束。加了一级索引后，查找路径：1、4、7、9、10，查找节点需要遍历的元素相对少了，不需要对 10 之前的所有数据都遍历，查找的效率提升了。</p><p>那如果加二级索引呢？如下图所示，查找路径：1、7、9、10。这就是跳表的思想，用 “空间换时间”，通过给链表建立索引，提高了查找的效率。</p><p><img src="/algorithm-efec1a8327be/image-20240116223516241.png" alt="二级索引"></p><p>从上面例子来看，提升的效率并不明显，本来需要遍历 8 个元素，优化了半天，还需要遍历 4 个元素，这是因为数据量太少了，当数据量足够大时，效率提升会很大。</p><p>如下图所示，假如有序单链表现在有 10000 个元素，分别是 0 ~ 9999。建了很多级索引，最高级的索引，就两个元素 0、5000，次高级索引四个元素 0、2500、5000、7500，依次类推，当查找 7890 这个元素时，查找路径为 0、5000、7500、…、7890，通过最高级索引直接跳过了 5000 个元素，次高层索引直接跳过了 2500 个元素，<strong>从而使得链表能够实现二分查找</strong>。由此可以看出，当元素数量较多时，索引提高的效率比较大，近似于二分查找。</p><p><img src="/algorithm-efec1a8327be/image-20240116224724285.png" alt="元素较多"></p><h2 id="复杂度分析">复杂度分析</h2><h3 id="时间复杂度">时间复杂度</h3><p>查找元素的过程是从最高层开始，一层一层遍历最后下沉到原始链表。所以，时间复杂度 = 跳表的高度 × 每一层遍历元素的个数。</p><p>假设每两个节点会抽出一个节点作为更上一层的节点。</p><p>原始的链表有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个元素，则一级索引有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">n/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord">/2</span></span></span></span> 个元素、二级索引有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mn>4</mn></mrow><annotation encoding="application/x-tex">n/4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord">/4</span></span></span></span> 个元素、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 级索引就有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi mathvariant="normal">/</mi><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">n/2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0991em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord">/</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span> 个元素。最高级索引一般有 2 个元素，即最高级索引 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span></span></span></span> 满足 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>=</mo><mi>n</mi><mi mathvariant="normal">/</mi><msup><mn>2</mn><mi>h</mi></msup></mrow><annotation encoding="application/x-tex">2 = n/2^h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0991em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord">/</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span></span></span></span></span></span></span></span>，即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo>=</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">h = log_2n - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，最高级索引 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span></span></span></span> 为索引层的高度加上原始数据一层，跳表的总高度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo>=</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi></mrow><annotation encoding="application/x-tex">h = log_2n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">n</span></span></span></span>。</p><p>若每两个节点抽出一个节点作为更上一层的节点时，每一层最多遍历 3 个节点（自行证明），所以时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><h3 id="空间复杂度">空间复杂度</h3><p>跳表通过建立索引，来提高查找元素的效率，典型的&quot;空间换时间&quot;的思想，所以在空间上做了一些牺牲。</p><p>假如原始链表包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个元素</p><p>如果每两个节点抽一个节点作为索引，则一级索引元素个数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">n/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord">/2</span></span></span></span>、二级索引元素个数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mn>4</mn></mrow><annotation encoding="application/x-tex">n/4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord">/4</span></span></span></span>、三级索引元素个数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mn>8</mn></mrow><annotation encoding="application/x-tex">n/8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord">/8</span></span></span></span> 以此类推。所以，索引节点的总和是：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>+</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>4</mn><mo>+</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>8</mn><mo>+</mo><mo>…</mo><mo>+</mo><mn>8</mn><mo>+</mo><mn>4</mn><mo>+</mo><mn>2</mn><mo>=</mo><mi>n</mi><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">n/2 + n/4 + n/8 + … + 8 + 4 + 2 = n-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord">/2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord">/4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord">/8</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span>，<strong>空间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></strong>。</p><p>如果每三个节点抽一个节点做为索引，索引总和数就是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mn>3</mn><mo>+</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>9</mn><mo>+</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>27</mn><mo>+</mo><mo>…</mo><mo>+</mo><mn>9</mn><mo>+</mo><mn>3</mn><mo>+</mo><mn>1</mn><mo>=</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">n/3 + n/9 + n/27 + … + 9 + 3 + 1= n/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord">/3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord">/9</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord">/27</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">9</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord">/2</span></span></span></span>，减少了一半。所以可以通过较少索引数来减少空间复杂度，但是相应的肯定会造成查找效率有一定下降，实际根据应用场景来控制这个阈值。</p><p>但是索引节点往往只需要存储 key 和几个指针，并不需要存储完整的对象，所以当对象比索引节点大很多时，索引占用的额外空间就可以忽略了。</p><p>举个例子：现在需要用跳表来给所有学生建索引，学生有很多属性：学号、姓名、性别、身份证号、年龄、家庭住址、身高、体重等。学生的各种属性只需要在原始链表中存储一份即可，只需要用学生的学号（<code>int</code> 类型的数据）建立索引，所以索引相对原始数据而言，占用的空间可以忽略。</p><h2 id="过程">过程</h2><h3 id="节点定义">节点定义</h3><p>下面是跳表节点的定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SkipNode</span> &#123;<br>    <span class="hljs-comment">// 节点的值</span><br>    <span class="hljs-type">int</span> value;<br>    <span class="hljs-comment">// 该节点的所有 next 指针</span><br>    SkipNode[] next;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SkipNode</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-built_in">this</span>.value = value;<br>        next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SkipNode</span>[MAX_LEVEL];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>下图中，每个圈出来的是一个节点，紫色的节点是 head 节点，每个节点维护一个 next 数组，next[level] 表示第 level 层的下一个节点，图中省略 next 中为 null 的指向。原始链表的 level 为 0。</p><p><img src="/algorithm-efec1a8327be/image-20240116225525481.png" alt="跳表"></p><h3 id="比-value-小的最右节点">比 value 小的最右节点</h3><blockquote><p>在【查找】、【新增】、【删除】方法中都会使用到该方法</p></blockquote><p>在整个跳表中查找比 value 小的最右边的节点，如下图，假设需要查找 value = 10，则比 value 小的最右边的节点就是 9。</p><p>其查找规则如下：</p><ul><li>若 next 指针为 null，或者 next 指向的节点值 nextVal ≥ value，则向下找</li><li>若 next 指针不为 null，且 next 指向的节点值 nextVal ＜ value，则向右找</li></ul><p>在这个过程中，使用一个 path 数组记录查找的过程并返回，以便后续进行【新增】和【删除】时更方便的插入节点。</p><p><img src="/algorithm-efec1a8327be/image-20240116225741911.png" alt="比 value 小的最右节点"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> SkipNode[] findLessSkipNode(<span class="hljs-type">int</span> value) &#123;<br>    <span class="hljs-comment">// 记录查找的路径, 方便后续进行新增和删除</span><br>    SkipNode[] path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SkipNode</span>[MAX_LEVEL];<br>    <span class="hljs-type">SkipNode</span> <span class="hljs-variable">curr</span> <span class="hljs-operator">=</span> head;<br>    <span class="hljs-comment">// 逐层往下</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">level</span> <span class="hljs-operator">=</span> MAX_LEVEL - <span class="hljs-number">1</span>; level &gt;= <span class="hljs-number">0</span>; level--) &#123;<br>        <span class="hljs-keyword">while</span> (curr.next[level] != <span class="hljs-literal">null</span> &amp;&amp; curr.next[level].value &lt; value) &#123;<br>            curr = curr.next[level];<br>        &#125;<br>        <span class="hljs-comment">// 记录路径</span><br>        path[level] = curr;<br>    &#125;<br>    <span class="hljs-keyword">return</span> path;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="查找">查找</h3><p>首先找到【比 value 小的最右节点】，即 path 路径数组的第一个元素（level = 0），该节点的下一个节点要么就是 value 节点，要么值大于 value 则没有 value 节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>    SkipNode[] path = findLessSkipNode(value);<br>    <span class="hljs-type">SkipNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> path[<span class="hljs-number">0</span>].next[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">return</span> node != <span class="hljs-literal">null</span> &amp;&amp; node.value == value;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="新增">新增</h3><p>跳表的原始链表需要保持有序，所以我们会向查找元素一样，找到元素应该插入的位置。</p><p>如下图所示，要插入数据 6，整个过程类似于查找 6，整个的查找路径为 1、4、5。查找到最底层原始链表的元素 5 时，发现 5 小于 6 但是后继节点 7 大于 6，所以应该把 6 插入到 5 之后 7 之前。</p><p><img src="/algorithm-efec1a8327be/image-20240116230003745.png" alt="插入 6"></p><p>但是，只将 6 插入到最底层就可以了吗？</p><p>假如一直向原始链表中插入数据，但是不更新上层的数据，那么在某一层中，会出现两个节点之间的数据非常多的情况，在极端情况下，跳表退化为单链表，查找效率变为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，所以需要维护上层的索引。</p><p>如何维护？</p><p>假如跳表每一层的晋升概率是 1/2，最理想的情况就是在原始链表中每隔一个元素抽取一个元素作为一级索引，也就是，在 <strong>原始链表中随机选择 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">n/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord">/2</span></span></span></span> 个元素作为一级索引，在一级索引中随机选择 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mn>4</mn></mrow><annotation encoding="application/x-tex">n/4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord">/4</span></span></span></span> 个元素作为二级索引 …</strong>。</p><p>虽然这样做是随机抽取的元素，不能达到每隔一个元素抽取一个元素的理想情况，极端情况，一级索引为原始链表的前一半元素，但是这样的概率太小，在原始链表中 <strong>元素数量足够多</strong> 且 <strong>抽取足够随机</strong> 的话，我们可以认为得到的索引是均匀的。</p><p>所以，可以维护一个这样的索引：<strong>随机选 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">n/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord">/2</span></span></span></span> 个元素做为一级索引、随机选 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mn>4</mn></mrow><annotation encoding="application/x-tex">n/4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord">/4</span></span></span></span> 个元素做为二级索引、随机选 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mn>8</mn></mrow><annotation encoding="application/x-tex">n/8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord">/8</span></span></span></span> 个元素做为三级索引，依次类推，一直到最顶层索引</strong>。这里每层索引的元素个数已经确定，且每层索引元素选取的足够随机，所以可以通过索引来提升跳表的查找效率。</p><p>如何实现？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">randomLevel</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">level</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// MAX_LEVEL 表示该跳表的最高层数</span><br>    <span class="hljs-comment">// SKIP_LIST 表示晋升概率</span><br>    <span class="hljs-keyword">while</span> (Math.random() &lt; SKIP_LIST &amp;&amp; level &lt; MAX_LEVEL) &#123;<br>        level++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> level;<br>&#125;<br></code></pre></td></tr></table></figure><p>晋升概率 <code>SKIP_LIST</code> 设置为 1/2，则每两个元素抽出一个元素作为上一级索引的节点。如果想节省空间利用率，可以适当的降低代码中的 <code>SKIP_LIST</code>，从而减少索引元素个数。</p><p>新增数据时维护索引的时间复杂度是多少呢？<strong>元素插入到单链表的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></strong>，索引的高度最多为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">logn</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span></span></span></span>，当插入一个元素 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 时，最坏的情况就是元素 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 需要插入到每层索引中，所以插入数据到各层索引中，最坏时间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</p><p>假设插入 6 时，它能晋升到二级索引，那么最终的跳表如图：</p><p><img src="/algorithm-efec1a8327be/image-20240116230141837.png" alt="最终结果"></p><p>所以，整个新增过程：</p><ol><li>首先随机一个节点所能晋升到的最高层数 level</li><li>从 0 到 level 依次创建节点，此时 path 数组发挥重要作用</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>    SkipNode[] path = findLessSkipNode(value);<br>    <span class="hljs-type">SkipNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SkipNode</span>(value);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">level</span> <span class="hljs-operator">=</span> randomLevel();<br>    <span class="hljs-comment">// 修改路径节点的 next 指针以及新增节点的 next 指针</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; level; i++) &#123;<br>        node.next[i] = path[i].next[i];<br>        path[i].next[i] = node;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="删除">删除</h3><p>跳表删除数据时，要把每一层中对应节点也要删掉。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">erase</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>    SkipNode[] path = findLessSkipNode(value);<br>    <span class="hljs-type">SkipNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> path[<span class="hljs-number">0</span>].next[<span class="hljs-number">0</span>];<br>    <span class="hljs-comment">// 没有找到 value 节点</span><br>    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span> || node.value != value) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; MAX_LEVEL; i++) &#123;<br>        <span class="hljs-keyword">if</span> (path[i].next[i] != node) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        path[i].next[i] = node.next[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>跳表中，删除元素的时间复杂度是多少呢？</p><p>删除元素的过程跟查找元素的过程类似，只不过在查找的路径上如果发现了要删除的元素 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>，则执行删除操作。跳表中，每一层其实都是一个有序的单链表，单链表删除元素的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，层数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">logn</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span></span></span></span> 则最多需要删除 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">logn</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span></span></span></span> 个元素，所以删除元素的总时间包含 <em>查找元素的时间</em> + <em>删除 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">logn</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span></span></span></span> 个元素的时间</em> 为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo><mo>+</mo><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn) + O(logn) = 2 O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，所以，时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</p><h2 id="模板代码">模板代码</h2>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-dc73f5fd" role="button" aria-expanded="false" aria-controls="collapse-dc73f5fd">        <div class="fold-arrow">▶</div>模板代码      </div>      <div class="fold-collapse collapse" id="collapse-dc73f5fd">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SkipList</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> <span class="hljs-variable">SKIP_LIST</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.5f</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_LEVEL</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">SkipNode</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SkipNode</span>(-<span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SkipNode</span> &#123;<br>        <span class="hljs-type">int</span> value;<br>        SkipNode[] next;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">SkipNode</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>            <span class="hljs-built_in">this</span>.value = value;<br>            next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SkipNode</span>[MAX_LEVEL];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> SkipNode[] findLessSkipNode(<span class="hljs-type">int</span> value) &#123;<br>        SkipNode[] path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SkipNode</span>[MAX_LEVEL];<br>        <span class="hljs-type">SkipNode</span> <span class="hljs-variable">curr</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">level</span> <span class="hljs-operator">=</span> MAX_LEVEL - <span class="hljs-number">1</span>; level &gt;= <span class="hljs-number">0</span>; level--) &#123;<br>            <span class="hljs-keyword">while</span> (curr.next[level] != <span class="hljs-literal">null</span> &amp;&amp; curr.next[level].value &lt; value) &#123;<br>                curr = curr.next[level];<br>            &#125;<br>            path[level] = curr;<br>        &#125;<br>        <span class="hljs-keyword">return</span> path;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        SkipNode[] path = findLessSkipNode(value);<br>        <span class="hljs-type">SkipNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> path[<span class="hljs-number">0</span>].next[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">return</span> node != <span class="hljs-literal">null</span> &amp;&amp; node.value == value;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        SkipNode[] path = findLessSkipNode(value);<br>        <span class="hljs-type">SkipNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SkipNode</span>(value);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">level</span> <span class="hljs-operator">=</span> randomLevel();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; level; i++) &#123;<br>            node.next[i] = path[i].next[i];<br>            path[i].next[i] = node;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">erase</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        SkipNode[] path = findLessSkipNode(value);<br>        <span class="hljs-type">SkipNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> path[<span class="hljs-number">0</span>].next[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span> || node.value != value) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; MAX_LEVEL; i++) &#123;<br>            <span class="hljs-keyword">if</span> (path[i].next[i] != node) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            path[i].next[i] = node.next[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">randomLevel</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">level</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (Math.random() &lt; SKIP_LIST &amp;&amp; level &lt; MAX_LEVEL) &#123;<br>            level++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> level;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>哈希表</title>
    <link href="/algorithm-53bff467bc4b/"/>
    <url>/algorithm-53bff467bc4b/</url>
    
    <content type="html"><![CDATA[<h1>HashTable</h1><h2 id="简介">简介</h2><p><strong>哈希表（Hash Table）</strong>：也叫散列表。是根据关键码值（Key）直接进行访问的数据结构。</p><p>哈希表通过键 key 和映射函数 Hash(key) 计算出对应的值 value，把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做哈希函数（散列函数），存放记录的数组叫做哈希表（散列表）。</p><p>哈希表的关键思想是使用哈希函数，将键 key 映射到对应表的某个区块中。将算法思想分为两个部分：</p><ul><li><strong>向哈希表中插入一个关键码值</strong>：哈希函数决定该关键字的对应值应该存放到表中的哪个区块，并将对应值存放到该区块中。</li><li><strong>在哈希表中搜索一个关键码值</strong>：使用相同的哈希函数从哈希表中查找对应的区块，并在特定的区块搜索该关键字对应的值。</li></ul><h2 id="哈希函数">哈希函数</h2><h3 id="简介-2">简介</h3><p>哈希（Hash）是指通过 <strong>哈希函数</strong> 将 <strong>输入数据</strong> 映射为 <strong>固定长度的输出</strong>，通常是一串 <strong>数字</strong> 和 <strong>字母</strong> 的组合。这个输出被称为哈希值，哈希值的长度是固定的，不受输入数据大小的影响。</p><p>哈希函数是一个算法，它将输入数据（例如文件、文本、密码等）转换为一个固定大小的字符串，通常是一段数字和字母的混合。哈希函数的设计要求尽可能地满足以下几个特点：</p><ol><li><strong>输入输出域</strong>：输入域可以认为是无穷的，而输出域相对有限（也可是无穷的）</li><li><strong>确定性</strong>：对于相同的输入，哈希函数总是产生 <strong>相同的哈希值</strong>。</li><li><strong>固定长度输出</strong>：哈希函数的输出长度是固定的，不管输入数据的大小如何。</li><li><strong>快速计算</strong>：哈希函数应该在合理的时间内计算出哈希值。</li><li><strong>预映射域均匀分布</strong>：优秀的哈希函数应该能够将输入数据在哈希值空间中 <strong>均匀分布</strong>，以减少 <strong>哈希碰撞</strong> 的可能性。哈希碰撞：在一个哈希函数中，不同输入映射到相同哈希值（输出）</li><li><strong>不可逆性</strong>：从哈希值无法轻易地推导出原始输入数据。好的哈希函数应该是单向的，即难以从哈希值还原出原始数据。</li><li><strong>抗碰撞性</strong>：哈希函数应该避免不同的输入映射到相同的哈希值，尽管无法完全避免碰撞，但优秀的哈希函数应该在实际应用中降低碰撞的可能性。</li><li><strong>雪崩效应</strong>：输入数据的微小变化应该导致哈希值的显著变化，这被称为雪崩效应。这有助于确保即使输入数据发生轻微更改，其哈希值也会截然不同。</li><li><strong>抗攻击性</strong>：好的哈希算法应该对常见的攻击如碰撞攻击、预像攻击、彩虹表攻击等具有较高的抵抗能力。</li></ol><p>哈希在计算机科学和密码学中具有广泛的应用，包括但不限于：</p><ul><li><strong>数据完整性验证</strong>：通过比较哈希值，可以验证数据是否在传输或存储过程中被篡改。</li><li><strong>密码存储</strong>：用户密码通常不会以明文形式存储，而是将其哈希后存储。当用户登录时，系统将输入密码进行哈希，并与存储的哈希值进行比较。</li><li><strong>数字签名</strong>：数字签名使用哈希函数和加密技术，以确保数据的来源和完整性。</li><li><strong>散列存储</strong>：哈希函数在散列表（HashTable）等数据结构中用于快速查找和访问数据。</li></ul><p>总之，哈希在计算中起着重要的作用，可以帮助保障数据的安全性、完整性和快速处理。</p><h3 id="常见哈希函数">常见哈希函数</h3><p>常见的哈希算法包括：</p><ol><li>MD5（Message Digest Algorithm 5）：MD5 是一种广泛使用的哈希算法，输出 128 位（16 字节）的哈希值。然而，由于其安全性不足，已经不推荐用于加密目的。</li><li>SHA-1（Secure Hash Algorithm 1）：SHA-1 产生 160 位（20 字节）的哈希值，也因为安全性问题逐渐被淘汰。</li><li>SHA-256（Secure Hash Algorithm 256）：SHA-256 是 SHA-2 家族的一部分，输出 256 位（32 字节）的哈希值，广泛用于加密和数据完整性验证。</li><li>SHA-3（Secure Hash Algorithm 3)）：SHA-3 是 SHA-2 之后发布的哈希算法标准，输出的哈希值长度可以是 224、256、384 或 512 位，提供更高的安全性。</li><li>bcrypt：bcrypt 是一种针对密码存储的哈希算法，通过加盐和多轮哈希来增加安全性，通常用于用户密码的加密存储。</li><li>scrypt：scrypt 是另一种专门用于密码存储的哈希函数，具有内存硬化（memory-hard）特性，增加了攻击者使用专用硬件攻击的难度。</li><li>SHAKE（SHA-3 SHAKE Extendable-Output Function）：SHAKE 允许指定不同的输出长度，提供更大范围的哈希值长度。</li></ol><p>这只是其中的一部分常见哈希算法，每种算法都有自己的优缺点和适用场景。在选择哈希算法时，应根据具体需求考虑其安全性、性能以及适用性。</p><p><strong>在 Java 类库（JDK 11）中支持的 hash 算法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.security.MessageDigest;<br><span class="hljs-keyword">import</span> java.security.NoSuchAlgorithmException;<br><span class="hljs-keyword">import</span> java.security.Security;<br><span class="hljs-keyword">import</span> java.util.Formatter;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JdkHash</span> &#123;<br>    <span class="hljs-keyword">private</span> MessageDigest hash;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">JdkHash</span><span class="hljs-params">(String algorithm)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            hash = MessageDigest.getInstance(algorithm);<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchAlgorithmException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">hashcode</span><span class="hljs-params">(String input)</span> &#123;<br>        <span class="hljs-type">Formatter</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Formatter</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">byte</span> b : hash.digest(input.getBytes())) &#123;<br>            f.format(<span class="hljs-string">&quot;%02x&quot;</span>, b);<br>        &#125;<br>        <span class="hljs-keyword">return</span> f.toString();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;支持的算法: &quot;</span>);<br>        <span class="hljs-keyword">for</span> (String messageDigest : Security.getAlgorithms(<span class="hljs-string">&quot;MessageDigest&quot;</span>)) &#123;<br>            System.out.print(messageDigest + <span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">支持的算法: <br>SHA3-<span class="hljs-number">512</span> SHA-<span class="hljs-number">1</span> SHA-<span class="hljs-number">384</span> SHA3-<span class="hljs-number">384</span> SHA-<span class="hljs-number">224</span> SHA-<span class="hljs-number">512</span>/<span class="hljs-number">256</span> SHA-<span class="hljs-number">256</span> MD2 SHA-<span class="hljs-number">512</span>/<span class="hljs-number">224</span> SHA3-<span class="hljs-number">256</span> SHA-<span class="hljs-number">512</span> MD5 SHA3-<span class="hljs-number">224</span><br></code></pre></td></tr></table></figure><h3 id="哈希冲突">哈希冲突</h3><h4 id="简介-3">简介</h4><p>对于不同的关键字 key，可能得到同一个哈希地址，即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mi>e</mi><mi>y</mi><mn>1</mn><mo mathvariant="normal">≠</mo><mi>k</mi><mi>e</mi><mi>y</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">key1 \neq key2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal" style="margin-right:0.03588em;">ey</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal" style="margin-right:0.03588em;">ey</span><span class="mord">2</span></span></span></span>，但是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mi>a</mi><mi>s</mi><mi>h</mi><mo stretchy="false">(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mi>h</mi><mi>a</mi><mi>s</mi><mi>h</mi><mo stretchy="false">(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">hash(key1)=hash(key2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ha</span><span class="mord mathnormal">s</span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal" style="margin-right:0.03588em;">ey</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ha</span><span class="mord mathnormal">s</span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal" style="margin-right:0.03588em;">ey</span><span class="mord">2</span><span class="mclose">)</span></span></span></span>，这种现象就称为 <strong>哈希冲突</strong>，也叫 <strong>哈希碰撞</strong>。</p><p>一般情况下，哈希冲突只能尽可能的减少，但不可能完全避免。因为哈希函数是从关键字集合到地址集合的映射，通常来说关键字集合比较大，它的元素理论上包括所有可能的关键字，而地址集合的元素仅为哈希表中的地址值。这就导致了哈希冲突的必然性。</p><p>下面以 <strong>除留取余法</strong> 作为哈希函数，来说明哈希碰撞。</p><p>假设 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>19</mn><mo separator="true">,</mo><mn>24</mn><mo separator="true">,</mo><mn>6</mn><mo separator="true">,</mo><mn>33</mn><mo separator="true">,</mo><mn>51</mn><mo separator="true">,</mo><mn>15</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[19,24,6,33,51,15]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">19</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">24</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">33</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">51</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">15</span><span class="mclose">]</span></span></span></span>，用散列存储的方式存储在一个长度为 11 的数组中，将这组数据分别模上数组的长度，以余数作为该元素在数组中的存储位置，则得到如下的哈希表：</p><p><img src="/algorithm-53bff467bc4b/image-20240116215739503.png" alt="哈希表"></p><p>若此时需要插入数据 72，经过哈希函数计算出索引为 6，但此时数组中 6 的位置已经被其他元素占据了，这就是 <strong>哈希冲突</strong>。</p><h4 id="开放定址法">开放定址法</h4><p>开放定址法是指当发生地址冲突时，按照某种方法继续探测哈希表中的其他存储单元，直到找到空位置为止。</p><p>72 模 11 后得到 6，而此时 6 的位置已经被其他元素占用了，那么将 6 加 1 得到 7， 此时发现 7 的位置也被占用了，那就再加 1 得到下一个地址为 8，而此时 8 仍然被占用，再接着加 1 得到 9，此时 9 处为空，则将 72 存入其中，即得到如下哈希表：</p><p><img src="/algorithm-53bff467bc4b/image-20240116215912273.png" alt="线性探测再散列"></p><p>像上边的这种探测方法称为 <strong>线性探测再散列</strong>。</p><p>当然除此之外还有 <strong>二次探测再散列</strong>，探测地址的方式为原哈希地址加上 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>d</mi><mo>=</mo><mo>±</mo><msup><mn>1</mn><mn>2</mn></msup><mo separator="true">,</mo><mo>±</mo><msup><mn>2</mn><mn>2</mn></msup><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mo>±</mo><msup><mi>m</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(d=\pm1^2,\pm2^2,...,\pm m^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord">±</span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">±</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">±</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，经过二次探测再散列后会得到求得 72 的哈希地址为 5，存储如下图所示：</p><p><img src="/algorithm-53bff467bc4b/image-20240116220032152.png" alt="二次探测再散列"></p><h4 id="再哈希法">再哈希法</h4><p>再哈希法即选取若干个不同的哈希函数，在产生哈希冲突的时候计算另一个哈希函数，直到不再发生冲突为止。</p><h4 id="建立公共溢出区">建立公共溢出区</h4><p>专门维护一个溢出表，当发生哈希冲突时，将值填入溢出表。</p><h4 id="拉链法">拉链法</h4><p>拉链法是指在碰到哈希冲突的时候，将冲突的元素以链表的形式进行存储。也就是凡是哈希地址为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 的元素都插入到同一个链表中，元素插入的位置可以是表头（<strong>头插法</strong>），也可以是表尾（<strong>尾插法</strong>）。</p><p>以一组新的数据 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>19</mn><mo separator="true">,</mo><mn>24</mn><mo separator="true">,</mo><mn>6</mn><mo separator="true">,</mo><mn>33</mn><mo separator="true">,</mo><mn>51</mn><mo separator="true">,</mo><mn>15</mn><mo separator="true">,</mo><mn>25</mn><mo separator="true">,</mo><mn>72</mn><mo separator="true">,</mo><mn>37</mn><mo separator="true">,</mo><mn>17</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>55</mn><mo separator="true">,</mo><mn>83</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[19,24,6,33,51,15,25,72,37,17,4,55,83]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">19</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">24</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">33</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">51</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">15</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">25</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">72</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">37</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">17</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">55</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">83</span><span class="mclose">]</span></span></span></span> 为例，使用 <strong>拉链法</strong> 解决哈希冲突的结果如下：</p><p><img src="/algorithm-53bff467bc4b/image-20240116220238449.png" alt="拉链法"></p><p>虽然拉链法是一种很好的处理哈希冲突的方法，但是在一些极端情况下也会出现问题，如这样一组数据 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>48</mn><mo separator="true">,</mo><mn>15</mn><mo separator="true">,</mo><mn>26</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>70</mn><mo separator="true">,</mo><mn>82</mn><mo separator="true">,</mo><mn>59</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[48,15,26,4,70,82,59]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">48</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">15</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">26</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">70</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">82</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">59</span><span class="mclose">]</span></span></span></span>，散列存储在长度为 11 的数组中：</p><p><img src="/algorithm-53bff467bc4b/image-20240116220550344.png" alt="退化为链表"></p><p>可以发现，此时的哈希表已经退化成了一个链表，在这样的数据结构中去查找某个元素的话，时间复杂度又变回了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，不符合预期。因此，当哈希表中的链表过长时就需要对其进行优化。</p><p>二叉查找树的查询效率是远远高于链表的。因此，当哈希表中的链表过长时可以把这个链表变成一棵红黑树。</p><p>上面的一组数据优化后可得到如下结果：</p><p><img src="/algorithm-53bff467bc4b/image-20240116220803208.png" alt="红黑树结构"></p><p>红黑树是一个可以自平衡的二叉查找树。它的查询的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。通过这样的优化可以提高哈希表的查询效率。</p><h3 id="hashCode">hashCode</h3><h4 id="Object-hashCode">Object.hashCode</h4><ul><li>Object 的 hashCode 方法默认是生成随机数作为 hash 值（会缓存在对象头当中）</li><li>包含相同 <strong>值</strong> 的不同对象，它们的 hashCode 不一样，不能够用 hash 值来反映对象的 <strong>值</strong> 特征，因此诸多子类都会重写 hashCode 方法</li></ul><h4 id="String-hashCode">String.hashCode</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> hash;<br>    <span class="hljs-keyword">if</span> (h == <span class="hljs-number">0</span> &amp;&amp; value.length &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">char</span> val[] = value;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; value.length; i++) &#123;<br>            h = <span class="hljs-number">31</span> * h + val[i];<br>            <span class="hljs-comment">// 优化 h = (h &lt;&lt; 5) - h + val[i]</span><br>        &#125;<br>        hash = h;<br>    &#125;<br>    <span class="hljs-keyword">return</span> h;<br>&#125;<br></code></pre></td></tr></table></figure><p>计算类似于：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>×</mo><mn>3</mn><msup><mn>1</mn><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>+</mo><mi>s</mi><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo>×</mo><mn>3</mn><msup><mn>1</mn><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow></msup><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><mi>s</mi><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">s[0] × 31 ^ {n - 1} + s[1] × 31 ^ {n - 2} + ... + s[n - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord">3</span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord">3</span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">...</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></p><ul><li>经验表明如果每次乘的是较大质数，可以有更好地降低 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mi>a</mi><mi>s</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">hash</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">ha</span><span class="mord mathnormal">s</span><span class="mord mathnormal">h</span></span></span></span> 冲突</li><li>【乘 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>31</mn></mrow><annotation encoding="application/x-tex">31</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">31</span></span></span></span>】可以等价为【乘 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>32</mn></mrow><annotation encoding="application/x-tex">32</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">32</span></span></span></span> - <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span></span></span></span>】，进一步可以转为更高效地【左移 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5</span></span></span></span> 位 - <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span></span></span></span>】</li></ul><h2 id="HashTable">HashTable</h2><h3 id="简介-4">简介</h3><p>下面实现一个简单的哈希表。</p><p>使用 <strong>拉链法</strong> 解决哈希冲突，底层由 <strong>数组（桶）加单链表</strong> 组成（和 Java 的 HashMap 类似）。</p><h3 id="节点">节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span> &#123;<br>    <span class="hljs-type">int</span> hash;<br>    Object key;<br>    Object value;<br>    Entry next;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Entry</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, Object key, Object value)</span> &#123;<br>        <span class="hljs-built_in">this</span>.hash = hash;<br>        <span class="hljs-built_in">this</span>.key = key;<br>        <span class="hljs-built_in">this</span>.value = value;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="哈希函数-2">哈希函数</h3><p>使用 Java 中 Object.hashCode 方法生成哈希值，该哈希值对底层数组的长度进行取模运算得到元素映射的桶的索引，在数组长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span> 的条件下，优化为 <strong>位运算</strong>，即</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>h</mi><mi>a</mi><mi>s</mi><mi>h</mi><mi mathvariant="normal">%</mi><mtext>数组长度</mtext><mo>=</mo><mi>h</mi><mi>a</mi><mi>s</mi><mi>h</mi><mi mathvariant="normal">&amp;</mi><mo stretchy="false">(</mo><mtext>数组长度</mtext><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">hash \%数组长度=hash\&amp;(数组长度-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8056em;vertical-align:-0.0556em;"></span><span class="mord mathnormal">ha</span><span class="mord mathnormal">s</span><span class="mord mathnormal">h</span><span class="mord">%</span><span class="mord cjk_fallback">数组长度</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ha</span><span class="mord mathnormal">s</span><span class="mord mathnormal">h</span><span class="mord">&amp;</span><span class="mopen">(</span><span class="mord cjk_fallback">数组长度</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span> &#123;<br>    <span class="hljs-keyword">return</span> key.hashCode() &amp; (table.length - <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="查找">查找</h3><ul><li>根据 <strong>哈希函数</strong> 找到该 key 所在的桶（若存在）</li><li>遍历该桶找到该 key 对应的 Entry 节点，返回其 value</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">get</span><span class="hljs-params">(Object key)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> hash(key);<br>    <span class="hljs-keyword">if</span> (table[idx] == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-type">Entry</span> <span class="hljs-variable">curr</span> <span class="hljs-operator">=</span> table[idx];<br>    <span class="hljs-keyword">while</span> (curr != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (curr.key.equals(key)) &#123;<br>            <span class="hljs-keyword">return</span> curr.value;<br>        &#125;<br>        curr = curr.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="新增">新增</h3><ul><li>根据 <strong>哈希函数</strong> 找到该 key 所在的桶（若存在）</li><li>将键和值封装在 Entry 节点挂在该桶下，若该桶已有节点则挂在该桶尾节点后面作为新的尾节点（尾插）</li><li>若键已存在则更新其值</li><li>若更新后 size 超过阈值（threshold）则需要扩容</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(Object key, Object value)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> hash(key);<br>    <span class="hljs-keyword">if</span> (table[idx] == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 直接新增</span><br>        table[idx] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(key.hashCode(), key, value);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 沿着链表查找, 若 key 已存在则更新, 否则新增</span><br>        <span class="hljs-type">Entry</span> <span class="hljs-variable">curr</span> <span class="hljs-operator">=</span> table[idx];<br>        <span class="hljs-keyword">while</span> (curr.next != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 更新</span><br>            <span class="hljs-keyword">if</span> (curr.key.equals(key)) &#123;<br>                curr.value = value;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            curr = curr.next;<br>        &#125;<br>        curr.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(key.hashCode(), key, value);<br>    &#125;<br>    size++;<br>    <span class="hljs-comment">// size 超过阈值则扩容</span><br>    <span class="hljs-keyword">if</span> (size &gt; threshold) &#123;<br>        grow();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="扩容">扩容</h3><p>在 <strong>哈希表</strong> 的每个桶，最多拆分为两个桶，即一个单链表最多拆分为两个单链表，可以按照下面的规则进行划分：</p><ul><li>若 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mi>a</mi><mi>s</mi><mi>h</mi><mi mathvariant="normal">&amp;</mi><mi>t</mi><mi>a</mi><mi>b</mi><mi>l</mi><mi>e</mi><mi mathvariant="normal">.</mi><mi>l</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>t</mi><mi>h</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">hash\&amp;table.length=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ha</span><span class="mord mathnormal">s</span><span class="mord mathnormal">h</span><span class="mord">&amp;</span><span class="mord mathnormal">t</span><span class="mord mathnormal">ab</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 为一组</li><li>若 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mi>a</mi><mi>s</mi><mi>h</mi><mi mathvariant="normal">&amp;</mi><mi>t</mi><mi>a</mi><mi>b</mi><mi>l</mi><mi>e</mi><mi mathvariant="normal">.</mi><mi>l</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>t</mi><mi>h</mi><mo mathvariant="normal">≠</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">hash\&amp;table.length \neq 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ha</span><span class="mord mathnormal">s</span><span class="mord mathnormal">h</span><span class="mord">&amp;</span><span class="mord mathnormal">t</span><span class="mord mathnormal">ab</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 为另一组</li></ul><p>每一次扩容的新的桶大小为原桶大小的 2 倍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">grow</span><span class="hljs-params">()</span> &#123;<br>    Entry[] newT = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>[table.length &lt;&lt; <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; table.length; i++) &#123;<br>        <span class="hljs-type">Entry</span> <span class="hljs-variable">curr</span> <span class="hljs-operator">=</span> table[i];<br>        <span class="hljs-keyword">if</span> (curr != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 拆分链表</span><br>            <span class="hljs-type">Entry</span> <span class="hljs-variable">pa</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-type">Entry</span> <span class="hljs-variable">pb</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-type">Entry</span> <span class="hljs-variable">headA</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-type">Entry</span> <span class="hljs-variable">headB</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">while</span> (curr != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> ((curr.hash &amp; table.length) == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (pa != <span class="hljs-literal">null</span>) &#123;<br>                        pa.next = curr;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        headA = curr;<br>                    &#125;<br>                    pa = curr;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">if</span> (pb != <span class="hljs-literal">null</span>) &#123;<br>                        pb.next = curr;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        headB = curr;<br>                    &#125;<br>                    pb = curr;<br>                &#125;<br>                curr = curr.next;<br>            &#125;<br>            <span class="hljs-comment">// pa 链表的位置不变, pb 链表的位置加上原 table.length 即可</span><br>            <span class="hljs-keyword">if</span> (pa != <span class="hljs-literal">null</span>) &#123;<br>                pa.next = <span class="hljs-literal">null</span>;<br>                newT[i] = headA;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (pb != <span class="hljs-literal">null</span>) &#123;<br>                pb.next = <span class="hljs-literal">null</span>;<br>                newT[i + table.length] = headB;<br>            &#125;<br>        &#125;<br>    &#125;<br>    table = newT;<br>    <span class="hljs-comment">// 更新阈值</span><br>    threshold = (<span class="hljs-type">int</span>) (loadFactor * table.length);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="删除">删除</h3><ul><li>根据 <strong>哈希函数</strong> 找到该 key 所在的桶（若存在）</li><li>遍历该桶找到该 key 对应的 Entry 节点，从单链表中删除该节点</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">remove</span><span class="hljs-params">(Object key)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> hash(key);<br>    <span class="hljs-keyword">if</span> (table[idx] == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-type">Entry</span> <span class="hljs-variable">curr</span> <span class="hljs-operator">=</span> table[idx];<br>    <span class="hljs-type">Entry</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">while</span> (curr != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (curr.key.equals(key)) &#123;<br>            <span class="hljs-keyword">if</span> (prev == <span class="hljs-literal">null</span>) &#123;<br>                table[idx] = curr.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                prev.next = curr.next;<br>            &#125;<br>            size--;<br>            <span class="hljs-keyword">return</span> curr.value;<br>        &#125;<br>        prev = curr;<br>        curr = curr.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="模板代码">模板代码</h3>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-a8163d0f" role="button" aria-expanded="false" aria-controls="collapse-a8163d0f">        <div class="fold-arrow">▶</div>模板代码      </div>      <div class="fold-collapse collapse" id="collapse-a8163d0f">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashTable</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span> &#123;<br>        <span class="hljs-type">int</span> hash;<br>        Object key;<br>        Object value;<br>        Entry next;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Entry</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, Object key, Object value)</span> &#123;<br>            <span class="hljs-built_in">this</span>.hash = hash;<br>            <span class="hljs-built_in">this</span>.key = key;<br>            <span class="hljs-built_in">this</span>.value = value;<br>        &#125;<br>    &#125;<br><br>    Entry[] table = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>[<span class="hljs-number">16</span>];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">float</span> <span class="hljs-variable">loadFactor</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.75f</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">threshold</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) (loadFactor * table.length);<br><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">get</span><span class="hljs-params">(Object key)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> hash(key);<br>        <span class="hljs-keyword">if</span> (table[idx] == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-type">Entry</span> <span class="hljs-variable">curr</span> <span class="hljs-operator">=</span> table[idx];<br>        <span class="hljs-keyword">while</span> (curr != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (curr.key.equals(key)) &#123;<br>                <span class="hljs-keyword">return</span> curr.value;<br>            &#125;<br>            curr = curr.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(Object key, Object value)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> hash(key);<br>        <span class="hljs-keyword">if</span> (table[idx] == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 直接新增</span><br>            table[idx] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(key.hashCode(), key, value);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 沿着链表查找, 有重复的 key 则更新, 否则新增</span><br>            <span class="hljs-type">Entry</span> <span class="hljs-variable">curr</span> <span class="hljs-operator">=</span> table[idx];<br>            <span class="hljs-keyword">while</span> (curr.next != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (curr.key.equals(key)) &#123;<br>                    curr.value = value;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                curr = curr.next;<br>            &#125;<br>            curr.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(key.hashCode(), key, value);<br>        &#125;<br>        size++;<br>        <span class="hljs-comment">// size 超过阈值则扩容</span><br>        <span class="hljs-keyword">if</span> (size &gt; threshold) &#123;<br>            grow();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">remove</span><span class="hljs-params">(Object key)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> hash(key);<br>        <span class="hljs-keyword">if</span> (table[idx] == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-type">Entry</span> <span class="hljs-variable">curr</span> <span class="hljs-operator">=</span> table[idx];<br>        <span class="hljs-type">Entry</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span> (curr != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (curr.key.equals(key)) &#123;<br>                <span class="hljs-keyword">if</span> (prev == <span class="hljs-literal">null</span>) &#123;<br>                    table[idx] = curr.next;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    prev.next = curr.next;<br>                &#125;<br>                size--;<br>                <span class="hljs-keyword">return</span> curr.value;<br>            &#125;<br>            prev = curr;<br>            curr = curr.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">grow</span><span class="hljs-params">()</span> &#123;<br>        Entry[] newT = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>[table.length &lt;&lt; <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; table.length; i++) &#123;<br>            <span class="hljs-type">Entry</span> <span class="hljs-variable">curr</span> <span class="hljs-operator">=</span> table[i];<br>            <span class="hljs-keyword">if</span> (curr != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 拆分链表</span><br>                <span class="hljs-type">Entry</span> <span class="hljs-variable">pa</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>                <span class="hljs-type">Entry</span> <span class="hljs-variable">pb</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>                <span class="hljs-type">Entry</span> <span class="hljs-variable">headA</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>                <span class="hljs-type">Entry</span> <span class="hljs-variable">headB</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>                <span class="hljs-keyword">while</span> (curr != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">if</span> ((curr.hash &amp; table.length) == <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-keyword">if</span> (pa != <span class="hljs-literal">null</span>) &#123;<br>                            pa.next = curr;<br>                        &#125; <span class="hljs-keyword">else</span> &#123;<br>                            headA = curr;<br>                        &#125;<br>                        pa = curr;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-keyword">if</span> (pb != <span class="hljs-literal">null</span>) &#123;<br>                            pb.next = curr;<br>                        &#125; <span class="hljs-keyword">else</span> &#123;<br>                            headB = curr;<br>                        &#125;<br>                        pb = curr;<br>                    &#125;<br>                    curr = curr.next;<br>                &#125;<br>                <span class="hljs-comment">// pa 链表的位置不变, pb 链表的位置加上原 table.length 即可</span><br>                <span class="hljs-keyword">if</span> (pa != <span class="hljs-literal">null</span>) &#123;<br>                    pa.next = <span class="hljs-literal">null</span>;<br>                    newT[i] = headA;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (pb != <span class="hljs-literal">null</span>) &#123;<br>                    pb.next = <span class="hljs-literal">null</span>;<br>                    newT[i + table.length] = headB;<br>                &#125;<br>            &#125;<br>        &#125;<br>        table = newT;<br>        <span class="hljs-comment">// 更新阈值</span><br>        threshold = (<span class="hljs-type">int</span>) (loadFactor * table.length);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span> &#123;<br>        <span class="hljs-keyword">return</span> key.hashCode() &amp; (table.length - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h2 id="哈希相关">哈希相关</h2><h3 id="布隆过滤器">布隆过滤器</h3><h4 id="概述">概述</h4><p>布隆过滤器（BloomFilter）是一种 <strong>空间高效</strong> 的 <strong>概率型</strong> 数据结构，用于判断一个元素是否属于某个集合。经常被用于快速检查一个元素是否存在于大型数据集中，同时具有很低的内存消耗。</p><p>基本思想：使用 <strong>多个哈希函数</strong> 将元素映射到一个 <strong>位数组</strong> 中的 <strong>多个位置</strong>，每个哈希函数对应位数组的一个位置。当判断一个元素是否在集合中时，将这个元素经过哈希函数映射到位数组中的相应位置，如果所有对应的位都已经被置为 1，则可以大致判定元素可能在集合中，如果有任何一个位为 0，则可以确定元素肯定不在集合中。</p><p>布隆过滤器的优点在于它占用的内存非常小，适合处理大规模的数据集合，而且查询速度非常快。然而，它也有一些缺点：</p><ol><li><strong>误判率</strong>：由于哈希函数的映射和位数组的有限大小，布隆过滤器存在一定的误判率。<strong>即使一个元素没有在集合中，也有可能被误判为在集合中</strong>。</li><li><strong>删除困难</strong>：一旦元素被加入布隆过滤器，通常无法直接删除，因为删除一个元素可能会影响到其他元素的判断结果。</li><li><strong>无法存储具体信息</strong>：布隆过滤器只能告诉你元素可能在集合中，但不能存储元素的具体信息。</li></ol><p>布隆过滤器在很多应用场景中非常有用，例如：</p><ul><li>网络爬虫中用于快速判断一个 URL 是否已经被访问过。</li><li>数据库查询中用于减少对庞大数据库的查询次数。</li><li>分布式系统中用于判定某个数据是否已经同步过。</li><li>防止缓存穿透，过滤掉不存在的数据查询。</li></ul><p>布隆过滤器适合那些可以 <strong>容忍一定误判率</strong> 的场景，但不适合那些对于误判率要求较高的场景。</p><h4 id="实现原理">实现原理</h4><p>通常判断某个元素是否存在用的是什么？HashMap？将值映射到 HashMap 的 Key，然后在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 的时间复杂度内返回结果，效率很高。</p><p>但是 HashMap 的实现也有缺点，如存储容量高，考虑到负载因子的存在，通常空间是不能被用满的，而一旦值很多，多达上亿的时候，那 HashMap 占据的内存大小就变得很可观了。</p><p>若数据集存储在远程服务器上，本地服务接受输入，而数据集非常大，不可能一次性读进内存构建 HashMap 的时候，也会存在问题。</p><p>如果你可以容忍一定误判率，那么不访试试布隆过滤器，它相较于 HashMap 来说，有着极大的空间优化。</p><p>布隆过滤器是一个 bit 向量或者 bit 数组：</p><p><img src="/algorithm-53bff467bc4b/image-20231226091636681.png" alt="bit 向量"></p><p>如果要映射一个值到布隆过滤器中，需要使用多个不同的哈希函数生成多个哈希值，并将每个生成的哈希值指向的 bit 位置为 1，如针对值 “baidu” 和三个不同的哈希函数分别生成了哈希值 0、3、7，则上图转变为：</p><p><img src="/algorithm-53bff467bc4b/image-20231226091931703.png" alt="布隆过滤器"></p><p>再存一个值 “tencent”，如果哈希函数返回 2、3、6 的话，则：</p><p><img src="/algorithm-53bff467bc4b/image-20231226092132757.png" alt="布隆过滤器"></p><p>3 这个 bit 位由于两个值的哈希函数都返回了这个 bit 位，因此它被覆盖了。</p><p>现在查询 “ocsio” 这个值是否存在，哈希函数返回了 0、4、7 三个值，结果发现 4 这个 bit 位上的值为 0，<strong>说明没有任何一个值映射到这个 bit 位上</strong>，因此可以很明确地说 “ocsio” 这个值不存在。</p><p>而当查询 “baidu” 这个值是否存在，那么哈希函数必然会返回 0、3、7，检查发现这三个 bit 位上的值均为 1，那么可以说 “baidu” <strong>存在了么？答案是不可以，只能是 “baidu” 这个值可能存在。</strong></p><p>因为随着增加的值越来越多，被置为 1 的 bit 位也会越来越多，这样某个值如 “taobao” 即使没有被存储过，但是若哈希函数返回的三个 bit 位都被其他值置为了 1 ，那么程序还是会判断 “taobao” 这个值存在。</p><p>这也是布隆过滤器的 <strong>误判率</strong> 所在，即使一个元素没有在集合中，也可能被误判为在集合中。</p><h4 id="三个公式">三个公式</h4><p>布隆过滤器涉及到几个重要的公式，用于计算布隆过滤器所需的参数和性能指标：</p><p>1）<strong>位数组大小（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>）的计算</strong>：布隆过滤器使用一个位数组来存储数据，每个位表示一个位置的状态（1 或 0）。要存储 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个元素，假设期望的误判率为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span>，位数组大小 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 可以通过以下公式计算，向上取整：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>m</mi><mo>=</mo><mo>−</mo><mfrac><mrow><mi>n</mi><mo>×</mo><mi>l</mi><mi>n</mi><mtext>  </mtext><mi>p</mi></mrow><mrow><mo stretchy="false">(</mo><mi>l</mi><mi>n</mi><mtext>  </mtext><mn>2</mn><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow></mfrac></mrow><annotation encoding="application/x-tex">m=-\frac{n×ln\;p}{(ln\;2)^2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.3074em;vertical-align:-0.936em;"></span><span class="mord">−</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">2</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7401em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>2）<strong>哈希函数个数（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>）的计算</strong></p><p>布隆过滤器使用多个哈希函数来将元素映射到位数组中的多个位置。哈希函数的个数可以通过以下公式计算：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>k</mi><mo>=</mo><mi>l</mi><mi>n</mi><mtext>  </mtext><mn>2</mn><mo>×</mo><mfrac><mi>m</mi><mi>n</mi></mfrac></mrow><annotation encoding="application/x-tex">k = ln\;2 ×\frac{m}{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.7936em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1076em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 是位数组大小，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 是要存储的元素个数。</p><p>3）<strong>实际误判率（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span>）的计算</strong></p><p>布隆过滤器的实际误判率取决于位数组大小、哈希函数个数以及要存储的元素个数。可以通过以下公式估计实际误判率：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>P</mi><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><msup><mi>e</mi><mrow><mo>−</mo><mfrac><mrow><mi>n</mi><mi>k</mi></mrow><mi>m</mi></mfrac></mrow></msup><msup><mo stretchy="false">)</mo><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">P= (1-e^{-\frac{nk}{m}})^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.279em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.029em;"><span style="top:-3.413em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.88em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span style="top:-3.2255em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">nk</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span></span></p><p>其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 是哈希函数个数，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 是要存储的元素个数，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 是位数组大小。</p><p>这些公式提供了布隆过滤器的一些理论指导，但实际应用中可能会受到哈希函数的质量、实际数据分布等因素的影响，因此实际性能可能会略有偏差。</p><p><strong>如何获取 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 个哈希函数？</strong></p><p>在布隆过滤器中，选择适当的哈希函数个数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 是一个重要的考虑因素，它会影响到误判率和性能。合适的哈希函数个数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 可以通过以下方法来选择：</p><ol><li><strong>独立的哈希函数</strong>：选择多个相互独立的哈希函数。这些哈希函数应该能够均匀地将元素映射到位数组中的不同位置，以减少碰撞的可能性。常见的哈希函数有散列函数（如 MD5、SHA-1、SHA-256 等）。</li><li><strong>多次哈希</strong>：通过多次应用同一个哈希函数并引入不同的种子值，产生多个哈希值。这样可以模拟多个独立的哈希函数。例如，对于一种哈希函数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span></span></span></span>，可以计算 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mn>1</mn></msub><mo>=</mo><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>s</mi><mi>e</mi><mi>e</mi><mi>d</mi><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h_1=h(x, seed1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">see</span><span class="mord mathnormal">d</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mn>2</mn></msub><mo>=</mo><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>s</mi><mi>e</mi><mi>e</mi><mi>d</mi><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h_2=h(x,seed2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">see</span><span class="mord mathnormal">d</span><span class="mord">2</span><span class="mclose">)</span></span></span></span> 等多个哈希值。</li><li><strong>取模操作</strong>：每个哈希值计算出一个位置，这个位置可能超过位数组的大小。通过对位置进行取模操作，将其映射到位数组的范围内。这样可以保证哈希值的范围在位数组大小之内。</li></ol><p>常见的做法是结合多个哈希函数，如选择一组独立的哈希函数，每个函数对输入进行不同的变换，并取模映射到位数组的范围内。</p><p>总之，选择哈希函数个数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 需要考虑实际应用的误判率要求和性能。较大的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 值可以减少误判率，但会增加计算成本，较小的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 值可能会导致较高的误判率。通常情况下，根据误判率和数据规模，选择适当的哈希函数个数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 可以在误判率和性能之间取得平衡。</p><h3 id="一致性哈希">一致性哈希</h3><p>一致性哈希（Consistent Hashing）是一种用于 <strong>分布式系统</strong> 中数据分片和负载均衡的算法。它的目标是在节点的增加、减少或故障恢复等情况下，最小化数据迁移，同时保持负载均衡。</p><p>在传统的哈希算法中，当节点数量发生变化时，需要重新计算哈希值，导致大量数据的重新映射。这在分布式环境中可能会导致性能问题和数据迁移的开销。而一致性哈希算法通过引入虚拟节点（也称为虚拟副本或虚拟节点副本）的概念，可以在节点变动时减少数据迁移。</p><p>基本思想是将节点和数据都映射到一个相同的环上，环的范围是一个哈希函数的输出空间。每个节点在环上占据一个位置，数据根据哈希函数映射到环上的一个位置。当数据需要被存储或查找时，根据其哈希值找到环上最近的节点，然后在该节点上进行存储或查找操作。</p><p>一致性哈希具有以下特点：</p><ol><li><strong>节点的平衡性</strong>：节点在环上均匀分布，确保负载均衡，因为每个节点只负责环上它与其前一个节点之间的数据区间。</li><li><strong>扩展性</strong>：当节点数量变化时，只会影响到环上少部分数据，大部分数据仍然映射到相同的节点，从而减少数据迁移。</li><li><strong>节点故障的影响减小</strong>：节点故障时，只会影响到环上故障节点的数据区间，而不会影响到其他节点的数据。</li><li><strong>简单性</strong>：一致性哈希算法相对于其他分布式哈希算法来说，实现相对较简单。</li></ol><p>注意，虽然一致性哈希算法在解决分布式负载均衡和节点变化时的数据迁移问题上具有优势，但也可能导致数据分布不够均匀或热点问题。为解决这些问题，提出了一些改进的一致性哈希算法，如带虚拟节点的一致性哈希等。</p><p><strong>带虚拟节点的一致性哈希</strong></p><p>虚拟节点的一致性哈希（Virtual Node Consistent Hashing）是一种对传统一致性哈希算法的改进，旨在解决节点分布不均匀和负载不平衡等问题。</p><p>传统一致性哈希算法中，每个节点只在环上占据一个位置，数据根据哈希函数映射到环上的一个位置，然后根据节点位置存储或查找数据。然而，在某些情况下，节点的分布可能不均匀，导致某些节点负载较重，而其他节点负载较轻。</p><p>虚拟节点的一致性哈希通过引入虚拟节点的概念来解决这个问题。每个实际的物理节点会被映射到多个虚拟节点的位置上，这样就能够更均匀地分布节点，从而减少负载不平衡的问题。虚拟节点在环上的位置可以通过将物理节点的名称与某个数字或索引进行组合而得到。这样，每个物理节点会占据多个虚拟节点的位置，从而在环上分布更均匀。</p><p>虚拟节点的一致性哈希具有以下优点：</p><ol><li><strong>负载均衡</strong>：虚拟节点的引入可以更好地均匀分布数据，从而减少节点负载不平衡。</li><li><strong>节点扩展和收缩的影响减小</strong>：当节点数量变化时，只会影响到少数虚拟节点的位置，而不会影响到所有数据。</li><li><strong>简化数据迁移</strong>：节点的添加或删除时，只需调整虚拟节点的位置，从而减少实际数据的迁移。</li></ol><p>使用虚拟节点的一致性哈希需要在实现中对节点的映射进行适当的调整。每个节点可以映射到多个虚拟节点，然后在查询时，根据哈希函数找到最近的虚拟节点，进而定位到实际的物理节点。</p><p>虚拟节点的一致性哈希算法提供了更好的负载均衡和节点变动时的灵活性，使分布式系统能够更有效地应对节点变化和负载变化。</p>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
