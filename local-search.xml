<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>JVM 基础</title>
    <link href="/java/jvm-a1fb6fd89ac6/"/>
    <url>/java/jvm-a1fb6fd89ac6/</url>
    
    <content type="html"><![CDATA[<h1>JVM 基础</h1><h2 id="引言">引言</h2><h3 id="1-什么是-JVM">1. 什么是 JVM</h3><p>定义：Java Virtual Machine（Java 虚拟机），是 Java 程序的运行环境（Java  二进制字节码的运行环境）</p><p>JVM 的本质是一个运行在计算机上的程序，它的职责是 <strong>运行 Java 字节码文件</strong>。</p><p>比较：JVM、JRE（Java Runtime Environment）、JDK（Java Development Kit）</p><p><img src="/java/jvm-a1fb6fd89ac6/image-20240118102353745.png" alt="JVM vs JRE vs JDK"></p><p>其中，</p><ul><li><strong>基础类库</strong> 指的是 Java 的一些基础类，例如 IO 类、集合类、线程类、日期类等。</li><li><strong>编译工具</strong> 指的是像 Javac、Javap、内存监测工具这些 Java 编译工具。</li><li><strong>应用服务器</strong> 就是像 tomcat 这样的服务器。</li><li><strong>IDE</strong> 就是像 vscode、Idea 这样的集成开发环境。</li></ul><h3 id="2-JVM-的功能">2. JVM 的功能</h3><h4 id="2-1-解释和运行">2.1 解释和运行</h4><p>对字节码中的指令，实时的解释为机器码，让计算机执行。</p><p>我们平时编写的 .java 文件，会经过 javac 编译为 .class 字节码文件，将其交由 JVM 解释运行，其中字节码文件中包含了一连串的指令，即字节码指令，这些指令需要转换为机器码才能交给计算机执行，而转换机器码的过程就是 <strong>解释</strong>。</p><h4 id="2-2-内存管理">2.2 内存管理</h4><p>自动为对象、方法分配内存，自动垃圾回收机制，回收不再使用的对象。</p><p>对比于 C/C++，Java 的一个优势在于 JVM 会自动的帮助我们为对象分配内存，同时将不用的对象经过垃圾回收机制回收掉。</p><h4 id="2-3-即时编译">2.3 即时编译</h4><p>对热点代码进行优化，提升执行效率。对于 Java 程序来说，即时编译是提升 Java 程序性能的最核心的手段。</p><p>Java 语言需要将字节码指令实时的通过 JVM 解释为机器码，才能交给计算机执行，这个过程随着程序的执行需要反复的进行，所以每一次都会花费一定的时间。</p><p>而 C/C++ 在编译过程直接将源代码转换为机器码，省去了解释的过程，这样的话，Java 程序的性能就不如 C/C++。</p><p>而为了保证跨平台的特性，Java 不得不这样做，所以在 Jdk 1.1 版本中就推出了 <strong>即时编译</strong> 来提升性能。</p><blockquote><p>跨平台特性：</p><ul><li>将一份字节码指令交给不同的平台，在这些平台上安装不同的 JVM，分别将这份字节码指令解释为当前平台的机器码，就可以交给不同平台的操作系统执行。</li></ul></blockquote><p>即时编译具体的做法是，</p><ul><li>现在有一份字节码文件，里面的某段字节码指令，如果 JVM 发现这段指令是热点代码（很短的时间内被多次调用），则认为这段代码有必要优化。</li><li>于是 JVM 将该段代码解释为机器码，并将该机器码保存在内存中，当后面执行相同的代码时，直接从内存中调用该机器码，这样省略了解释的步骤，提升了性能。</li></ul><h3 id="3-常见的-JVM">3. 常见的 JVM</h3><blockquote><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html">Java® 虚拟机规范（oracle.com）</a></p></blockquote><p>对于一款 Java 虚拟机，必须遵守 Oracle 制定的 Java 虚拟机的规范。具体，</p><ul><li>字节码文件的定义。</li><li>类和接口的加载和初始化。</li><li>指令集。</li></ul><p>此外，Java 虚拟机不仅限于 Java 使用，现在像 Groovy、Scale 这样语言只能能够编译成满足规范的 .class 文件，同一能够借助于 Java 虚拟机来运行，这也体现了虚拟机的 <strong>标准化、灵活性</strong>。</p><p><strong>常见的 JVM</strong></p><p><img src="/java/jvm-a1fb6fd89ac6/image-20231103152951178.png" alt="常见的 JVM"></p><h2 id="JVM-组成">JVM 组成</h2><p><img src="/java/jvm-a1fb6fd89ac6/image-20231103153702802.png" alt="JVM 组成"></p><p>从 Java 源文件经过 javac 编译后的 <strong>字节码文件</strong> 开始，</p><ol><li>首先该字节码文件的来源有多种，比如从磁盘读取、从网络传输，JVM 需要把这些文件中的内容加载到内存中，后续使用才会比较高效，这个过程由 **类加载器（ClassLoader）**来实现。</li><li>那么 JVM 理所应当要准备一块内存去存放这些字节码文件中的类和接口，如果要创建对象，还要为这些对象申请内存，所以这块存放类、对象的内存区域就叫做 <strong>运行时数据区域</strong>，本质上它就是 JVM 所管理的内存。</li><li>最后应该执行字节码文件中的指令，也就是执行代码，所以将文件中的类和接口被加载到内存之后，JVM 就要使用 <strong>执行引擎</strong> 执行代码，需要将字节码指令解释成机器码，同时还要使用 <strong>即时编译（JIT）</strong> 优化性能，有些对象不再使用了，还要使用 <strong>垃圾回收器</strong> 来回收对象。</li><li>还有一个组件叫做本地接口，Java 虚拟机像 HotSport，使用 C++ 语言来编写，所以 Java 程序在运行时需要调用底层虚拟机实现的用 C++ 编写的方法（比如用 native 修饰的方法），这些方法在字节码文件中不存在，将它统称为本地接口，执行引擎会负责本地接口的调用，同时本地接口也会去创建对象。</li></ol><h2 id="字节码文件">字节码文件</h2><h3 id="1-概述">1. 概述</h3><p>在字节码文件中，主要包含 5 部分内容，</p><ol><li>基础信息：魔术版本号、访问标志、包含的父类、实现的接口。</li><li>常量池：字符串常量、类或接口名、字段名，主要在字节码指令中使用。</li><li>字段：源代码中类和接口的字段信息。</li><li>方法：源代码中类和接口的方法信息，以及方法转换的字节码指令。</li><li>属性：类的属性，可以理解为类的元信息，比如源码的文件名、内部类的列表等。</li></ol><p>下面我们将以下面的代码为例，详细说明上面的内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.aman;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hello</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello World&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a + b;<br>        System.out.println(<span class="hljs-string">&quot;c = &quot;</span> + c);<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-基础信息">2. 基础信息</h3><p><img src="/java/jvm-a1fb6fd89ac6/image-20231103160850095.png" alt="基础信息"></p><p>在一般信息中，包含了，</p><ol><li>主次版本号，即编译该字节码的 JVM 版本</li><li>计数（常量池、接口、字段、方法、属性计数）</li><li>访问标志</li><li>本类和父类的索引（链接到常量池）</li></ol><h4 id="2-1-魔术">2.1 魔术</h4><p>所有的字节码文件的前四个字节就是魔数，魔数的固定值为：0xCAFEBABE。魔数放在字节码文件开头，JVM 可以根据文件的开头来判断这个文件是否是一个字节码文件，若是，才会继续进行后续的操作。</p><h4 id="2-2-主次版本号">2.2 主次版本号</h4><p>主次版本号指的是编译字节码文件的 JDK 版本号，其中，</p><ul><li>主版本号用于标识大版本。</li><li>次版本号是当主版本号相同时作为区分不同版本的标识。</li></ul><p>JDK 1.0 ~ 1.1 使用 45.0 ~ 45.3，之后每升级一个大版本则主版本号加 1，所以在 JDK 1.2 后，大版本号的计算方法是 <strong>主版本号 - 44</strong>。</p><p>版本号主要的作用：判断当前字节码的版本和运行时的 JDK （即 JRE）是否兼容。</p><p>如，现在启动的是 JDK 7 的环境，想要运行一个 JDK 17 的字节码文件，当然是不行的，在加载过程就会报错。</p><h4 id="2-3-访问标志">2.3 访问标志</h4><p>描述该 Class 是类还是接口，以及是否被 public、abstract、final 等修饰符修饰。JVM 规范规定了如下表的访问标志（Access_Flag）。</p><table><thead><tr><th>Flag Name</th><th>Value</th><th>Interpretation</th></tr></thead><tbody><tr><td><code>ACC_PUBLIC</code></td><td>0x0001</td><td>public</td></tr><tr><td><code>ACC_FINAL</code></td><td>0x0010</td><td>final</td></tr><tr><td><code>ACC_SUPER</code></td><td>0x0020</td><td>略</td></tr><tr><td><code>ACC_INTERFACE</code></td><td>0x0200</td><td>接口</td></tr><tr><td><code>ACC_ABSTRACT</code></td><td>0x0400</td><td>abstract</td></tr><tr><td><code>ACC_SYNTHETIC</code></td><td>0x1000</td><td>略</td></tr><tr><td><code>ACC_ANNOTATION</code></td><td>0x2000</td><td>注解类型</td></tr><tr><td><code>ACC_ENUM</code></td><td>0x4000</td><td>枚举类型</td></tr></tbody></table><p>JVM 并没有穷举所有的访问标志，而是使用按位或操作来进行描述的</p><ul><li>如某个类的修饰符为 public final，则对应的访问修饰符的值为 ACC_PUBLIC | ACC_FINAL，即 0x0001 | 0x0010 = 0x0011。</li><li>字节码文件中 <strong>字段</strong> 和 <strong>方法</strong> 的访问标志与上述类似。</li></ul><h3 id="3-常量池">3. 常量池</h3><p>字节码文件中常量池的作用：可以避免相同的内容重复定义，以节省空间。主要存储两部分内容，</p><ol><li>字面量：源代码中声明为 final 的常量值。</li><li>符号引用：如类和接口的全限定名、字段的名称和描述符、方法的名称和描述符。</li></ol><p>注意，由于常量的个数是不固定的，所以需要在常量池前面预留两个字节表示常量池中常量个数（常量池计数器）</p><h3 id="4-字段">4. 字段</h3><p><img src="/java/jvm-a1fb6fd89ac6/image-20231103163823441.png" alt="字段"></p><p>字段很简单，就是存储源代码中类、接口中的字段名称、描述符、访问标志。</p><h3 id="5-方法">5. 方法</h3><p><img src="/java/jvm-a1fb6fd89ac6/image-20231103203406741.png" alt="方法"></p><p>方法就是源代码中的类和接口中声明的方法信息存放在了字节码文件里，但此时类和接口中的方法已经被编译为字节码指令。</p><p>每个方法中有 3 个部分，</p><ol><li>“Code” 区：源代码对应的字节码指令，在进行字节码增强时重点操作的区域。<ul><li>在 “Code” 区中除了字节码指令，还有异常表，在处理异常的时候使用。</li><li>还记录操作数栈的最大深度，局部变量最大槽数（即局部变量的个数），以及字节码指令的总行数（字节码长度）。</li></ul></li><li>“LineNumberTable”：行号表，将 Code 区的操作码与源代码中的行号对应，主要用于 Debug（决定了当源代码执行一行，JVM 指令执行多少行）</li><li>“LocalVariableTable”：本地变量表，实质是一个数组，<ul><li>对于非静态方法，索引 0 号位置默认为 this（所以在方法内部可以使用 this），接着是方法参数，最后是方法内的局部变量。</li><li>对于静态方法，由于不能使用 this，所以首先是方法参数，最后是方法内的局部变量。</li></ul></li></ol><p>那么下面重点关注字节码指令。以下面的代码为例，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.aman;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Method</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        i = i++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其编译后的字节码指令为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">0</span> iconst_0<br><span class="hljs-number">1</span> istore_1<br><span class="hljs-number">2</span> iload_1<br><span class="hljs-number">3</span> iinc <span class="hljs-number">1</span> by <span class="hljs-number">1</span><br><span class="hljs-number">6</span> istore_1<br><span class="hljs-number">7</span> <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><p>上面各个指令的含义：</p><ul><li>iconst_0：将常量 0 压入操作数栈。</li><li>istore_1：弹出当前操作数栈顶元素，存储在当前栈帧中，局部变量表 1 号索引处。</li><li>iload_1：将当前栈帧中，局部变量表 1 号索引处的元素 <strong>拷贝</strong> 到操作数栈。</li><li>iinc 1 by 1：将局部变量表中 1 号索引处的元素加 1</li><li>return：返回</li></ul><p>图示：</p><p><img src="/java/jvm-a1fb6fd89ac6/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4.gif" alt="字节码指令"></p><blockquote><p>字节码指令的查看：</p><ol><li>使用 jclasslib Bytecode Viewer 插件，右键指令后点击 “显示 JVM 规范” 会自动跳转到指令详情页面。</li><li>在 <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html">Java 虚拟机规范</a> 中查看</li></ol></blockquote><h3 id="6-属性">6. 属性</h3><p><img src="/java/jvm-a1fb6fd89ac6/image-20231103211356306.png" alt="属性"></p><p>属性很简单，就是存储源代码的名称、内部类列表等。</p><h3 id="7-查看字节码的工具">7. 查看字节码的工具</h3><p>1）上面所使用到的 Idea 插件：jclasslib Bytecode Viewer</p><p>2）Java 自带的工具 javap，可以通过控制台查看字节码文件的内容，适合在服务器上查看字节码文件。</p><ul><li>可以通过 <code>javap -help</code> 查看该命令的参数，一般使用 <code>javap -v</code> 即可。</li><li>需要先将 .java 源文件经过 javac 编译为 .class 文件，才能使用 javap 反编译。</li></ul><p>3）通过 arthas 获取正在运行时的字节码文件</p><blockquote><p>arthas  官网：<a href="https://arthas.aliyun.com/">arthas（aliyun.com）</a></p></blockquote><ul><li>使用 dump 命令将 JVM 中实际运行的 class 的字节码信息 dump 到指定目录，再使用 javap 将其反编译即可。</li><li>使用 jad 将 JVM 中实际运行的 class 的字节码反编译为 Java 代码（可能存在语法错误，但不影响阅读）。</li></ul><h2 id="类加载器">类加载器</h2><h3 id="1-类的生命周期">1. 类的生命周期</h3><h4 id="1-1-概述">1.1 概述</h4><p>类的生命周期描述了一个类从加载、使用、卸载的全过程。</p><p>主要包含 5 个阶段：</p><ol><li>加载（Loading）</li><li>连接（Linking），可细分为 <strong>验证、准备、解析</strong> 这三个阶段，所以也可以说类的生命周期是七个阶段</li><li>初始化（Initialization）</li><li>使用（Using）</li><li>卸载（Unloading）</li></ol><ul><li>其中 <strong>使用</strong> 就是平时我们写代码过程中通过 new 关键字或者反射操作创建对象并使用的过程，不再赘述。</li><li>而 <strong>卸载</strong> 主要和垃圾回收有关，在垃圾回收章节说明。</li></ul><p>所以在这里我们的重点就是 <strong>加载</strong>、<strong>连接</strong>、<strong>初始化</strong> 这三个阶段。</p><h4 id="1-2-加载">1.2 加载</h4><p><strong>在类的加载阶段</strong></p><p>1）首先类加载器根据类的全限定名（包名 + 类名），通过不同的渠道，以二进制流的方式将字节码信息加载到内存。</p><p>Java 虚拟机在设计时已经考虑到了扩展性，它允许通过不同的途径，读取字节码文件。如，</p><ul><li>最常见的就是将在磁盘上编译好的字节码文件加载进内存。</li><li>其次是一些框架，如 Spring，使用到的动态代理技术。在程序运行时，通过动态代理生成的类也需要被加载，这时类加载器就会根据类的全限定名，在内存中找到其二进制数据，将其读取到一块专门的内存区域中。</li><li>甚至可以通过网络将一个类传输过来，再通过类加载器加载到内存中，实际的应用场景就是早期的 applet 技术。</li></ul><p>2）接下里 Java 虚拟机会将字节码信息保存到一块专门的内存区域中，即方法区。</p><p>方法区只是 JVM 规范中设计的一个虚拟概念，每一款不同的 JVM，甚至 HotSport 虚拟机的不同版本，在设计方法区时都用到了不同的内存空间。比如像早期的 JDK 版本中，使用的永久代，而目前较新的版本使用的是元空间。</p><p>3）JVM 在回收到字节码信息后，会在方法区中生成一个对象（instanceKlass）来保存这些信息。</p><p>该 instanceKlass 对象保存了类的所有信息，还包括实现特定功能如 <strong>多态</strong> 的信息（虚方法表）。</p><p><img src="/java/jvm-a1fb6fd89ac6/image-20231103221655754.png" alt="instanceKlass"></p><p>4）JVM 除了在方法区中存放一份类的信息之外，还会在堆中也生成一份与方法区中数据类似的一个对象（Class 对象）。</p><p>主要作用是，在实现反射时，需要先获取类的基本信息，也就是 Class 对象，再通过它获取到该类的方法或字段，所以该 Class 对象存放在堆区，在类的加载阶段被创建，其包含的基本内容就有字段、方法等信息。</p><p>这两个对象（instanceKlass 和 Class）之间会通过一个引用彼此关联。</p><p>除此之外，在 JDK 8 之后，该 Class 对象还会存放一份静态字段的数据，如类中创建的静态变量，其真实数据就存放在当前对象里。</p><blockquote><p>当然在 JDK 8 之前，是存放在方法区。</p></blockquote><p><img src="/java/jvm-a1fb6fd89ac6/image-20231103222511779.png" alt="instanceKlass"></p><p>那么，整个加载阶段，主要是通过类加载器，将类的字节码信息加载到内存，并在方法区和堆区中分别创建一份对象以作后用。</p><p><strong>思考</strong></p><p>为什么需要在方法区和堆区中都创建一个对象，若不要堆区中的对象，只留下方法区中的对象，在反射的时候使用方法区中的信息，这样不是更节省内存吗？</p><ul><li>首先，方法区中的 instanceKlass 对象是使用 C++ 编写的对象，而 Java 代码不应该直接去操作该对象，所以 JVM 在堆区中专门创建一个 Class 对象，以便在 Java 代码中获取。</li><li>其次，Class 对象中的字段是少于 instanceKlass 对象中的字段，因为 instanceKlass 对象中的信息并不完全由 Java 开发者使用，如虚方法表，这是 JVM 在底层实现多态时使用的，对于 Java 开发者而言完全不需要使用，这样很好的控制了开发者访问数据的范围，保证了数据的安全性。</li></ul><p><strong>使用 HSDB 查看 Class 和 instanceKlass 中的信息</strong></p><p>使用 JDK 自带的 HSDB 工具查看 JVM 内存信息。工具是 JDK 8 的 lib 目录下的 sa-jdi.jar，其内部的启动类就是 HSDB 的启动类。</p><p>启动命令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">java -cp sa-jdi.jar sun.jvm.hotspot.HSDB<br></code></pre></td></tr></table></figure><p>测试程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HSDBDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">HSDBDemo</span>();<br>        System.in.read();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>可以使用 jps 查看正在运行的 Java 程序的进程 id。</p></blockquote><p>结果：</p><p><img src="/java/jvm-a1fb6fd89ac6/image-20231103225856543.png" alt="结果"></p><h4 id="1-3-连接">1.3 连接</h4><p>当加载阶段完成后，一个类或者接口的字节码信息就被加载到了内存中，接下来 JVM 开始进入连接阶段。</p><p>连接阶段主要做 3 件事：</p><ol><li>验证，主要是校验字节码的信息是否满足 Java 虚拟机规范。</li><li>准备，虽然在加载阶段，JVM 给对象分配了内存，但是静态变量还没有处理，所以该阶段主要是给静态变量分配内存并赋初值。</li><li>解析，将常量池中的符号引用替换为指向内存的直接引用，方便后续获取常量池中的信息。</li></ol><p>这三个阶段，总的来说，被称为连接阶段，做了一些校验和前期的准备工作，并不会执行代码。</p><h5 id="验证">验证</h5><p>校验字节码文件的内容是否符合 Java 虚拟机规范。</p><p>这个阶段一般不需要开发人员参与，了解一下常见的校验内容（真正的校验极为复杂，可能包含格式、信息、字节码、指令等），</p><ol><li>文件格式的校验，比如在字节码开头是否有魔数，主次版本号是否满足当前 JVM 运行环境</li><li>对元信息（基础信息）进行校验，如一个类，必须有父类</li><li>校验字节码指令中的语义是否正确，如字节码指令跳转时不能跳转到不存在的语句。</li><li>校验符号引用，如有没有访问其他类中的 private 方法。</li></ol><h5 id="准备">准备</h5><p>给静态变量分配内存，并且赋初值。</p><p>在下面的代码中，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>定义类 Student，存放一个静态变量 value，赋值为 1。</li><li>那么 JVM 在加载这个类的过程中，会在堆上创建一个 Class 的对象，并给 value 变量分配一块内存区域，将其赋初始值为 0。</li><li>注意是 0 而不是 1。这里初始值指的是变量的初始值（默认值），而将该 value 的值变为 1 是在下一个阶段（初始化阶段）。</li><li>其他类型，如 long 默认为 0L，short 默认为 0，char 默认为 ‘\u0000’，byte 默认为 0，boolean 默认为 false，double 默认为 0.0，引用数据类型默认为 null。</li><li>至于为什么需要赋初值为默认值，当静态变量只声明不赋初值的时候，即 <code>public static int value;</code>，若不将 value 赋初值为默认值 0，假如该内存区域有残留的值，那么输出 value 变量就会是随机值。</li></ul><p>但是对于 final 修饰的静态变量且是基本类型，如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>定义类 Student，存放静态常量 value，赋值为 1。</li><li>那么此时在堆上创建 Class 对象后，直接给 value 赋值为 1，而省略了上面赋初值为默认值 0 的过程。</li><li>这是因为，当使用 final 修饰，那么在编译阶段就可以确定 value 的值一定是 1。</li></ul><h5 id="解析">解析</h5><p>将常量池中的符号引用替换为指向内存的直接引用，方便后续获取常量池中的信息。</p><p>指向内存的直接引用性能较高，以后只要找到当前类的内存地址，就可以直接访问常量池的信息。</p><p>如，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HSDBDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">HSDBDemo</span>();<br>        System.in.read();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在字节码中，一般信息中展示了该类的父类索引，使用的是符号引用，即 cp_info #6，而在 HSDB 里面该类的父类的符号引用就被替换为内存地址（@0x00000007c0000f28）</p><p><img src="/java/jvm-a1fb6fd89ac6/image-20231103233124594.png" alt="符号引用"></p><p><img src="/java/jvm-a1fb6fd89ac6/image-20231103233056536.png" alt="内存地址"></p><h4 id="1-4-初始化">1.4 初始化</h4><h5 id="初始化">初始化</h5><p>在连接阶段结束后，类的信息已经被加载到了内存中，同时校验和前置的准备工作已经完成，那接下来就进入到与开发人员有关初始化的阶段。</p><p>在初始化阶段，会执行静态代码块中的代码，并为静态变量赋值，在字节码文件中体现在，&lt;clinit&gt; 方法。</p><p>以下面的类为例，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InitDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        value = <span class="hljs-number">2</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>查看其字节码中的方法：</p><p><img src="/java/jvm-a1fb6fd89ac6/image-20231103235430273.png" alt="clinit"></p><p>生成了 3 个方法，</p><ol><li>构造方法 &lt;init&gt;，虽然该类没有构造方法，但是编译器会自动生成无参的构造方法。</li><li>main 主方法。</li><li>类的初始化方法 &lt;clinit&gt;。</li></ol><p>主要关注 &lt;clinit&gt; 方法，其字节码指令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">0</span> iconst_1<br><span class="hljs-number">1</span> putstatic #<span class="hljs-number">2</span> &lt;com/aman/InitDemo.value : I&gt;<br><span class="hljs-number">4</span> iconst_2<br><span class="hljs-number">5</span> putstatic #<span class="hljs-number">2</span> &lt;com/aman/InitDemo.value : I&gt;<br><span class="hljs-number">8</span> <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><ul><li>iconst_1：将常量 1 压入操作数栈。</li><li>putstatic：将操作数栈顶的值赋给常量池中符号引用为 #2 的变量，即 com/aman/InitDemo.value</li><li>iconst_2：将常量 2 压入操作数栈。</li><li>putstatic：将操作数栈顶的值赋给常量池中符号引用为 #2 的变量，即 com/aman/InitDemo.value</li><li>return：返回。</li></ul><p>所以，总结 &lt;clinit&gt; 的作用：编译器会按从上到下的顺序，收集所有 static 静态代码块和静态变量赋值的代码，合并为一个特殊的方法，即 &lt;clinit&gt; 在类加载的初始化阶段被调用。</p><p>此外，说明 &lt;init&gt; 的作用：编译器按从上到下的顺序，收集所有实例代码块 <code>&#123;&#125;</code> 和非静态变量赋值的代码，以及类的构造方法，合并为 &lt;init&gt; 方法，注意，原始的构造方法内的代码总是在最后。</p><h5 id="触发类的初始化的方式">触发类的初始化的方式</h5><ol><li>访问一个类的静态变量或者静态方法，会触发类的初始化，但是若该变量用 final 修饰，并且等号右边是一个常量，那么在连接阶段就会直接给该变量赋常量值。</li><li>调用 Class.forName(String className) 方法，会触发类的初始化，注意在 Class 类的 forName 方法还有一个含 3 个参数的重载方法，其第二个参数为 initialize 的布尔值，可以用来决定是否让类初始化。</li><li>通过 new 关键字来创建一个对象，会触发类的初始化。</li><li>执行 main 方法的当前类，会触发类的初始化。</li></ol><blockquote><p>添加 -XX:+TraceClassLoading 虚拟机参数，可以打印出加载并初始化的类。</p></blockquote><p>示例：</p><p>1）访问某个类的静态变量或者静态方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">isInit</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Demo1.num = &quot;</span> + Demo1.num);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Demo1 被初始化了&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>说明：</p><ul><li>当 isInit 中 main 方法访问 Demo1.num，而 num 是非 final 的静态变量，则会导致 Demo1 的初始化，则输出静态代码块中的内容。</li><li>将 num 加上 final 修饰，则不会输出静态代码块中的内容。</li></ul><p>2）调用 Class.forName(String className) 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">isInit</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>        Class&lt;?&gt; clazz = Class.forName(<span class="hljs-string">&quot;com.aman.Demo2&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo2</span> &#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Demo2 被初始化了&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>说明：</p><ul><li>调用了 Class.forName(“com.aman.Demo2”) 方法，则会导致 Demo2 的初始化，则输出静态代码块中的内容。</li></ul><p>3）使用 new 关键字创建对象、执行 main 方法的类会被初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">isInit</span> &#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;isInit 被初始化了&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Demo3</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo3</span> &#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Demo3 被初始化了&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>说明：</p><ul><li>在 isInit 中使用 new 创建了 Demo3 的对象，而 isInit 类本身执行了 main 方法，则这两个类都会被初始化，则输出静态代码块中的内容，先输出 isInit，后输出 Demo3。</li></ul><h5 id="clinit-不会出现的情况">&lt;clinit&gt; 不会出现的情况</h5><ol><li>无静态代码块且无静态变量赋值语句。</li><li>有静态变量的声明但没有赋值语句。</li><li>静态变量的定义使用  final 关键字，该类变量会在准备阶段直接赋值。</li></ol><h5 id="存在继承关系的情况">存在继承关系的情况</h5><ol><li>直接访问父类的静态变量，不会触发子类的初始化。</li><li>子类的初始化 &lt;clinit&gt; 调用之前，会先调用父类的 &lt;clinit&gt; 初始化方法。</li></ol><h5 id="两个面试题">两个面试题</h5><p>1）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;A&quot;</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test1</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test1</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Test1</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;B&quot;</span>);<br>    &#125;<br><br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;C&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;D&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：DACBCB</p><ul><li>首先，进入 main 则必然初始化 Test1 类，则先执行静态代码块中的内容，输出 “D”，后输出 “A”</li><li>当 new Test1 对象，由于该类已经被初始化过，所以直接执行实例代码块和构造方法的内容，输出 “CBCB”</li></ul><p>2）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(A02.a);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A01</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        a = <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A02</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A01</span> &#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        a = <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：1</p><ul><li>虽然访问是 A02.a，但是 a 变量是继承自父类，相当于直接访问父类的静态变量，不会触发子类的初始化。</li></ul><h3 id="2-类加载器">2. 类加载器</h3><h4 id="2-1-概述">2.1 概述</h4><p>在类的生命周期的第一个阶段就是加载，在这个阶段使用的就是类加载器。</p><p>类加载器（ClassLoader）是 JVM 提供给应用程序去实现获取类和接口字节码数据的技术。</p><p>类加载器负责接收字节码文件，不管字节码文件从哪来（磁盘、网络传输、动态代理生成），当收到这些二进制数据后，类加载器就需要执行 JNI（本地接口调用），在方法区和堆区创建对象，保存字节码中的类和接口的信息。</p><p>所以，类加载器只是负责获取二进制的字节码信息，后续对象的创建还是交给 JVM 其他部分完成的。</p><p>Java 中类加载大部分是使用 Java 语言编写的，但是也有一些使用 C++ 语言编写，这些类加载就位于虚拟机的源码中。</p><p><img src="/java/jvm-a1fb6fd89ac6/image-20231104083658269.png" alt="类加载"></p><h4 id="2-2-类加载器的分类">2.2 类加载器的分类</h4><blockquote><p>类加载器在 JDK 8 ~ 9 变化巨大，这里先说明 JDK 8 的类加载器，后续说明 JDK 9。</p></blockquote><h5 id="概述">概述</h5><p><strong>类加载器分为两类</strong></p><p>1）虚拟机底层源码实现</p><p>其源码位于虚拟机的源码中，实现的语言和虚拟机一致。在虚拟机底层中有一个 <strong>启动类加载器（Bootstrap）</strong></p><p>其作用：加载编写 Java 程序需要用到的基础类、最核心的类，如 String 类，确保类被加载的可靠性。</p><p>2）Java 语言实现</p><p>JDK 源码中提供了许多不同作用的类加载器，开发人员也可以根据需要个性化定制（实现自定义类加载器）。</p><p>所有的类加载器都是继承自 ClassLoader 抽象类，如</p><p><img src="/java/jvm-a1fb6fd89ac6/image-20231104084438278.png" alt="ClassLoader"></p><p>在 Java 中，提供的类加载器有 2 种，</p><ul><li>扩展类加载器（Extension），主要用于扩展 Java 中的一些比较通用的类</li><li>应用程序类加载（Application），主要用于加载开发人员编写的类，以及引用的第三方 jar 包里的类。</li></ul><p><strong>查看类加载器</strong></p><p>使用 arthas 的 classloader 命令可以查看正在使用的类加载器。</p><p><img src="/java/jvm-a1fb6fd89ac6/image-20231104085854546.png" alt="classloader"></p><ol><li>BootstrapClassLoader，即启动类加载器。</li><li>ArthasClassLoader，arthas 类加载器。</li><li>ExtClassLoader，即扩展类加载器。</li><li>DelegatingClassLoader，JDK 底层用于提升反射效率的类加载器。</li><li>APPClassLoader，即应用程序类加载器。</li></ol><h5 id="启动类加载器">启动类加载器</h5><p>启动类加载器是由 HotSpot 虚拟机提供的，使用 C++ 编写的一款类加载器。</p><p>作用：加载 JDK 安装目录下 jre/lib 中的类文件，如 String 类就位于该文件中的 rj.jar 中。</p><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassLoaderTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> String.class.getClassLoader();<br>        System.out.println(classLoader); <span class="hljs-comment">// null</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>获取 String 类的类信息后再拿到它对应的类加载器，并打印，结果为 null。</li><li>由于启动类加载器位于虚拟机环境中，是偏向底层的应用，而 Java 程序偏向上层的应用，所以虚拟机并不允许在 Java 代码中获取到启动类加载器。</li><li>所以当获得的类加载器为 null 的时候，该类加载器可能就是启动类加载器。</li></ul><p><strong>扩展基础类</strong></p><p>如何让启动类加载器加载开发人员自定义的类？</p><p>使用 JVM 参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">-Xbootclasspath/a:jar 包目录/jar 包名<br></code></pre></td></tr></table></figure><p>那么，此时启动类加载器就会加载位于 <strong>jar 包目录/jar 包名</strong> 中的类。</p><h5 id="扩展、应用程序类加载器">扩展、应用程序类加载器</h5><p>扩展类加载器和应用程序加载器都是由 JDK 提供的、使用 Java 编写的类加载器。</p><p>源码位于 sun.misc.Launcher 中，是该类的静态内部类，继承自 URLClassLoader。</p><p><img src="/java/jvm-a1fb6fd89ac6/image-20231104093541460.png" alt="Launcher"></p><p>作用：通过目录或者指定 jar 包将字节码加载到内存中。</p><p>这两类加载器的继承关系：</p><p><img src="/java/jvm-a1fb6fd89ac6/image-20240118103441563.png" alt="继承关系"></p><ul><li>ClassLoader：抽象类，规范了类加载的步骤，即获取二进制字节码信息，调用 JVM 底层方法创建方法区和堆区的对象。</li><li>SecureClassLoader：使用证书机制提升类加载的安全性。</li><li>URLClassLoader：利用 URL 获取目录下或者指定 jar 包的字节码文件进行加载。</li><li>扩展、应用程序类加载器通过该继承体系，也有了上面各个类的功能。</li></ul><p><strong>扩展类加载器</strong></p><p>默认加载 JDK 安装目录下 jre\lib\ext 文件中的类文件，如 nashorn.jar（提供一整套 JavaScript 的运行环境）。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> jdk.nashorn.internal.runtime.ScriptEnvironment;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestExt</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> ScriptEnvironment.class.getClassLoader();<br>        System.out.println(classLoader); <span class="hljs-comment">// sun.misc.Launcher$ExtClassLoader@677327b6</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>如何让扩展类加载器加载开发人员自定义的类？</strong></p><p>使用 JVM 参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">-Djava.ext.dirs=jar 包目录<br></code></pre></td></tr></table></figure><p>注意：这种方式会覆盖到原始目录，在使用时需要追加上原始目录（Windows 环境中使用 <code>;</code> 隔开），如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">-Djava.etx.dirs=<span class="hljs-string">&quot;D:\environment\JDK8\jdk1.8.0_341\jre\lib\ext;D:\jvm\jar&quot;</span><br></code></pre></td></tr></table></figure><p><strong>应用程序类加载器</strong></p><p>加载 ClassPath 下的类文件，包括项目中编写的类和接口的文件，以及第三方 jar 包中类和接口的文件。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.mysql.jdbc.Driver; <span class="hljs-comment">// 引入 mysql-connector-java </span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestApp</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader1</span> <span class="hljs-operator">=</span> Student.class.getClassLoader();<br>        System.out.println(classLoader1); <span class="hljs-comment">// sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader2</span> <span class="hljs-operator">=</span> Driver.class.getClassLoader(); <br>        System.out.println(classLoader2); <span class="hljs-comment">// sun.misc.Launcher$AppClassLoader@18b4aac2</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="使用-arthas-查看">使用 arthas 查看</h5><ol><li>首先使用 classpath 命令获取类加载器的哈希码信息。</li><li>然后使用该哈希码输出该类加载所加载的路径。</li></ol><p>示例：</p><p><img src="/java/jvm-a1fb6fd89ac6/image-20231104100111868.png" alt="classloader"></p><h4 id="2-3-双亲委派机制">2.3 双亲委派机制</h4><p>如果虚拟机要去加载一个类，到底由哪个类加载器完成？这就需要使用 <strong>双亲委派机制</strong> 来解释。</p><p>首先明确类在被加载过程中最基本的要求：</p><ol><li>保证类加载的安全性。开发人员如果自定义了 java.lang.String，JVM 保证该类不能替换到 rj.jar 中的 String 核心类。</li><li>避免重复加载。减少在加载过程中的性能开销。</li></ol><p>在 ClassLoader 抽象类中，有一个 parent 属性，表示每一个类加载器都有一个父类加载器（启动类加载器除外）。</p><p><img src="/java/jvm-a1fb6fd89ac6/image-20231104101950889.png" alt="ClassLoader"></p><ul><li>应用程序类加载的父类加载器为 <strong>扩展类加载器</strong>。</li><li>扩展类加载器的父类加载器为 <strong>null</strong>。于是就有了下面的类加载器的层次结构图：</li></ul><p><img src="/java/jvm-a1fb6fd89ac6/image-20240118103719423.png" alt="层次结构"></p><p><strong>双亲委派机制</strong></p><ol><li>当一个类加载器去加载某个类时，会先自底向上查找父类加载器是否加载过，如果加载过就直接返回该类信息，如果一直到最顶层的类加载器都没有加载，再自顶向下进行加载。</li><li>应用程序类加载器的父类加载器是扩展类加载器，扩展类加载器没有父类加载器，但在双亲委派时会委派给启动类加载器。</li></ol><p>向上查找的机制保证只要其中一个类加载器加载过该类，则直接返回该类，避免重复加载。而向下委派的机制起到了加载优先级的作用，一个类优先由启动类加载器加载，它加载不了再交给扩展类加载器。</p><p>示例：</p><p>1）假设类 com.aman.Test 位于 classpath 下，且未被加载过</p><p><img src="/java/jvm-a1fb6fd89ac6/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6.gif" alt="双亲委派机制"></p><p>2）若开发人员自定义了 java.lang.String，则 JVM 保证该类不能替换到 rj.jar 中的 String 核心类。</p><p>![String 类加载](./JVM基础/String 类加载.gif)</p><p>3）自定义 java.lang.String，由 Application 类加载加载，看实际是由哪个类加载器加载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> java.lang;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以通过类加载器的 loadClass 方法指定某个类加载器加载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoadTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader1</span> <span class="hljs-operator">=</span> LoadTest.class.getClassLoader();<br>        System.out.println(classLoader1); <span class="hljs-comment">// sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><br>        Class&lt;?&gt; clazz = classLoader1.loadClass(<span class="hljs-string">&quot;java.lang.String&quot;</span>);<br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader2</span> <span class="hljs-operator">=</span> clazz.getClassLoader();<br>        System.out.println(classLoader2); <span class="hljs-comment">// null</span><br>        Field[] fields = clazz.getFields();<br>        System.out.println(Arrays.toString(fields)); <br>        <span class="hljs-comment">// [public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER]</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>classLoader2 为 null，说明即使自定义了 java.lang.String 类，JVM 还是会让启动类加载器加载。</li><li>且加载的 java.lang.String 是 rj.jar 中的 Java 核心类 String。</li></ul><p>4）使用 arthas 查看类加载器的继承关系</p><p>命令：<code>classloader - t</code></p><p><img src="/java/jvm-a1fb6fd89ac6/image-20231104105410974.png" alt="classloader"></p><p><strong>三个问题</strong></p><p>1）若一个类重复出现在三个类加载器，由谁加载？</p><p>由启动类加载器加载，根据双亲委派机制，它的优先级是最高的。</p><p>2）String 类可以被覆盖吗？</p><p>不能，会交由启动类加载器加载在 rj.jar 中的 String 类。</p><p>3）类加载器的关系？</p><p>应用程序类加载器的父类加载器是扩展类加载器，扩展类加载器没有父类加载器，但是会委派给启动类加载器。</p><h4 id="2-4-打破双亲委派机制">2.4 打破双亲委派机制</h4><p>在某些特定的情况下，需要打破双亲委派机制才能实现想要的功能。大致有 3 种方法，</p><ol><li>自定义类加载器。</li><li>线程上下文类加载器。</li><li>Osgi 框架的类加载器（略）。</li></ol><h5 id="自定义类加载器">自定义类加载器</h5><h6 id="应用场景">应用场景</h6><p>在 Tomcat 中，可以运行多个 Web 应用，假设当前 Tomcat 容器运行了两个 Web 应用，但是这两个应用中存放了相同全限定名的类，现在 Tomcat 要去加载这两个类，由于双亲委派机制的存在，势必只能加载其中一个类，而另一个会直接返回已加载的类信息。</p><p><img src="/java/jvm-a1fb6fd89ac6/image-20240121140456494.png" alt="Tomcat"></p><p>而 Tomcat 底层为每一个 Web 应用都单独生成了一个类加载器，且这些类加载不再使用双亲委派机制。</p><h6 id="分析双亲委派机制">分析双亲委派机制</h6><p>在 ClassLoader 抽象类中，有 4 个重要方法：</p><ol><li>public Class&lt;?&gt; loadClass(String name)：类加载的入口方法，提供了双亲委派机制，内部会调用 findClass 方法。</li><li>protected Class&lt;?&gt; findClass(String name)：由子类实现，获取二进制数据调用 defineClass，如 URLClassLoader 会根据文件路径获取类文件中的二进制数据。</li><li>protected final Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len)：做一些类名的校验，然后调用虚拟机底层的方法将字节码信息加载到内存中。</li><li>protected final void resolveClass(Class&lt;?&gt; c)：执行类生命周期中的连接阶段。</li></ol><p><strong>loadClass 方法</strong></p><p>两个重载方法，区别是否对类进行连接（即是否调用 resolveClass 方法），默认为 false。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-type">boolean</span> resolve)<br>    <span class="hljs-keyword">throws</span> ClassNotFoundException<br>&#123;<br>    <span class="hljs-comment">// 加锁保证线程安全</span><br>    <span class="hljs-keyword">synchronized</span> (getClassLoadingLock(name)) &#123;<br>        <span class="hljs-comment">// First, check if the class has already been loaded</span><br>        <span class="hljs-comment">// 首先检查该类是否已经被加载过, 若被加载过则进入 resolve 的判断, 然后返回</span><br>        Class&lt;?&gt; c = findLoadedClass(name);<br>        <span class="hljs-comment">// c == null 表示还未被加载</span><br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">t0</span> <span class="hljs-operator">=</span> System.nanoTime();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 若该类加载器的父类加载器不为 null 则递归调用父类加载器的 loadClass 方法</span><br>                <span class="hljs-comment">// 向上查找</span><br>                <span class="hljs-keyword">if</span> (parent != <span class="hljs-literal">null</span>) &#123;<br>                    c = parent.loadClass(name, <span class="hljs-literal">false</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 否则调用启动类加载器加载</span><br>                    <span class="hljs-comment">// 该方法内部调用 private native Class&lt;?&gt; findBootstrapClass(String name);</span><br>                    c = findBootstrapClassOrNull(name);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>                <span class="hljs-comment">// ClassNotFoundException thrown if class not found</span><br>                <span class="hljs-comment">// from the non-null parent class loader</span><br>            &#125;<br><br>            <span class="hljs-comment">// 此时若 c == null 表示父类加载器并没有加载成功, 则让当前类加载器尝试进行加载</span><br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// If still not found, then invoke findClass in order</span><br>                <span class="hljs-comment">// to find the class.</span><br>                <span class="hljs-type">long</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> System.nanoTime();<br>                <span class="hljs-comment">// 调用 findClass 方法, 该方法由子类实现</span><br>                c = findClass(name);<br><br>                <span class="hljs-comment">// this is the defining class loader; record the stats</span><br>                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);<br>                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);<br>                sun.misc.PerfCounter.getFindClasses().increment();<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 若 resolve 为 true 则进行连接</span><br>        <span class="hljs-keyword">if</span> (resolve) &#123;<br>            resolveClass(c);<br>        &#125;<br>        <span class="hljs-comment">// 返回</span><br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>defineClass 方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Class&lt;?&gt; defineClass(String name, <span class="hljs-type">byte</span>[] b, <span class="hljs-type">int</span> off, <span class="hljs-type">int</span> len,<br>                                     ProtectionDomain protectionDomain)<br>    <span class="hljs-keyword">throws</span> ClassFormatError<br>&#123;<br>    <span class="hljs-comment">// 进行校验工作</span><br>    protectionDomain = preDefineClass(name, protectionDomain);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">source</span> <span class="hljs-operator">=</span> defineClassSourceLocation(protectionDomain);<br>    <span class="hljs-comment">// private native Class&lt;?&gt; defineClass1(String name, byte[] b, int off, int len,</span><br>    <span class="hljs-comment">//                                      ProtectionDomain pd, String source);</span><br>    <span class="hljs-comment">// 本地方法, 交给虚拟机创建对象</span><br>    Class&lt;?&gt; c = defineClass1(name, b, off, len, protectionDomain, source);<br>    postDefineClass(c, protectionDomain);<br>    <span class="hljs-keyword">return</span> c;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="打破双亲委派机制">打破双亲委派机制</h6><p>经过上面的代码分析，打破双亲委派机制的关键就在 loadClass 方法上。</p><p>我们可以自定义类加载器，重写 loadClass 方法，自定义类加载时的逻辑，示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.apache.commons.io.IOUtils;<br><br><span class="hljs-keyword">import</span> java.io.File;<br><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.util.regex.Matcher;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BreakClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ClassLoader</span> &#123;<br>    <span class="hljs-keyword">private</span> String basePath;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">FILE_EXT</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;.class&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBasePath</span><span class="hljs-params">(String basePath)</span> &#123;<br>        <span class="hljs-built_in">this</span>.basePath = basePath;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] loadClassData(String name) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">tempName</span> <span class="hljs-operator">=</span> name.replaceAll(<span class="hljs-string">&quot;\\.&quot;</span>, Matcher.quoteReplacement(File.separator));<br>            <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(basePath + tempName + FILE_EXT);<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">return</span> IOUtils.toByteArray(fis);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                IOUtils.closeQuietly(fis);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;自定义类加载器失败, 原因: &quot;</span> + e.getMessage());<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 重写 loadClass 方法, 去掉双亲委派机制</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>        <span class="hljs-type">byte</span>[] data = loadClassData(name);<br>        <span class="hljs-keyword">return</span> defineClass(name, data, <span class="hljs-number">0</span>, data.length);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">BreakClassLoader</span> <span class="hljs-variable">loader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BreakClassLoader</span>();<br>        loader.setBasePath(<span class="hljs-string">&quot;D:\\jvm\\&quot;</span>);<br><br>        Class&lt;?&gt; clazz = loader.loadClass(<span class="hljs-string">&quot;java.lang.String&quot;</span>);<br>        clazz.newInstance();<br>        System.out.println(clazz);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>D:\jvm\</code> 下提前编写一个 java.lang.String 文件，通过 javac 编译为 class 文件。</p><p>运行代码：</p><p><img src="/java/jvm-a1fb6fd89ac6/image-20231104150131878.png" alt="运行"></p><p>报错的原因是包名 java.lang 不合法，在使用 defineClass 来创建方法区和堆区的对象时，在 ClassLoader 类中的 preDefineClass 方法中会进行校验，如果需要加载的类名以 java. 开头，则直接抛出安全性的异常（因为以 java 为前缀的类必须是由启动类加载器加载）。</p><p><img src="/java/jvm-a1fb6fd89ac6/image-20231104150444606.png" alt="运行"></p><p>所以使用自定义加载器加载 java.lang.String 是不可能成功的，再尝试另一个自定义的类 com.aman.Hello。</p><p>修改代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">BreakClassLoader</span> <span class="hljs-variable">loader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BreakClassLoader</span>();<br>    loader.setBasePath(<span class="hljs-string">&quot;D:\\jvm\\&quot;</span>);<br><br>    Class&lt;?&gt; clazz = loader.loadClass(<span class="hljs-string">&quot;com.aman.Hello&quot;</span>);<br>    clazz.newInstance();<br>    System.out.println(clazz);<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/java/jvm-a1fb6fd89ac6/image-20231104150850892.png" alt="运行"></p><p>报错：在该路径下找不到 Object.class，因为所有的类都继承自 Object 类，那么在文件中找不到 Object 的字节码就会报错。</p><p>修改代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>    <span class="hljs-keyword">if</span> (name.startsWith(<span class="hljs-string">&quot;java.&quot;</span>)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.loadClass(name);<br>    &#125;<br>    <span class="hljs-type">byte</span>[] data = loadClassData(name);<br>    <span class="hljs-keyword">return</span> defineClass(name, data, <span class="hljs-number">0</span>, data.length);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">BreakClassLoader</span> <span class="hljs-variable">loader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BreakClassLoader</span>();<br>    loader.setBasePath(<span class="hljs-string">&quot;D:\\jvm\\&quot;</span>);<br><br>    Class&lt;?&gt; clazz = loader.loadClass(<span class="hljs-string">&quot;com.aman.Hello&quot;</span>);<br>    clazz.newInstance();<br>    System.out.println(clazz); <span class="hljs-comment">// class com.aman.Hello</span><br>    System.out.println(clazz.getClassLoader()); <span class="hljs-comment">// com.aman.BreakClassLoader@70177ecd</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这一次就会成功的加载，而且加载该类的类加载器就是自定义类加载器。那么就成功的打破了双亲委派机制。</p><h6 id="两个小问题">两个小问题</h6><p>1）对于自定义类加载器，它的父类加载器是？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">BreakClassLoader</span> <span class="hljs-variable">loader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BreakClassLoader</span>();<br>    loader.setBasePath(<span class="hljs-string">&quot;D:\\jvm\\&quot;</span>);<br><br>    Class&lt;?&gt; clazz = loader.loadClass(<span class="hljs-string">&quot;com.aman.Hello&quot;</span>);<br>    clazz.newInstance();<br>    System.out.println(clazz); <span class="hljs-comment">// class com.aman.Hello</span><br>    System.out.println(clazz.getClassLoader()); <span class="hljs-comment">// com.aman.BreakClassLoader@70177ecd</span><br>    System.out.println(clazz.getClassLoader().getParent()); <br>    <span class="hljs-comment">// sun.misc.Launcher$AppClassLoader@18b4aac2</span><br>    System.out.println(getSystemClassLoader()); <span class="hljs-comment">// sun.misc.Launcher$AppClassLoader@18b4aac2</span><br>&#125;<br></code></pre></td></tr></table></figure><p>运行代码，可以发现，自定义类加载器的父类加载器为 Application 类加载器。</p><p>原因在于，ClassLoader 的构造方法的重载方法中，如果没有指定父类加载器，则默认为系统类加载器（即应用程序类加载器）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-title function_">ClassLoader</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>(checkCreateClassLoader(), getSystemClassLoader());<br>&#125;<br></code></pre></td></tr></table></figure><p>如果需要指定父类加载器，只需重写 ClassLoader 的构造方法，传递父类加载器即可。</p><p>2）如果两个自定义类加载器去加载一个相同全限定名的类，会不会冲突？</p><p>在同一个 Java 虚拟机中，只有相同的类加载器 + 相同的类全限定名，才会被认为是同一个类。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">BreakClassLoader</span> <span class="hljs-variable">loader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BreakClassLoader</span>();<br>    loader.setBasePath(<span class="hljs-string">&quot;D:\\jvm\\&quot;</span>);<br><br>    Class&lt;?&gt; clazz = loader.loadClass(<span class="hljs-string">&quot;com.aman.Hello&quot;</span>);<br>    clazz.newInstance();<br>    System.out.println(clazz); <span class="hljs-comment">// class com.aman.Hello</span><br>    System.out.println(clazz.getClassLoader()); <span class="hljs-comment">// com.aman.BreakClassLoader@70177ecd</span><br>    System.out.println(clazz.getClassLoader().getParent()); <br>    <span class="hljs-comment">// sun.misc.Launcher$AppClassLoader@18b4aac2</span><br>    System.out.println(getSystemClassLoader()); <span class="hljs-comment">// sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><br>    <span class="hljs-comment">// 拿到应用程序类加载器</span><br>    <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> BreakClassLoader.class.getClassLoader();<br>    Class&lt;?&gt; clazz2 = classLoader.loadClass(<span class="hljs-string">&quot;com.aman.Hello&quot;</span>);<br><br>    System.out.println(clazz == clazz2); <span class="hljs-comment">// false</span><br>&#125;<br></code></pre></td></tr></table></figure><h6 id="通过-arthas-查看类的详细信息">通过 arthas 查看类的详细信息</h6><p>命令：<code>sc -d 类的全限定名</code></p><p><img src="/java/jvm-a1fb6fd89ac6/image-20231104152357045.png" alt="sc"></p><h5 id="线程上下文类加载器">线程上下文类加载器</h5><h6 id="应用场景-2">应用场景</h6><p>线程上下文类加载器被广泛应用在 JDBC、JNDI 这样的技术中，下面以 JDBC 来说明 <strong>线程上下文类加载器</strong>。</p><p>对于 JDBC 这个框架，其目的是在 Java 中去操作数据库，在它设计的核心思想中，不希望出现某个特定数据库的语法，保持泛用性，这样将来对接任何的数据库都不会有较大的代码变动。</p><p>那么它是怎么做到这一点的？</p><ul><li>在 java.sql 包中有一个 DriverManager 类，该类会管理在 jar 包中引入的数据库驱动类，比如使用 MySQL 数据库，就需要添加 MySQL 的驱动， 而 DriverManager 会负责加载 MySQL 的 jar 包中的驱动累，这样就可以连接 MySQL 的数据库。</li><li>如果想连接 Oracle 数据库，那么只需把 jar 包替换成 Oracle 的 jar 包，由 DriverManager 去加载 Oracle 的 jar 包中驱动类。</li></ul><p>通过引入不同驱动的方式，DriverManager 就可以对接不同的数据库，且在代码层次它是统一的。</p><p>但 DriverManager 类去加载驱动 jar 包中的类的过程中，会发现它打破了双亲委派机制，具体：</p><ul><li>DriverManager 类是 rj.jar 中的类，属于 Java 的核心 jar 包，会由启动类加载器来进行加载。</li><li>而数据库的驱动类其实是由应用程序类加载器加载的，所以这里就产生了一个冲突。</li><li>在双亲委派机制中，应该是自底向上进行委派，而现在仿佛变成了自顶向下的委派。</li></ul><p><img src="/java/jvm-a1fb6fd89ac6/image-20240121140756638.png" alt="自顶向下的委派"></p><p>下面分析 DriverManager 是如何来实现这种向下委派的机制的？</p><h6 id="SPI-机制">SPI 机制</h6><p>DriverManager 位于 rj.jar，属于 JDK 的底层类，它是怎么知道引入了一个驱动 jar 包？</p><p>这就需要用到 JDK 的底层技术，SPI 机制，该机制也被大量用于如 dubbo 等框架。</p><p>简单来说，就是 JDK 提供了一种机制，当需要加载一个 <strong>接口的实现类对象</strong>，就可以通过 SPI 机制快速找到。</p><p>图示：</p><p><img src="/java/jvm-a1fb6fd89ac6/image-20240121141013535.png" alt="SPI"></p><p>当服务的提供者提供了一种接口的实现之后，需要在 classpath 下的 META-INF/services/ 目录里创建一个以服务接口命名的文件，该文件里的内容就是这个接口的具体的实现类。</p><p>当其他的程序需要这个服务的时候，就可以通过查找该 jar 包（一般都是以 jar 包做依赖）的 META-INF/services/ 中的配置文件，配置文件中有接口的具体实现类名，可以根据这个类名进行加载实例化，就可以使用该服务了。</p><p>在 JDK 中查找服务实现的工具类是：java.util.ServiceLoader。</p><p>以 MySQL 为例，MySQL 的驱动 jar 包需要暴露驱动类给 DriverManager 使用，在它的 jar 包中有一个固定的文件夹（即 META-INF/services），SPI 机制会主动扫描该文件夹的文件，文件名就是驱动类所实现的接口，文件的内容就是驱动类，即</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">com.mysql.cj.jdbc.Driver<br></code></pre></td></tr></table></figure><p><img src="/java/jvm-a1fb6fd89ac6/image-20231104160924602.png" alt="Driver"></p><p>在 MySQL 的 jar 包的源码中，这个驱动是在 com.mysql.cj.jdbc 包下的 Driver 类，它实现了 java.sql.Driver 接口。另外在静态代码块中将该类的对象创建出来注册到了 DriverManager  中，所以只要这个类被加载并初始化，那么注册驱动的过程完成了。</p><p><img src="/java/jvm-a1fb6fd89ac6/image-20231104161333899.png" alt="Driver"></p><p>现在准备工作已经做好，那么 DriverManager  就可以拿到当前实现类的类名，并且用类加载器加载它。</p><p>在 DriverManager 中的静态代码块中的 loadInitialDrivers 方法就是用来初始化驱动。</p><p><img src="/java/jvm-a1fb6fd89ac6/image-20231104162050780.png" alt="DriverManager"></p><p>在 loadInitialDrivers 方法内部会调用 ServiceLoader 的 load 方法，只需传递需要加载的接口，就会返回 ServiceLoader 对象，然后调用该对象的迭代器拿到当前类名，并创建对象。</p><p><img src="/java/jvm-a1fb6fd89ac6/image-20231104162134953.png" alt="load"></p><h6 id="通过线程上下文拿到类加载器">通过线程上下文拿到类加载器</h6><p>在上面的 ServiceLoader 的 load 方法中，使用当前线程上下文的类加载器，调试一下可以发现为 Application 类加载器。</p><p><img src="/java/jvm-a1fb6fd89ac6/image-20231104162627465.png" alt="load"></p><p>即我们也可以使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Thread.currentThread().setContextClassLoader(classLoader);<br>Thread.currentThread().getContextClassLoader();<br></code></pre></td></tr></table></figure><p>这两个方法获取或设置线程上下文类加载器。</p><h6 id="总结">总结</h6><ol><li>DriverManager 类位于 rt.jar 中，由启动类加载器进行加载。</li><li>而 DriverManager 需要拿到第三方 jar 包中对应的数据库的驱动，所以在底层使用了 SPI 这种服务发现机制，来找到对应 jar 包中的驱动。</li><li>而在 SPI 机制中的 ServiceLoader 类获取到了线程上下文的类加载器（在一个线程创建完后，虚拟机底层会将应用程序类加载器放入该线程上下文中）</li><li>DriverManager 使用 ServiceLoader 类返回的类加载器加载了 MySQL 的驱动。</li></ol><p>图示：</p><p><img src="/java/jvm-a1fb6fd89ac6/image-20240121141321115.png" alt="过程"></p><h6 id="真的打破双亲委派机制了吗">真的打破双亲委派机制了吗</h6><p>由于上面的例子中由启动类加载器委托应用程序类加载器加载 jar 包中的驱动类，与双亲委派机制中自底向上的进行委派的方式违背，所以说打破了双亲委派机制。</p><p>但是，在上面的案例中，DriverManager 是由启动类加载器加载的，而在 jar 包中的驱动类位于 classpath 下，由应用程序类加载器进行加载也是满足双亲委派机制的向上委派，向下尝试的过程的，所以从这方面来说并没有打破双亲委派机制。</p><p>在我认为，只有重写在 ClassLoader 类中的 loadClass 方法，去除掉双亲委派机制的逻辑，才算真正的打破双亲委派机制。</p><h4 id="2-5-JDK-9-之后的类加载器">2.5 JDK 9 之后的类加载器</h4><p>在 JDK 9 之前，扩展类加载器和应用程序类加载器的源代码都在 sun.misc.Launcher 类中，该类位于 rt.jar，这两个类加载器都继承自 URLClassLoader，可以通过某个特定的目录查找 jar 包以及 jar 包中的字节码文件。</p><p>所以本质上 JDK 9 之前的版本中都是按照 jar 包的位置去加载字节码文件。</p><p>但是在 JDK 9 之后，由于引入了模块化的概念，那么就会将 Java 中的类放到 jmod 文件中，如下：</p><p><img src="/java/jvm-a1fb6fd89ac6/image-20231104170923678.png" alt="jmod"></p><p>那么类加载器从原来在 jar 包中进行加载转变为从这些 jmod 文件中进行加载。</p><p>主要变化：</p><ol><li>启动类加载器（BootClassLoader）不再使用 C++ 编写，而是直接使用 Java 编写，是 jdk.internal.loader.ClassLoaders 类的静态内部类中，后面提及的其他类加载器也是该类的静态内部类。</li><li>启动类加载器会继承自 BuiltinClassLoader，实现了从 jmod 模块中找到要加载的字节码文件。</li><li>启动类加载器依然无法通过 Java 代码获取到，返回的仍然是 null，提高了类加载的安全性。</li><li>JDK 9 之前的 <strong>扩展类加载器</strong> 被替换为 <strong>平台类加载器</strong>（PlatformClassLoader），平台类加载器遵循模块化方式加载字节码文件，所以继承关系从 URLClassLoader 变为了 BuiltinClassLoader。平台类加载器的存在更多了为了与老版本的设计方案兼容，自身并没有特殊的逻辑。</li><li>JDK 9 之前的应用程序类加载器，只是继承关系发生了变化，还是应用程序类加载器（AppClassLoader）。</li></ol><h2 id="内存结构">内存结构</h2><h3 id="1-概述-2">1. 概述</h3><p>类加载器将字节码文件加载到内存中，会用到两块内存区域，即方法区和堆区。这两块区域都属于 JVM 管理的内存，由于 JVM 在运行过程中会使用这块内存，所以就称之为运行时数据区域。</p><p>Java 虚拟机规范中规定了运行时数据区域的中每个部分的作用，大致分为两大类：</p><ol><li>线程共享：方法区、堆区</li><li>线程不共享：程序计数器、Java 虚拟机栈、本地方法栈</li></ol><p><img src="/java/jvm-a1fb6fd89ac6/image-20240121141549362.png" alt="运行时数据区域"></p><p>所谓线程不共享，</p><ol><li>每当创建一个线程后，每一个线程内部都会有独属于该线程的程序计数器、Java 虚拟机栈以及本地方法栈，其他线程是不可能访问到当前线程的这些数据的。</li><li>由于不能共享，整体的安全性比较高，而且当线程运行结束后，可以直接将整个线程回收掉，该内存区域即得到释放。</li></ol><p>而线程共享，</p><ol><li>指的是每个线程都可以从方法区、堆区中放入、获取数据并使用。</li><li>但线程共享的区域存在线程安全问题，且对于 Java 来说，该区域的内存回收也是一个复杂的问题。</li></ol><h3 id="2-程序计数器">2. 程序计数器</h3><h4 id="2-1-概述-2">2.1 概述</h4><p>程序计数器（Program Counter Register）也叫做 PC 寄存器，每个线程会通过程序寄存器记录当前要执行的字节码指令的地址。</p><ol><li>首先字节码指令最初是保存在字节码文件中，当类加载器将字节码文件读取到内存后，这些指令就会保存在内存中，所以每一行指令应该有自己的内存地址。</li><li>而字节码指令最终要交给解释器去解释执行，所以解释器就需要知道要执行的字节码指令的位置，那么程序计数器就保存了当前要执行的字节码指令的地址，解释器在程序计数器中获取到该地址，就可以拿到对应的字节码指令来执行。</li></ol><h4 id="2-2-程序计数器作用">2.2 程序计数器作用</h4><p><strong>1）程序计数器可以控制程序指令的进行，实现分支、跳转、异常处理等逻辑</strong></p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PCTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;<br>            i--;<br>        &#125;<br>        i++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码转换为字节码指令为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-number">0</span> iconst_0<br> <span class="hljs-number">1</span> istore_1<br> <span class="hljs-number">2</span> iload_1<br> <span class="hljs-number">3</span> ifne <span class="hljs-number">9</span> (+<span class="hljs-number">6</span>)<br> <span class="hljs-number">6</span> iinc <span class="hljs-number">1</span> by -<span class="hljs-number">1</span><br> <span class="hljs-number">9</span> iinc <span class="hljs-number">1</span> by <span class="hljs-number">1</span><br><span class="hljs-number">12</span> <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><p>上面各个指令的含义：</p><ul><li>iconst_0：将常量 0 压入操作数栈</li><li>istore_1：弹出当前操作数栈顶元素，存储在当前栈帧中，局部变量表 1 号索引处。</li><li>iload_1：将当前栈帧中，局部变量表 1 号索引处的元素 <strong>拷贝</strong> 到操作数组栈。</li><li>ifne 9 (+6)：将操作数栈顶元素与 0 比较，如果相等则跳到 9 号位置执行，否则继续向下执行。</li><li>iinc 1 by -1：将局部变量表中 1 号索引处的元素减 1。</li><li>iinc 1 by 1：将局部变量表中 1 号索引处的元素加 1。</li><li>return：返回。</li></ul><p>·在加载阶段，虚拟机将字节码文件中的指令读取到内存后，将原来字节码文件中的偏移量转换为实际的内存地址。</p><p>在代码执行过程中，程序计数器会记录下一行字节码指令的地址，执行完当前指令之后，虚拟机的执行引擎根据程序计数器中的地址值执行下一行指令。</p><p><strong>2）在多线程执行时，JVM 需要通过程序计数器记录 CPU 切换时解释执行到的指令的内存地址。</strong></p><p>在多线程的情况下， CPU 在执行过程中，不是一致执行一个线程，它会在多个线程之间来的切换。</p><p>如果 CPU 从线程 a 切换到线程 b 就需要知道线程 b 的解释器解释到了哪一行指令，而程序计数器保存了接下来要执行的指令地址，那么只需要根据该地址取出指令，解释器就可以继续工作。</p><h4 id="2-3-会内存溢出吗">2.3 会内存溢出吗</h4><p>程序计数器在运行过程中会内存溢出吗？</p><p>内存溢出，指的是程序在使用某一块内存区域时，存放数据占用的内存超过了虚拟机能够提供的内存上限。</p><p>那么在程序计数器中，是不会发生内存溢出的，程序计数器只会保存一个固定长度的内存地址，也就是字节码指令的地址，那自然就不会发生内存的溢出。</p><h3 id="3-Java-虚拟机栈">3. Java 虚拟机栈</h3><h4 id="3-1-概述">3.1 概述</h4><p>Java 虚拟机栈，采用先进先出的栈作为数据结构，保存每一个方法调用时对应的信息，每一个方法的调用会使用一个栈帧（Stack Frame）来保存。</p><p>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StackTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        method01();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method01</span><span class="hljs-params">()</span> &#123;<br>        method02();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method02</span><span class="hljs-params">()</span> &#123;<br>        method03();<br>        System.out.println(<span class="hljs-string">&quot;method02&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method03</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;method03&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 Idea 中通过 debug 调试可以查看每个方法的栈帧</p><p><img src="/java/jvm-a1fb6fd89ac6/image-20231104203312875.png" alt="debug"></p><p>虚拟机栈的特点：</p><ol><li>每一个线程都拥有自己的栈，在栈中可以存放栈帧对应的数据。</li><li>虚拟机栈和线程的生命周期一致，当线程被销毁，则对应的栈空间也会被回收释放。</li><li>虚拟机栈中每一个栈帧都有 3 部分组成，<strong>局部变量表、操作数栈和帧数据</strong>。</li></ol><h4 id="3-2-局部变量表">3.2 局部变量表</h4><p>局部变量表：在运行过程中存放所有的局部变量，方法参数，若为实例方法则还存放 this 变量，在编译为字节码时，就可以确定局部变量表中的内容。</p><p>如，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LocalVarTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其局部变量表中的内容：</p><p><img src="/java/jvm-a1fb6fd89ac6/image-20231104204559115.png" alt="局部变量表"></p><ul><li>保存了 3 个变量：<code>this</code>、<code>j</code> 和 <code>i</code>。</li><li>Nr. 表示：局部变量的编号。</li><li>起始 PC 和长度：限制了该局部变量在字节码指令中有效的范围。</li><li>序号：局部变量表本质是一个数组，数组的每一个位置称为 slot 槽，在 Java 中，long 和 double 类型会占用 2 个槽，而其他包括引用类型的引用都只占 1 个槽，如上面 <code>j</code> 是 long 型变量会占据 1、2 号槽。</li><li>在局部变量表中还可以存放 this 变量和方法参数，存放顺序是：this 变量、方法参数、局部变量。</li><li>在局部变量表中，还存在复用性，一旦某个局部变量不再使用，则存放该变量的槽在方法运行时也可以被其他变量占用。</li></ul><p>示例：下面的方法中，在局部变量表中会占用几个槽？6 个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> m)</span> &#123;<br>    &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>    &#125;<br>    &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/java/jvm-a1fb6fd89ac6/image-20231104205457240.png" alt="槽数"></p><h4 id="3-3-操作数栈">3.3 操作数栈</h4><p>操作数栈（栈结构）是栈帧中虚拟机在执行指令的过程中，用来存放中间数据的一块内存区域。</p><p>在编译器就可以确定操作数栈的最大深度，从而在执行时正确的分配内存。</p><h4 id="3-4-帧数据">3.4 帧数据</h4><p>局部变量表和操作数栈，每一个虚拟机都是按照虚拟机规范去实现的。但帧数据与之不同，每一个虚拟机可以添加任意所需的数据，只介绍重要部分。</p><p>1）动态链接</p><p>当类的字节码指令引用了其他类的属性或者方法时，需要将符号引用（编号）转换为对应的运行时常量池中的内存地址，而动态链接就保存了 <strong>符号引用</strong> 到 <strong>运行时常量池的内存地址的映射关系</strong>。</p><p>2）方法出口</p><p>方法出口指的是方法在正确或者异常结束时，当前栈帧会被弹出，同时程序计数器应该指向上一个栈帧中的下一条指令的地址，所以在当前栈帧中，需要存储此方法出口的地址。</p><p>3）异常表的引用</p><p>异常表，存放是代码中异常的处理信息，这块信息在编译期就可以确定，主要包含的是 try、catch 代码块，在异常发生以及异常不发生的情况下，代码跳转的位置，JVM 在执行字节码指令的过程中就可以快速跳转。</p><h4 id="3-5-栈内存溢出">3.5 栈内存溢出</h4><p>Java 虚拟机栈中，如果栈帧过多，占用的内存超过栈内存可以分配的最大大小就会出现内存溢出，抛出 StackOverflowError 错误。</p><p>如果不知道栈的大小 ，则 JVM 将创建一个具有默认大小的栈，该大小取决于操作系统和计算机的体系结构。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StackOverTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recursion</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(++count);<br>        recursion();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        recursion();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/java/jvm-a1fb6fd89ac6/image-20231104211342232.png" alt="栈内存溢出"></p><p>在 10691 次发生了栈内存溢出。</p><p><strong>可以使用虚拟机参数设置虚拟机栈的大小</strong></p><p>命令：<code>-Xss栈大小</code> 或者 <code>-XX:ThreadStackSize=栈大小</code></p><p>单位：字节（默认，必须是 1024 的倍数）、k 或者 K、m 或者 M、g 或者 G。</p><p>注意：</p><ol><li>HotSpot 虚拟机对栈大小的最大值和最小值的要求：<ul><li>Windows（64 位）下 JDK 8 最小值为 180k，最大值为 1024m。</li></ul></li><li>局部变量过多，操作数栈深度过大都可能会导致栈的溢出。</li><li>一般情况，即使使用递归，栈的深度最多也只能到几百左右，不会出现栈的溢出，故可设置为 <code>-Xss256k</code> 以节省内存。</li></ol><h3 id="4-本地方法栈">4. 本地方法栈</h3><p>本地方法栈（Native Method Stack）与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务，也就是为 Java 虚拟机调用本地方法所提供的内存空间，就是本地方法栈。</p><p>在虚拟机规范中对本地方法栈中方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如 HotSpot 虚拟机）直接就把本地方法栈和虚拟机栈合二为一。</p><p>本地方法栈区域也会抛出 StackOverflowError 和 OutOfMemoryError 异常。</p><h3 id="5-堆区">5. 堆区</h3><h4 id="5-1-概述">5.1 概述</h4><p>在一般的 Java 程序，堆内存应该是空间占用最大的一块内存区域。</p><p>我们在程序中创建出来的对象都位于堆上，而栈中的局部变量表上存放了堆中对象的引用，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HeapTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Teacher</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>();<br>        t1.setName(<span class="hljs-string">&quot;张三&quot;</span>);<br>        t1.setAge(<span class="hljs-number">20</span>);<br>        t1.setId(<span class="hljs-number">1</span>);<br><br>        <span class="hljs-type">Teacher</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>();<br>        t2.setName(<span class="hljs-string">&quot;李四&quot;</span>);<br>        t2.setAge(<span class="hljs-number">23</span>);<br>        t2.setId(<span class="hljs-number">2</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其内存划分：</p><p><img src="/java/jvm-a1fb6fd89ac6/image-20240121142220376.png" alt="内存划分"></p><p>而静态变量也可以存放堆对象的引用，那么通过静态变量就可以实现对象在线程之间进行共享。</p><h4 id="5-2-堆内存溢出">5.2 堆内存溢出</h4><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HeapOver</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        ArrayList&lt;Object&gt; objects = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            objects.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">5</span>]);<br>            Thread.sleep(<span class="hljs-number">10</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/java/jvm-a1fb6fd89ac6/image-20231104214126404.png" alt="堆内存溢出"></p><h4 id="5-3-堆内存的管理">5.3 堆内存的管理</h4><p>在堆内存中，需要关注 3 个值：used、total 和 max</p><ol><li>used：当前已经使用的堆内存。</li><li>total：Java 虚拟机已经分配的可用的堆内存。</li><li>max：Java 虚拟机可以分配的最大堆内存。</li></ol><blockquote><p>在 arthas 中，通过命令：dashboard 或者 memory 可以查看这 3 个值。</p></blockquote><p>used、total 和 max 的变化情况：</p><ol><li>随着堆中的对象增多，当 used 大于 total 时，Java 虚拟将会继续为堆分配内存，即增大 total 的值。</li><li>随着 total 的增大，当 total 增大到某个阈值，就会出现堆内存溢出（堆内存溢出的判断条件较为复杂，在垃圾回收器中解释）。</li></ol><p>如果不设置任何虚拟机参数，max 默认是系统内存的 1/4，total 默认是系统内存的 1/64。如何设置这两个值？</p><p>使用虚拟机参数：<code>-Xmx值</code> 设置 max 值，<code>-Xms值</code> 设置初始 total 值。</p><ul><li>单位：字节（默认，必须是 1024 的整数倍）、k 或者 K、m 或者 M、g 或者 G</li><li>限制：Xmx 必须大鱼板 2Mb，Xms 必须大于 1Mb。</li></ul><p>如：设置如下虚拟机参数，然后在 arthas 中使用 memory 命令查看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">-Xmx2g -Xms2g<br></code></pre></td></tr></table></figure><p><img src="/java/jvm-a1fb6fd89ac6/image-20231104220843375.png" alt="memory"></p><p>但是为什么设置了 2g 内存，在 arthas 中只有 1963m？</p><ul><li>arthas 中的获取堆内存的技术是 JMX，这种方法与垃圾回收器有关，计算的是 <strong>可分配对象的内存</strong>，而不是整个内存。</li></ul><p>在 Java 服务端程序开发时，建议将 <code>-Xmx</code> 和 <code>-Xms</code> 设置为相同的值，这样程序启动之后可使用的总内存就是最大内存，而无需向虚拟机再次申请，减少了申请并分配内存的时间开销，同时也不会出现内存过剩之后堆收缩的情况。</p><h3 id="6-方法区">6. 方法区</h3><h4 id="6-1-概述">6.1 概述</h4><p>方法区是一块线程共享的区域，每一个线程都可以去获取方法区中共享的数据。</p><p>主要存放，</p><ol><li>类的元信息，即类的基本信息。</li><li>运行时常量池，保存了字节码文件中的常量池。</li><li>字符串常量池（不同版本有差异）。</li></ol><p><strong>方法区的具体实现</strong></p><p>方法区只是 JVM 规范中设计的一个虚拟的概念，每一款 JVM 在实现上都各不相同，甚至对于 HotSpot 这款虚拟机来说，它的不同版本在实现方法区上用到的技术都有可能是不同的。</p><ul><li>在 JDK 7 及之前的版本，方法区位于堆中，这块空间被称为 <strong>永久代</strong>，堆的大小由虚拟机参数控制。</li><li>在 JDK 8 及之后的版本，方法区位于元空间，而元空间位于操作系统所维护的 <strong>直接内存</strong> 中，默认情况下只要不超过操作系统的上限就可以一直分配，可以使用 <code>-XX:MaxMetaspaceSize=值</code> 将元空间最大内存进行限制。</li></ul><p>所以，方法区是一个虚拟的概念，在 HotSpot 中实现的方式有两种，一种是永久代，另外一种就是元空间。</p><p>注意：静态变量的存放位置</p><ul><li>在 JDK 6 及之前的版本，静态变量存放在方法区中，也就是永久代。</li><li>在 JDK 7 及之后的版本，静态变量存放在堆中的 Class 对象中，脱离了永久代。</li></ul><h4 id="6-2-方法区内存溢出">6.2 方法区内存溢出</h4><p>通过 ByteBuddy 框架动态生成字节码数据，加载到内存中，观察方法区是否会出现内存溢出的情况。</p><p>1）引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>net.bytebuddy<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>byte-buddy<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.12.23<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2）示例</p><p>JDK 8</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodOver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ClassLoader</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">MethodOver</span> <span class="hljs-variable">methodOver</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MethodOver</span>();<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Class&quot;</span> + count;<br>            <span class="hljs-type">ClassWriter</span> <span class="hljs-variable">classWriter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassWriter</span>(<span class="hljs-number">0</span>);<br>            classWriter.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC, name, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;java/lang/Object&quot;</span>, <span class="hljs-literal">null</span>);<br>            <span class="hljs-type">byte</span>[] bytes = classWriter.toByteArray();<br>            methodOver.defineClass(name, bytes, <span class="hljs-number">0</span>, bytes.length);<br>            System.out.println(++count);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="/java/jvm-a1fb6fd89ac6/image-20231104224349006.png" alt="方法区内存溢出"></p><p>JDK 7</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodOver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ClassLoader</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">MethodOver</span> <span class="hljs-variable">methodOver</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MethodOver</span>();<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Class&quot;</span> + count;<br>            <span class="hljs-type">ClassWriter</span> <span class="hljs-variable">classWriter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassWriter</span>(<span class="hljs-number">0</span>);<br>            classWriter.visit(Opcodes.V1_7, Opcodes.ACC_PUBLIC, name, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;java/lang/Object&quot;</span>, <span class="hljs-literal">null</span>);<br>            <span class="hljs-type">byte</span>[] bytes = classWriter.toByteArray();<br>            methodOver.defineClass(name, bytes, <span class="hljs-number">0</span>, bytes.length);<br>            System.out.println(++count);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="/java/jvm-a1fb6fd89ac6/image-20231104230352005.png" alt="永久代内存溢出"></p><p>从两个结果对比可以看出：</p><ol><li>JDK 8 的方法区由于在操作系统维护的直接内存，那么可分配的内存很大，足足执行了上百万次才发生内存溢出，同时可以看出方法区在元空间。</li><li>JDK 7 的方法是在堆中，可分配的内存较操作系统更少，故执行就发生了内存溢出，同时可以看出方法区在永久代。</li></ol><p>在 JDK 8 中，虽然可用的内存很多，但是可能由于不正确代码导致方法区占用内存过大，导致达到操作系统的内存上限，可能把其他程序的内存资源占用，会影响整个服务器上程序的运行。</p><p>所以建议在启动程序的时候，给元空间设置一个最大的内存。</p><h4 id="6-3-类的元信息">6.3 类的元信息</h4><p>在类的加载阶段，JVM 通过类加载器将类的字节码信息读取到内存中，并且创建了 instanceKlass 对象，将字节码信息中的基本信息、常量池、字段和方法以及多态的基础，虚方法表等全部存放在该对象中。</p><p>当然，真正虚拟机在实现时，会将常量池和方法单独使用一块内存存放，而在 instanceKlass 中只是存放这两者的引用。</p><h4 id="6-4-运行时常量池">6.4 运行时常量池</h4><p>在字节码信息中，其中一块就是常量池，在类的加载阶段会被读取到内存中，这时由原来的静态常量池就变为了运行时常量池。</p><p>字节码文件中通过编号查表的方式找到常量，这种常量池称为静态常量池。当常量池加载到内存中之后，可以通过内存地址快速的定位到常量池中的内容，这种常量池称为运行时常量池，这种通过内存地址去访问数据的方式性能会比较好。</p><h4 id="6-5-字符串常量池">6.5 字符串常量池</h4><blockquote><p>StringTable</p></blockquote><h5 id="概述-2">概述</h5><p>字符串常量池（StringTable），存放的就是在源代码中定义的常量字符串。</p><p>StringTable 实际上是一个固定大小的 HashTable。因此被称为 StringTable。</p><p>其长度不能像 HashMap 那样动态扩容。因此，如果 hash 冲突，那么它只能采取拉链法来解决，那么这样带来的坏处就是，随着链表长度的增加，StringTable 中检索的时间复杂度会增加。这样会造成其性能急剧下降。</p><p>虽然在 JDK 8 版本中默认长度为 60013，但是如果某些特殊应用造成 StringTable 中链表的长度不断增加的话，势必会影响性能。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringTableTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;abc&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;<br>        System.out.println(s1 == s2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在上述代码编译为字节码后，“abc” 会直接加入常量池（字节码文件中的），而当该字节码被读取到内存后，“abc” 字符串就会被加入到 StringTable 中。</li><li>而由于该字符串对象是通过 new 关键字创建，所以该对象也会放在堆中，在栈中使用 S1 这个局部变量保存堆中的地址。</li><li>那么第二句代码并没有通过 new 关键字去创建新的对象，所以 S2 这个局部变量存放的是 StringTable 中的 “abc” 的地址。</li><li>输出结果应该为 false。</li></ul><p>所以，StringTable 中存放的内容，其实就是通过字节码文件读取到的静态常量池中的字符串。</p><h5 id="StringTable-和运行时常量池的关系">StringTable 和运行时常量池的关系</h5><p>在最早的时候，StringTable 是属于运行时常量池的一部分，因为运行时常量池除了存放字符串的常量外，还会存放如类名的常量、整数的常量，它们存储的位置是一样的。</p><p>但在后续的 JDK 版本过程中做出了调整，将 StringTable 和运行时常量池做了拆分。大致分为 3 个阶段。</p><ol><li>在 JDK 7 之前，运行时常量池包含了 StringTable，所以这两部分内容应该位于永久代。</li><li>在 JDK 7 时，StringTable 从运行时常量池中分离，单独存放在堆中。</li><li>在 JDK 7 之后，由于永久代不再使用，而是用元空间替代，所以 StringTable 还在堆中，而运行时常量时被移动到元空间，所以现在可以认为 StringTable 和运行时常量池不是一个东西了。</li></ol><h5 id="面试题">面试题</h5><p>1）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringTableTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;2&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;12&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> a + b;<br>        System.out.println(c == d); <span class="hljs-comment">// false</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其字节码指令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-number">0</span> ldc #<span class="hljs-number">2</span> &lt;<span class="hljs-number">1</span>&gt;<br> <span class="hljs-number">2</span> astore_1<br> <span class="hljs-number">3</span> ldc #<span class="hljs-number">3</span> &lt;<span class="hljs-number">2</span>&gt;<br> <span class="hljs-number">5</span> astore_2<br> <span class="hljs-number">6</span> ldc #<span class="hljs-number">4</span> &lt;<span class="hljs-number">12</span>&gt;<br> <span class="hljs-number">8</span> astore_3<br> <span class="hljs-number">9</span> <span class="hljs-keyword">new</span> #<span class="hljs-number">5</span> &lt;java/lang/StringBuilder&gt;<br><span class="hljs-number">12</span> dup<br><span class="hljs-number">13</span> invokespecial #<span class="hljs-number">6</span> &lt;java/lang/StringBuilder.&lt;init&gt; : ()V&gt;<br><span class="hljs-number">16</span> aload_1<br><span class="hljs-number">17</span> invokevirtual #<span class="hljs-number">7</span> &lt;java/lang/StringBuilder.append : (Ljava/lang/String;)Ljava/lang/StringBuilder;&gt;<br><span class="hljs-number">20</span> aload_2<br><span class="hljs-number">21</span> invokevirtual #<span class="hljs-number">7</span> &lt;java/lang/StringBuilder.append : (Ljava/lang/String;)Ljava/lang/StringBuilder;&gt;<br><span class="hljs-number">24</span> invokevirtual #<span class="hljs-number">8</span> &lt;java/lang/StringBuilder.toString : ()Ljava/lang/String;&gt;<br><span class="hljs-number">27</span> astore <span class="hljs-number">4</span><br><span class="hljs-number">29</span> getstatic #<span class="hljs-number">9</span> &lt;java/lang/System.out : Ljava/io/PrintStream;&gt;<br><span class="hljs-number">32</span> aload_3<br><span class="hljs-number">33</span> aload <span class="hljs-number">4</span><br><span class="hljs-number">35</span> if_acmpne <span class="hljs-number">42</span> (+<span class="hljs-number">7</span>)<br><span class="hljs-number">38</span> iconst_1<br><span class="hljs-number">39</span> goto <span class="hljs-number">43</span> (+<span class="hljs-number">4</span>)<br><span class="hljs-number">42</span> iconst_0<br><span class="hljs-number">43</span> invokevirtual #<span class="hljs-number">10</span> &lt;java/io/PrintStream.println : (Z)V&gt;<br><span class="hljs-number">46</span> <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><ul><li>源代码被加载后，“1”、“2”、“12” 就被加入到了 StringTable，所以 c 是 StringTable 中 “12” 的地址。</li><li>而 <code>d = a + b</code> 底层会调用 StringBuilder 创建一个新的对象，d 是该对象在堆中的地址。</li><li>所以结果为 false。</li></ul><p>解答类似题目时，需要分析清楚在局部变量表中存放的对象的地址是在 StringTable 中还是在堆中。</p><p>2）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringTableTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;2&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;12&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1&quot;</span> + <span class="hljs-string">&quot;2&quot;</span>;<br>        System.out.println(c == d); <span class="hljs-comment">// true</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其字节码指令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-number">0</span> ldc #<span class="hljs-number">2</span> &lt;<span class="hljs-number">1</span>&gt;<br> <span class="hljs-number">2</span> astore_1<br> <span class="hljs-number">3</span> ldc #<span class="hljs-number">3</span> &lt;<span class="hljs-number">2</span>&gt;<br> <span class="hljs-number">5</span> astore_2<br> <span class="hljs-number">6</span> ldc #<span class="hljs-number">4</span> &lt;<span class="hljs-number">12</span>&gt;<br> <span class="hljs-number">8</span> astore_3<br> <span class="hljs-number">9</span> ldc #<span class="hljs-number">4</span> &lt;<span class="hljs-number">12</span>&gt;<br><span class="hljs-number">11</span> astore <span class="hljs-number">4</span><br><span class="hljs-number">13</span> getstatic #<span class="hljs-number">5</span> &lt;java/lang/System.out : Ljava/io/PrintStream;&gt;<br><span class="hljs-number">16</span> aload_3<br><span class="hljs-number">17</span> aload <span class="hljs-number">4</span><br><span class="hljs-number">19</span> if_acmpne <span class="hljs-number">26</span> (+<span class="hljs-number">7</span>)<br><span class="hljs-number">22</span> iconst_1<br><span class="hljs-number">23</span> goto <span class="hljs-number">27</span> (+<span class="hljs-number">4</span>)<br><span class="hljs-number">26</span> iconst_0<br><span class="hljs-number">27</span> invokevirtual #<span class="hljs-number">6</span> &lt;java/io/PrintStream.println : (Z)V&gt;<br><span class="hljs-number">30</span> <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><ul><li>这一次 c 和 d 都是常量池中 “12” 的地址，所以输出 true。</li></ul><p>3）关于 intern 方法</p><p>之前 StringTable 中的内容都是通过源代码中的常量来进行定义的，而 intern 方法允许手动将字符串放入到 StringTable 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringTableTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>().append(<span class="hljs-string">&quot;think&quot;</span>).append(<span class="hljs-string">&quot;123&quot;</span>).toString();<br>        System.out.println(s1.intern() == s1);<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>().append(<span class="hljs-string">&quot;ja&quot;</span>).append(<span class="hljs-string">&quot;va&quot;</span>).toString();<br>        System.out.println(s2.intern() == s2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果：</p><ul><li>在 JDK 6 中结果为 false、false。</li><li>在 JDK 8 中结果为 true、false。</li></ul><p>造成的原因：</p><ul><li>在 JDK 6 时，使用 intern 方法会将该字符串对象尝试放入 StringTable，如果有则并不会放入，如果没有则会把此对象 <strong>拷贝</strong> 一份放入 StringTable，然后将 StringTable 中的对象返回。</li><li>而在 JDK 8 时，由于字符串常量池在堆中，为了节省空间，使用 intern 方法会将该字符串对象尝试放入 StringTable，如果有则并不会放入，如果没有则仅仅会放入该对象的 <strong>引用</strong> 到 StringTable。</li><li>区别在于：将堆中新创建的字符串对象拷贝到 StringTable 还是放入其引用。</li></ul><h5 id="StringTable-的回收">StringTable 的回收</h5><p>StringTable 会受到垃圾回收器管理的，当内存空间不足时，StringTable 中那些没有被引用的字符串常量也会被回收。</p><p>先来看几个虚拟机参数的设置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">-Xmxsize -- 用来指定虚拟机堆内存的最大值;<br>-XX:+PrintStringTableStatistics -- 打印字符串表的统计信息，可以看到串池中的字符串的个数等信息;<br>-XX:+PrintGCDetails -verbose:gc -- 打印垃圾回收的详细信息，包括次数，时间等;<br></code></pre></td></tr></table></figure><p>下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 演示垃圾回收</span><br><span class="hljs-comment">// JVM 参数：-Xmx10m -XX:+PrintStringTableStatistics -XX:+PrintGCDetails -verbose:gc</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringTableTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            System.out.println(i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么来解读一下控制台打印的内容：</p><p><img src="/java/jvm-a1fb6fd89ac6/image-20230707140735001.png" alt="控制台输出"></p><p>StringTable 底层 HashTable 的实现，是由数组 + 链表的结构，每个数组就称为一个桶，那么根据上面的信息，默认的桶（buckets）个数是 60013，entries 就是其中的键值对的个数为 1755，而 literals 就是其中的字符串常量的个数，也就是 1789，后面还展示了一些占用的字节大小信息。</p><p>上面的代码什么也没有做，但在 StringTable 里面就已经有了 1755 个字符串对象，这是因为 Java 程序在运行时的一些类名、方法名等也会存入 StringTable。</p><p>改动代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 演示垃圾回收</span><br><span class="hljs-comment">// JVM 参数：-Xmx10m -XX:+PrintStringTableStatistics -XX:+PrintGCDetails -verbose:gc</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringTableTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 循环 100 次, 产生 100 个字符串对象存入串池中</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">100</span>; j++) &#123;<br>                String.valueOf(j).intern();<br>                i++;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            System.out.println(i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/java/jvm-a1fb6fd89ac6/image-20230707140844654.png" alt="控制台输出"></p><p>此时 entries 和 literals 的数量变为了 1870，这是因为在串池中新加了 100 个字符串对象，此时也不会引发垃圾回收。</p><p>接着将 <code>j</code>  变量的循环次数改为 10000 次，再次运行查看结果：</p><p><img src="/java/jvm-a1fb6fd89ac6/image-20230707141002927.png" alt="控制台输出"></p><p>注意：</p><ol><li>首先循环 10000 次，就是在串池中新加了 10000 个字符串对象。</li><li>那么正常来说 entries 和 literals 应该是 10000+，但此时却是 7849，因为触发了垃圾回收（见打印信息），将一些无用的字符串对象回收了。</li></ol><h5 id="StringTable-性能调优">StringTable 性能调优</h5><p>1）设置桶的个数</p><p>StringTable 的底层是一种 HashTable 的结构，那么 HashTable 的性能是跟它的桶的个数密切相关的，如果桶的个数比较多，元素相对分散，那么发生哈希碰撞的几率就会减少，查找的效率就会很快，反之，如果桶的个数较少，那么发的哈希碰撞的几率会增大，导致链表较长，从而查找的速率就会很慢。</p><p>所以可以通过设置 JVM 参数 <code>-XX:StringTableSize=桶个数</code> 来更改桶的个数，从而加快查找效率。</p><p>总结：如果程序里面字符串常量比较多的话，那么就可以适当增多桶的个数，让其有一个更好的哈希分布，减少哈希冲突。</p><p>2）考虑将字符串对象入池</p><p>对于程序中一些大量的重复的字符串对象，可以考虑将这些字符串对象存入串池，去除重复的对象，减少字符串对内存的占用。</p><h3 id="7-直接内存">7. 直接内存</h3><h4 id="7-1-概述">7.1 概述</h4><p>直接内存（Direct Memory）：并不属于 JVM 虚拟机的内存管理，而是属于操作系统的内存</p><ul><li>常见于 NIO 操作时，用于数据缓冲区，比如 ByteBuffer 被分配的内存就是直接内存</li><li>分配回收成本较高，但读写性能高，因为直接内存属于操作系统的内存，Java 程序分配或者释放直接内存就会慢一些，但是其读写性能非常高。</li><li>不受 JVM 内存回收管理</li></ul><h4 id="7-2-直接内存的读写效率">7.2 直接内存的读写效率</h4><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DirectMemory</span> &#123;<br>    <span class="hljs-comment">// 视频文件大小约 2.55 GB</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">FROM</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;D:\\movie.mp4&quot;</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">TO</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;D:\\jvm\\movie.mp4&quot;</span>;<br>    <span class="hljs-comment">// 读写缓冲区的大小都设为 1MB</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">_1MB</span> <span class="hljs-operator">=</span> <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        io();<br>        directBuffer();<br>    &#125;<br><br>    <span class="hljs-comment">// 使用 ByteBuffer 分配直接内存</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">directBuffer</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.nanoTime();<br>        <span class="hljs-keyword">try</span> (<br>                <span class="hljs-type">FileChannel</span> <span class="hljs-variable">from</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(FROM).getChannel();<br>                <span class="hljs-type">FileChannel</span> <span class="hljs-variable">to</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(TO).getChannel()<br>        ) &#123;<br>            <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">bb</span> <span class="hljs-operator">=</span> ByteBuffer.allocateDirect(_1MB);<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> from.read(bb);<br>                <span class="hljs-keyword">if</span> (len == -<span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                bb.flip();<br>                to.write(bb);<br>                bb.clear();<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.nanoTime();<br>        System.out.println(<span class="hljs-string">&quot;directBuffer 用时：&quot;</span> + (end - start) / <span class="hljs-number">1000_000.0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 传统的 IO 读写</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">io</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.nanoTime();<br>        <span class="hljs-keyword">try</span> (<br>                <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">from</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(FROM);<br>                <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">to</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(TO)<br>        ) &#123;<br>            <span class="hljs-type">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[_1MB];<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> from.read(buf);<br>                <span class="hljs-keyword">if</span> (len == -<span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                to.write(buf, <span class="hljs-number">0</span>, len);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.nanoTime();<br>        System.out.println(<span class="hljs-string">&quot;io 用时：&quot;</span> + (end - start) / <span class="hljs-number">1000_000.0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">directBuffer 用时：<span class="hljs-number">5812.7709</span><br>io 用时：<span class="hljs-number">6182.531</span><br></code></pre></td></tr></table></figure><p>使用直接内存进行读写的效率是要高于传统的阻塞 IO 的（特别是在较大的文件的读写上）</p><p>原理：</p><p>Java 语言并不具备磁盘读写的能力，它必须调用操作系统提供的函数，需要从 <strong>用户态</strong> 切换到了 <strong>内核态</strong>，调用本地方法。</p><p>而内存这边也会进行一些操作，当切换到内核态以后，就会由操作系统的函数去读取磁盘文件中的内容，放入系统内存中的一块系统缓冲区，而在系统缓冲区中，Java 代码是不能操作系统缓冲区的，所以 Java 会在堆内存中分出一块 Java 缓冲区（就是代码中的 <code>new byte[]</code>），然后从系统缓冲区中读取数据放入 Java 缓冲区，这一系列操作完了之后，就会从内核态又切换回用户态，去对 Java 缓冲区的数据进行一些输出流的写入操作。</p><p>而经过反反复复的上面的过程就完成了一个磁盘文件的读写。</p><p>而这样进行磁盘文件的读写是有一个问题的，因为现在存在两块缓冲区，那么就必然涉及到从磁盘文件中拷贝数据到系统缓冲区，而 Java 不能操作系统缓冲区，那么又要把数据拷贝到 Java 缓冲区，这样就造成了不必要的数据的拷贝，所以效率不是很高。</p><p><img src="/java/jvm-a1fb6fd89ac6/image-20240121143406072.png" alt="不使用直接内存"></p><p>而如果使用 Direct Memory</p><p><img src="/java/jvm-a1fb6fd89ac6/image-20240121143515843.png" alt="直接内存"></p><p>当调用 <code>ByteBuffer.allocateDirect()</code> 方法时会在操作系统内存里分配一个指定大小的 <strong>直接内存</strong>，而对于这块 <strong>直接内存</strong>，在 Java 堆中维护了该内存的引用，所以可以直接操作，即对于 Java 和操作系统来说是一个共享的区域。</p><p>那么当操作系统的函数从磁盘文件中读取数据后会放入直接内存，Java 代码就可以直接操作，不需要经过系统缓冲区的一次拷贝，自然效率就高了（尤其是在大文件的读写上极为明显）。</p><h4 id="7-3-直接内存溢出">7.3 直接内存溢出</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DirectMemoryOver</span> &#123;<br>    <span class="hljs-comment">// 演示直接内存溢出</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">_100MB</span> <span class="hljs-operator">=</span> <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">100</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;ByteBuffer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">byteBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocateDirect(_100MB);<br>                list.add(byteBuffer);<br>                i++;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            System.out.println(i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：Direct Momery 也会引发内存溢出，Direct buffer memory</p><p><img src="/java/jvm-a1fb6fd89ac6/image-20231105091535983.png" alt="直接内存溢出"></p><p>在 arthas 中，通过 memory 可以查看直接内存的大小。</p><p><img src="/java/jvm-a1fb6fd89ac6/image-20231105091803795.png" alt="memory"></p><h4 id="7-3-释放原理">7.3 释放原理</h4><blockquote><p>直接内存不是 JVM 管理的，而是操作系统管理的内存，所以在 Windows 下需要打开任务管理器（Ctrl + Shift + Esc）来查看</p></blockquote><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 演示直接内存释放</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DirectMemory</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">_1GB</span> <span class="hljs-operator">=</span> <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">byteBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocateDirect(_1GB);<br>        System.out.println(<span class="hljs-string">&quot;直接内存分配完毕&quot;</span>);<br>        System.in.read();<br>        System.out.println(<span class="hljs-string">&quot;直接内存开始释放&quot;</span>);<br>        byteBuffer = <span class="hljs-literal">null</span>;<br>        System.gc();<br>        System.in.read();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行：</p><p><img src="/java/jvm-a1fb6fd89ac6/image-20230707143335506.png" alt="任务管理器"></p><p>在直接内存分配完毕之后，任务管理器就多了一个约 1 Gb 的 Java 进程，而敲入回车之后，直接内存被释放，该 Java 进程就只有 15.9 MB 的内存。</p><p><img src="/java/jvm-a1fb6fd89ac6/image-20230707143512479.png" alt="任务管理器"></p><p>而上面的代码有两个是直接内存回收可能的原因：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">byteBuffer = <span class="hljs-literal">null</span>;<br>System.gc();<br></code></pre></td></tr></table></figure><p>是 byteBuffer 置空导致的直接内存回收还是 JVM 垃圾回收导致的呢？直接内存不受 JVM 内存回收管理，所以是 byteBuffer 置空导致的直接内存回收，那么具体的原理是怎样的呢？看下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用 Unsafe 分配直接内存</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UnsafeTest</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">_1Gb</span> <span class="hljs-operator">=</span> <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">Unsafe</span> <span class="hljs-variable">unsafe</span> <span class="hljs-operator">=</span> getUnsafe();<br>        <span class="hljs-comment">// 调用 Unsafe 对象的方法来分配内存</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">base</span> <span class="hljs-operator">=</span> unsafe.allocateMemory(_1Gb); <span class="hljs-comment">// 返回值就是分配的直接内存的地址</span><br>        unsafe.setMemory(base, _1Gb, (<span class="hljs-type">byte</span>) <span class="hljs-number">0</span>);<br>        System.out.println(<span class="hljs-string">&quot;开始分配内存&quot;</span>);<br>        System.in.read();<br>        <span class="hljs-comment">// 调用 Unsafe 对象的方法来释放内存</span><br>        System.out.println(<span class="hljs-string">&quot;开始释放内存&quot;</span>);<br>        unsafe.freeMemory(base); <span class="hljs-comment">// 根据上面的直接内存的地址来释放内存</span><br>        System.in.read();<br>    &#125;<br><br>    <span class="hljs-comment">// 通过反射获取 Unsafe 对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Unsafe <span class="hljs-title function_">getUnsafe</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> Unsafe.class.getDeclaredField(<span class="hljs-string">&quot;theUnsafe&quot;</span>);<br>            field.setAccessible(<span class="hljs-literal">true</span>);<br>            <span class="hljs-keyword">return</span> (Unsafe) field.get(<span class="hljs-literal">null</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 Java 中，有一个比较底层的类，Unsafe 类就可以做一些分配内存、释放内存的操作，运行上面的代码：</p><p><img src="/java/jvm-a1fb6fd89ac6/image-20230707143856544.png" alt="任务管理器"></p><p>敲入回车开始释放内存</p><p><img src="/java/jvm-a1fb6fd89ac6/image-20230707143953741.png" alt="任务管理器"></p><p>就说明了，直接内存的管理不是通过 JVM 垃圾回收来管理的，而是通过底层一个 Unsafe 类的方法来进行分配和释放内存的。</p><p><strong>ByteBuffer 和 Unsafe 的关联</strong></p><p>进入 ByteBuffer 类的 allocateDirect()，在 DirectByteBuffer 构造器里面就调用了 Unsafe 的 allocateMemory 方法和 setMemory 方法来分配直接内存。</p><p><img src="/java/jvm-a1fb6fd89ac6/image-20231105092409968.png" alt="DirectByteBuffer"></p><p>而对于直接内存释放，必须主动调用 Unsafe 对象的 freeMemory 方法，那是怎样实现的呢？</p><p>在 DirectByteBuffe 类有一个 Deallocator 回调任务对象（实现了 Runnable 接口），其内部的 run 方法就执行了释放内存的操作。</p><p><img src="/java/jvm-a1fb6fd89ac6/image-20231105092846027.png" alt="回调对象"></p><p>在 DirectByteBuffer 的构造器中有一个虚引用对象 Cleaner，那么在 DirectByteBuffer 的构造器中的这一行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">cleaner = Cleaner.create(<span class="hljs-built_in">this</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Deallocator</span>(base, size, cap));<br></code></pre></td></tr></table></figure><p>当前对象（ByteBuffer，它也是 Java 对象，放在堆中，受 JVM 垃圾回收管理）如果被 JVM 垃圾回收掉了，那么会执行 Cleaner 对象的一个 clean 方法，而这个 clean 方法就会开启一个新的线程来执行 Deallocator 回调任务对象中的 run 方法来释放直接内存。</p><p><img src="/java/jvm-a1fb6fd89ac6/image-20231105092710615.png" alt="run"></p><p>总结：</p><ul><li>在 ByteBuffer 的实现类内部，使用了 Cleaner（虚引用）来监测 ByteBuffer 对象。</li><li>一旦 ByteBuffer 对象被垃圾回收，就会由 ReferenceHandler 线程通过 Cleaner 中的 clean 方法调用 freeMemory 来释放直接内存。</li></ul><h4 id="7-4-禁用显式回收对直接内存的影响">7.4 禁用显式回收对直接内存的影响</h4><p>在做 JVM 调优的时候经常会加一个这样的参数 <code>-XX:+DisableExplicitGC</code> 来禁止显式的垃圾回收。下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DirectMemory</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">_1Gb</span> <span class="hljs-operator">=</span> <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br><br>    <span class="hljs-comment">// -XX:+DisableExplicitGC 禁用显式的垃圾回收</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">byteBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocateDirect(_1Gb);<br>        System.out.println(<span class="hljs-string">&quot;直接内存分配完毕&quot;</span>);<br>        System.in.read();<br>        System.out.println(<span class="hljs-string">&quot;直接内存开始释放&quot;</span>);<br>        byteBuffer = <span class="hljs-literal">null</span>;<br>        System.gc(); <span class="hljs-comment">// 无效 FullGC</span><br>        System.in.read();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于禁用显式的垃圾回收，就是让代码中的 <code>System.gc()</code> 无效，因为 <code>System.gc()</code> 触发的是一次 Full GC。</p><p>这是一种比较影响性能的垃圾回收，不光影响新生代还会影响老年代。而加上上面的参数可能会对直接内存的回收机制造成一定的影响。运行上面的代码：</p><p><img src="/java/jvm-a1fb6fd89ac6/image-20230707145459334.png" alt="任务管理器"></p><p>在敲入回车将 byteBuffer 置空之后，这个 Java 进程的所分配的直接内存并没有被释放，这是因为代码中的 <code>System.gc()</code> 已经无效，那么堆中的内存充足，没有触发垃圾回收机制，所以 byteBuffer 对象没有被回收，那么自然直接内存就得不到释放，这样就会造成直接内存占用较大，长时间得不到释放。</p><p>这时只有主动使用 Unsafe 的 freeMemory 方法来手动释放直接内存。</p><h2 id="垃圾回收">垃圾回收</h2><h3 id="1-概述-3">1. 概述</h3><p>Java 中的自动垃圾回收机制，称为 GC（Garbage Collection），通过垃圾回收器来对不再使用的对象完成自动回收。</p><p><strong>内存泄漏</strong>：指的是不再使用的对象，在系统中未被回收，而内存泄漏的积累可能会导致 <strong>内存溢出</strong>。</p><p>对比于 C/C++ 的手动垃圾回收，</p><ol><li>自动垃圾回收，降低了程序员编码难度，降低对象回收 bug 的可能性，但是开发人员无法控制内存回收的及时性。</li><li>而手动垃圾回收，回收及时性高，由开发人员把控回收的时机，但是编码不当易造成悬空指针、重复释放、内存泄漏等问题。</li></ol><p>当然并不是说自动垃圾回收机制就不会出现内存泄露，由于开发人员无法控制内存回收的及时性，在某些特定情况下也可能出现内存泄漏。</p><p>在垃圾回收中，主要考虑 3 个问题：哪些内存需要回收，什么时候回收以及如何回收。</p><p>在 JVM 的内存结构中，程序计数器、虚拟机栈、本地方法栈 3 个区域随线程而生，随线程而灭，栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作，每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的（尽管在运行期会由 JIT 编译器进行一些优化，但大体上可以认为是编译期可知的），因此这几个区域的内存分配和回收都具备确定性，在这几个区域内就不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了。</p><p>而堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，只有在程序处于运行期间时才能知道会创建哪些对象，这部分 <strong>内存的分配和回收都是动态</strong> 的，所以垃圾回收所关注的是这部分内存。</p><h3 id="2-方法区的回收">2. 方法区的回收</h3><p>方法的垃圾回收主要回收两部分内容：废弃常量和无用的类。</p><ol><li>回收废弃常量与回收 Java 堆中的对象非常类似。以常量池中字面量的回收为例，假如一个字符串 “abc” 已经进入了常量池中，但是当前系统没有任何 String 对象引用常量池中的 “abc” 常量，也没有其他地方引用了这个字面量，如果这时发生内存回收，而且必要的话，这个 “abc” 常量就会被系统清理出常量池。</li><li>常量池中的其他类（接口）、方法、字段的符号引用也与此类似。</li></ol><p>判定一个常量是否是 “废弃常量” 比较简单，而要判定一个类是否是 “无用的类” 的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 “无用的类”：</p><ul><li>该类所有的实例对象都已经被回收，也就是 Java 堆中不存在该类的任何实例对象以及子类对象。</li><li>加载该类的 ClassLoader 已经被回收。</li><li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul><p>虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是 “可以”，而并不是和对象一样，不使用了就必然会回收。</p><p>是否对类进行回收，HotSpot 虚拟机提供了 <code>-Xnoclassgc</code> 参数进行控制，在大量使用反射、动态代理、CGLib 等 ByteCode 框架、动态生成 JSP 以及 OSGi 这类频繁自定义 ClassLoader 的场景都需要虚拟机具备类卸载的功能，以保证方法区不会溢出。</p><p>注意：</p><ol><li>很多人认为方法区是没有垃圾回收的，在 Java 虚拟机规范中确实说过不要求虚拟机在方法区实现垃圾回收，而且在方法区中进行垃圾回收的 “性价比” 较低，在堆中，尤其是在新生代中，常规应用进行一次垃圾回收一般可以回收 70%～95% 的空间，而方法区的垃圾回收效率远低于此。</li><li>两个虚拟机参数<ul><li><code>-XX:+TraceClassLoading</code>：在程序运行时，输出类的加载信息。</li><li><code>-XX:+TraceClassUnloading</code>：在类卸载时，输出类的卸载信息。</li></ul></li><li>System.gc() 方法：手动触发垃圾回收，但是调用该方法不一定会立即进行，仅仅向 JVM 发送垃圾回收的请求。</li></ol><h3 id="3-堆的回收">3. 堆的回收</h3><h4 id="3-1-哪些对象可以被回收">3.1 哪些对象可以被回收</h4><p>在堆中存放着 Java 中几乎所有的对象实例，垃圾回收器在对堆进行回收前，首先要确定这些对象之中哪些还 “存活” 着，哪些已经 “死去”（即不可能再被任何途径使用的对象）。</p><p>在 Java 中，对象是否能被回收，是根据对象是否被 <strong>引用</strong> 来决定的，如果对象被引用了，说明该对象还在使用，则不允许被回收。</p><p>常见的有两种判断方法：</p><ol><li>引用技术法</li><li>可达性分析算法</li></ol><h5 id="引用计数法">引用计数法</h5><blockquote><p>应用范围：微软 COM 技术、ActionScript 的 Flash Player、Python</p></blockquote><p>所谓 <strong>引用计数法</strong> （Reference Counting）就是在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一，当引用失效时，计数器值就减一。</p><p>任何时刻计数器为零的对象就是不可能再被使用的。</p><p>引用计数法占用了一些额外的内存空间来进行计数，但它的原理简单，判定效率也很高，在大多数情况下它都是一个不错的算法。</p><p>但是这个看似简单的算法有很多例外情况要考虑，必须要配合大量额外处理才能保证正确地工作，比如单纯的引用计数就很难解决 <strong>对象之间相互循环引用</strong> 的问题。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 引用计数法的循环引用问题</span><br><span class="hljs-comment">// JVM 参数：-XX:+PrintGCDetails -verbose:gc</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReferenceCounting</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">Object</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ReferenceCounting</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceCounting</span>();<br>        <span class="hljs-type">ReferenceCounting</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceCounting</span>();<br><br>        t1.instance = t2;<br>        t2.instance = t1;<br>        t1 = <span class="hljs-literal">null</span>;<br>        t2 = <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">// 发生 GC</span><br>        System.gc();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/java/jvm-a1fb6fd89ac6/image-20231105113034737.png" alt="垃圾回收"></p><p>垃圾回收日志中包含 “3906K -&gt; 808K”，意味着虚拟机并没有因为这两个对象互相引用就放弃回收它们，这也从侧面说明了 Java 虚拟机并不是通过引用计数算法来判断对象是否存活的。</p><h5 id="可达性分析算法">可达性分析算法</h5><p><strong>基本思路</strong></p><p>该算法的基本思路就是通过一系列称为 “GC Roots” 的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为 “引用链”（Reference Chain），如果某个对象到 GC Roots 间没有任何引用链相连， 或者用图论的话来说就是从 GC Roots 到这个对象不可达时，则此对象是不可能再被使用的，会被垃圾回收掉。</p><p>如图，对象 object 5、object 6、object 7 虽然互有关联，但是它们到 GC Roots 是不可达的， 因此它们将会被判定为可回收的对象。</p><p><img src="/java/jvm-a1fb6fd89ac6/image-20240121143829523.png" alt="GC Root"></p><p><strong>GC Roots 根对象</strong></p><p>在 Java 技术体系里面，固定可作为 GC Roots 的对象包括以下几种：</p><ul><li>线程 Thread 对象，其引用线程栈帧中的方法参数、局部变量等。</li><li>系统类加载器加载 java.lang.Class 对象。</li><li>监视器对象，用来保存同步锁 synchronized 关键字持有的对象。</li><li>本地方法调用时使用的全局对象。</li></ul><p>除了这些固定的 GC Roots 集合以外，根据用户所选用的垃圾回收器以及当前回收的内存区域不同，还可以有其他对象 “临时性” 地加入，共同构成完整 GC Roots 集合。</p><p><strong>查看 GC Root 对象</strong></p><p>通过 arthas 和 MAT 工具（eclipse 推出的 Java 堆内存检测工具）可以查看 GC Root。</p><ol><li>使用 arthas 的 heapdump 命令将堆内存快照保存到本地磁盘。</li><li>使用 MAT 工具打开堆内存快照文件。</li></ol><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MATTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">A</span> <span class="hljs-variable">a2</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">A</span> <span class="hljs-variable">a1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>();<br>        <span class="hljs-type">B</span> <span class="hljs-variable">b1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">B</span>();<br>        a1.b = b1;<br>        b1.a = a1;<br>        a2 = a1;<br>        System.in.read();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 MAT 中打开堆内存快照，找到 GC Roots 集合</p><p><img src="/java/jvm-a1fb6fd89ac6/image-20231105133903469.png" alt="MAT"></p><p><strong>循环引用问题</strong></p><p>循环引用问题，如果 A 引用 B，B 又引用 A，这 2 个对象是否能被 GC 回收？</p><p>关键不是在于 A、B 之间是否有引用，而是 A、B 是否可以一直向上追溯到 GC Roots。如果与 GC Roots 没有关联，则会被回收，否则将继续存活。</p><h4 id="3-2-五种引用">3.2 五种引用</h4><p>无论是通过引用计数算判断对象的引用数量，还是可达性分析算法判断对象的引用链是否可达，判定对象是否存活都与 “引用” 有关。</p><p>在 JDK 1.2 以前，Java 中的引用的定义很传统：如果 reference 类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。这种定义纯粹但太过狭隘，一个对象在这种定义下只有被引用或者没有被引用两种状态，对于如何描述一些可有可无的对象就显得无能为力。</p><p>我们希望能描述这样一类对象：当内存空间还足够时，则能保留在内存之中，如果内存空间在进行垃圾回收后还是非常紧张，则可以抛弃这些对象。很多系统的 <strong>缓存</strong> 功能都符合这样的应用场景。</p><p>在 JDK 1.2 之后，Java 对引用的概念进行了扩充，将引用分为强引用（Strongly Reference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）4 种，这 4 种引用强度依次逐渐减弱。</p><h5 id="强引用">强引用</h5><p>强引用是最传统的 “引用” 的定义，是指在程序代码之中普遍存在的引用赋值，即类似 <code>Object obj = new Object()</code> 这种引用关系。</p><p>在任何情况下，只要强引用关系还存在，垃圾回收器就永远不会回收掉被引用的对象。</p><p>示例：当执行 Strong() 方法，创建了 5 个大小为 4 MB 的 byte 数组，设置堆内存最大为 20MB，强引用的对象在内存回收时不会被回收，所以会出现内存溢出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 演示强引用</span><br><span class="hljs-comment">// JVM 参数：-Xmx20m -XX:+PrintGCDetails -verbose:gc</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StrongReference</span> &#123;<br>    <span class="hljs-comment">// 模拟一些不常用的资源</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">_4MB</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        Strong();<br>    &#125;<br><br>    <span class="hljs-comment">// 强引用</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Strong</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// list ---&gt; 实现的强引用</span><br>        List&lt;<span class="hljs-type">byte</span>[]&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[_4MB]);<br>        &#125;<br>        System.in.read();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="/java/jvm-a1fb6fd89ac6/image-20231105151612757.png" alt="垃圾回收"></p><h5 id="软引用">软引用</h5><p>软引用是用来描述一些还有用但非必须的对象，被软引用关联着的对象，在系统将要发生内存溢出前，会把这些对象列进回收范围之中进行垃圾回收，如果这次回收还没有足够的内存， 才会抛出内存溢出异常。</p><p>在 JDK 1.2 之后提供了 SoftReference 类来实现软引用。</p><p>软应用包含的对象，一定是程序非必要的数据，所以软引用常用于 <strong>缓存</strong> 中，因为缓存一般是为了提升程序访问数据的性能，即便缓存的数据不能再使用，也应该能够通过访问真实的数据继续运行。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 演示软引用</span><br><span class="hljs-comment">// JVM 参数：-Xmx20m -XX:+PrintGCDetails -verbose:gc</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SoftReferenceText</span> &#123;<br>    <span class="hljs-comment">// 模拟一些不常用的资源</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">_4MB</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Soft();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Soft</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// list ---&gt; SoftReference(软引用对象) ---&gt; byte[]</span><br>        List&lt;SoftReference&lt;<span class="hljs-type">byte</span>[]&gt;&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            SoftReference&lt;<span class="hljs-type">byte</span>[]&gt; softReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SoftReference</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[_4MB]);<br>            <span class="hljs-comment">// get() 方法返回 SoftReference 的引用对象即 byte[]</span><br>            <span class="hljs-comment">// 如果该引用对象已被程序或垃圾回收器清除，则此方法返回零</span><br>            <span class="hljs-type">byte</span>[] bytes = softReference.get();<br>            System.out.print(bytes + <span class="hljs-string">&quot; &quot;</span>);<br>            list.add(softReference);<br>            System.out.print(list.size() + <span class="hljs-string">&quot;  &quot;</span>);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;循环结束：&quot;</span> + list.size());<br>        list.forEach(softReference -&gt; System.out.print(softReference.get() + <span class="hljs-string">&quot; &quot;</span>));<br>        System.out.println();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="/java/jvm-a1fb6fd89ac6/image-20231105154044849.png" alt="垃圾回收"></p><p>在创建第 5 个 byte 数组对象的时候分配内存失败进行了一次 Full GC，将软引用所引用的对象进行了回收，所以最后在遍历 list 时，前四个对象为 null。</p><p>而此时，前四个 null 对象的软引用本身也没有必要继续存在，因此可以把软引用本身回收掉，更改一下 Soft() 方法，将软引用关联到引用队列，这样当软引用的对象被回收时，该软引用会加入到引用队列，那么我们就可以遍历该队列，将队列中的软引用回收掉。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Soft</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// list ---&gt; SoftReference(软引用对象) ---&gt; byte[]</span><br>    List&lt;SoftReference&lt;<span class="hljs-type">byte</span>[]&gt;&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-comment">// 引用队列</span><br>    ReferenceQueue&lt;<span class="hljs-type">byte</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceQueue</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>        <span class="hljs-comment">// 如果关联了引用队列, 那么当软引用的对象 byte[] 被回收时, 软引用自身会加入 queue 中</span><br>        SoftReference&lt;<span class="hljs-type">byte</span>[]&gt; softReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SoftReference</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[_4MB], queue);<br>        <span class="hljs-comment">// get() 方法返回 SoftReference 的引用对象即 byte[] 如果该引用对象已被程序或垃圾回收器清除，则此方法返回零</span><br>        list.add(softReference);<br>        list.forEach(softRef -&gt; System.out.print(softRef.get() + <span class="hljs-string">&quot; &quot;</span>));<br>        System.out.println();<br>    &#125;<br>    <span class="hljs-comment">// 获取队列中的元素并遍历删除</span><br>    Reference&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">byte</span>[]&gt; poll = queue.poll();<br>    <span class="hljs-keyword">while</span> (poll != <span class="hljs-literal">null</span>) &#123;<br>        list.remove(poll);<br>        poll = queue.poll();<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;循环结束, list 的大小为: &quot;</span> + list.size());<br>    list.forEach(softReference -&gt; System.out.print(softReference.get() + <span class="hljs-string">&quot; &quot;</span>));<br>    System.out.println();<br>&#125;<br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="/java/jvm-a1fb6fd89ac6/image-20231105154519274.png" alt="垃圾回收"></p><h5 id="弱引用">弱引用</h5><p>弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾回收发生为止。</p><p>当垃圾回收器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。</p><p>在 JDK 1.2 之后提供了 WeakReference 类来实现弱引用。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WeakReferenceTest</span> &#123;<br>    <span class="hljs-comment">// 模拟一些不常用的资源</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">_4MB</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Weak();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Weak</span><span class="hljs-params">()</span> &#123;<br>        List&lt;WeakReference&lt;<span class="hljs-type">byte</span>[]&gt;&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">// 引用队列</span><br>        ReferenceQueue&lt;<span class="hljs-type">byte</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceQueue</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            WeakReference&lt;<span class="hljs-type">byte</span>[]&gt; ref = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakReference</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[_4MB], queue);<br>            list.add(ref);<br>            list.forEach(weakRef -&gt; System.out.print(weakRef.get() + <span class="hljs-string">&quot; &quot;</span>));<br>            System.out.println();<br>        &#125;<br>        Reference&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">byte</span>[]&gt; poll = queue.poll();<br>        <span class="hljs-keyword">while</span> (poll != <span class="hljs-literal">null</span>) &#123;<br>            list.remove(poll);<br>            poll = queue.poll();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;循环结束：&quot;</span> + list.size());<br>        list.forEach(weakRef -&gt; System.out.println(weakRef + <span class="hljs-string">&quot; &quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="/java/jvm-a1fb6fd89ac6/image-20231105154712603.png" alt="垃圾回收"></p><p>对于软、弱引用，若没有引用对象，那么自身会进入一个引用队列，我们就可以遍历该队列来删除这些引用。</p><h5 id="虚引用">虚引用</h5><p>虚引用也称为 “幽灵引用” 或者 “幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。</p><p>为一个对象设置虚引用关联的唯一目的是为了能在该对象被垃圾回收时收到一个系统通知。</p><p>在 JDK 1.2 版之后提供了 PhantomReference 类来实现虚引用。</p><p>如在 ByteBuffer 类中，虚引用的作用体现在 <strong>直接内存</strong> 的释放。</p><h5 id="终结器引用">终结器引用</h5><p>终结器引用指的是在对象需要被回收时，该引用会关联对象并放置在 Finalizer 类中的引用队列中，在稍后由一条 FinalizerThread 线程从队列中获取对象，然后执行对象的 finalize 方法，在对象第二次被回收时，该对象才真正的被回收。</p><p>在这个过程中可以在 finalize 方法中再将自身对象使用强引用关联上，但是不建议这样做，原因在于：</p><ul><li>对象的 finalize() 只能执行一次。</li><li>它的运行代价高昂。</li><li>不确定性大。</li><li>无法保证各个对象的调用顺序。</li></ul><h4 id="3-3-垃圾回收算法">3.3 垃圾回收算法</h4><h5 id="概述-3">概述</h5><p>垃圾回收算法的核心思想：简单来说，垃圾回收主要做两件事，</p><ol><li>根据可达性分析算法找到堆中存活的对象。</li><li>释放不再存活对象的内存，使得程序能再次利用这部分空间。</li></ol><p>常见的垃圾回收算法主要有 4 种：</p><ol><li>标记-清除算法（Mark Sweep GC）</li><li>复制算法（Copying GC）</li><li>标记-整理算法（Mark Compact GC）</li><li>分代 GC（Generational GC）</li></ol><p>这 4 种算法中，标记-清除算法和复制算法是最早诞生的两个算法，本质上后续诞生的垃圾回收算法都是在这两种算法的基础上进行优化，比如标记-整理算法，它就是在标记-清除算法的基础上进行了优化。而分代 GC 算法比较特殊，它会混合使用前 3 种算法。</p><p><strong>垃圾回收算法的评价标准</strong></p><p>Java 垃圾回收过程会通过单独的 GC 线程来完成，但是不管使用哪一种 GC 算法，都会有部分阶段需要停止所有的用户线程。该过程被称之为 Stop The World（STW），如果 STW 时间过长则会影响用户的使用。</p><p>所以判断一个垃圾回收算法是否优秀，可以从 3 个方面考虑：</p><ol><li>吞吐量：指的是 CPU 用于执行用户代码的时间与 CPU 总执行时间的比值，即吞吐量 = 执行用户代码时间 / (执行用户代码时间 + GC 耗时)，而吞吐量越高，那么垃圾回收的效率就越高。</li><li>最大暂停时间：指的是某个时间段在垃圾回收过程中的 STW 时间的最大值。最大暂停时间越短，用户使用系统受到影响就越小。</li><li>堆使用效率：不同垃圾回收算法，对堆内存的使用方式是不同的。比如标记-清除算法，可以使用完整的堆内存，而复制算法会将堆内存一分为二，每次只能使用一半内存。从堆使用效率上来说，标记-清除算法要优于复制算法。</li></ol><p>上述三种评价标准：堆使用效率、吞吐量，以及最大暂停时间不可兼得。 一般来说，堆内存越大，最大暂停时间就越长，想要减少最大暂停时间，就会降低吞吐量。</p><p>总之，不同的垃圾回收算法，适用于不同的场景。</p><h5 id="标记-清除">标记-清除</h5><p>算法分为 “标记” 和 “清除” 两个阶段：</p><ol><li>首先标记出所有需要回收的对象。</li><li>在标记完成后，统一回收掉所有被标记的对象。</li><li>也可以反过来，标记存活的对象，统一回收所有未被标记的对象。</li></ol><p>标记过程就是对象是否属于垃圾的判定过程。 之所以说它是最基础的回收算法，是因为后续的回收算法大多都是以标记清除算法为基础，对其缺点进行改进而得到的。</p><p>特点：</p><ol><li>实现简单。</li><li>执行效率不稳定，如果 Java 堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低。</li><li>内存空间的碎片化问题，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象（如数组）时无法找到足够的连续内存而不得不提前触发另一次垃圾回收动作。</li><li>分配速度慢，由于内存碎片的存在，JVM 需要维护一个空闲链表，极有可能每次需要遍历到链表的最后才能找到合适的空间。</li></ol><p>图示：</p><p><img src="/java/jvm-a1fb6fd89ac6/image-20240121144524842.png" alt="垃圾回收"></p><h5 id="复制">复制</h5><p>算法核心思路：</p><ol><li>在堆内存中准备两块空间，分别是 From 和 To，每次在对象分配时，只使用其中一块空间（From 空间）</li><li>在垃圾回收 GC 阶段，将 From 中存活的对象复制到 To 空间。</li><li>将两块空间的引用互换（保证 From 中一定是存活的对象）。</li></ol><p>特点：</p><ol><li>吞吐量高：复制算法只需要遍历一次存活对象，将其复制到 To 空间即可，比标记-整理算法少了一次遍历的过程，因而性能较好，但是不如标记-清除算法， 因为标记清除算法不需要进行对象的移动。</li><li>不会产生内存碎片问题：复制算法在复制之后就会将对象按顺序放入 To 空间中，所以对象以外的区域都是可用空间，不存在碎片化内存空间。</li><li>但是内存使用率低，每次只能使用一半的空间来存放对象。</li></ol><p>图示：</p><p><img src="/java/jvm-a1fb6fd89ac6/image-20240121145047629.png" alt="垃圾回收"></p><h5 id="标记-整理">标记-整理</h5><p>算法分为 “标记” 和 “整理” 两个阶段：</p><ol><li>标记阶段，使用可达性分析算法，将所有存活的对象进行标记。</li><li>整理阶段，将存活的对象移动到堆的另一端，并清理掉剩余的空间。</li></ol><p>特点：</p><ol><li>内存利用率高：整个堆内存都可以使用，不会像复制算法只能使用半个堆内存。</li><li>不会产生内存碎片化问题：在整理阶段可以将对象往内存的一侧进行移动，剩下的空间都是可以分配对象的有效空间。</li><li>但是整理阶段的效率不高：整理算法有很多种，比如 Lisp2 整理算法需要对整个堆中的对象搜索 3 次，性能不佳，可以通过TwoFinger、表格算法、ImmixGC 等高效的整理算法优化此阶段的性能。</li></ol><p>图示：</p><p><img src="/java/jvm-a1fb6fd89ac6/image-20240121145242442.png" alt="垃圾回收"></p><h5 id="分代-GC">分代 GC</h5><p>分代 GC 将整个堆内存划分为 <strong>新生代</strong> 和 <strong>老年代</strong>，在新生代中存放存活时间比较短的对象，而老年代中存放存活时间比较长的对象。</p><p>在 <strong>新生代</strong> 中又分为：Eden（伊甸园）、Survivor To（幸存区 To）以及 Survivor From（幸存区 From）。</p><p><strong>使用 arthas 查看堆的内存分配</strong></p><p>使用的虚拟机参数：</p><table><thead><tr><th>参数名</th><th>参数含义</th></tr></thead><tbody><tr><td>-Xms</td><td>设置堆的初始大小，必须是 1024 的整数倍且大于 1M</td></tr><tr><td>-Xmx</td><td>设置堆的最大大小，必须是 1024 的整数倍且大于 2M</td></tr><tr><td>-Xmn</td><td>设置新生代的大小</td></tr><tr><td>-XX:SurvivorRatio</td><td>设置新生代中伊甸园和幸存区的比例，默认为 8</td></tr><tr><td>-XX:+PrintGCDetails -verbose:gc</td><td>打印 GC 日志</td></tr></tbody></table><p>使用 <code>-Xms60m -Xmx60m -Xmn20m -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc</code>：</p><ol><li>堆中新生代内存大小为 20M，堆中总大小为 60M，则老年代为 40M。</li><li>新生代中幸存区和伊甸园的比例为 8，则伊甸园为 16M，两个 Survivor 区分别为 4M。</li></ol><p>验证：</p><p><img src="/java/jvm-a1fb6fd89ac6/image-20231105172016426.png" alt="memory"></p><p>分代 GC 算法的过程：</p><ol><li>在分代回收时，创建出来的对象，首先被放入 Eden 区。</li><li>随着对象的增多，Eden 区域满，新创建的对象已经无法放入，就会出发一次年轻的的 GC（Minor GC/Young GC），将 Eden 和 From 区需要回收的对象回收，存活的对象放入 To 区。</li><li>接下来，From 和 To 交换引用，并记录对象的年龄（初始值为 0，每次加 1）。</li><li>如果在 Minor GC 后对象的年龄达到阈值（最大为 15，默认值与垃圾回收器有关），对象就会晋升至老年代。</li><li>当老年代中空间不足，会先尝试一次 Minor GC，若内存还是不足，则会触发 Full GC，对整个堆进行垃圾回收，若 Full GC 后内存依旧不足，则抛出 OutOfMemory 异常。</li></ol><p>对象进入老年代的情况：</p><ul><li>超大对象（需要大量连续内存空间的对象，如数组、字符串）直接进入老年代，避免在 Eden 和两个 Survivor 区发生大量的内存复制，使用 <code>-XX:PretenureSizeThreshold</code> 参数设置大对象的阈值，单位为 byte，默认为 0，即不开启。</li><li>如果 To 区已满，此时还有对象需要存储，那么会直接晋升老年代。</li><li>最后就是上面讲的，长期存活的对象（年龄达到阈值），也会进入老年代。</li></ul><p>示例：使用下面的程序查看分代 GC 的过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 虚拟机参数: -Xms60m -Xmx60m -Xmn20m -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MemoryTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        List&lt;Object&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            System.in.read();<br>            System.out.println(++count);<br>            <span class="hljs-comment">// 每次添加 1m 数据</span><br>            list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>为什么分代 GC 把堆分为新生代和老年代？</strong></p><p>首先我们要知道，系统中的大部分对象都是 “朝生夕死” 的，即创建出来后很快就不再使用，可以被回收，如用户获取的订单数据，但还有一部分对象需要长期存活，如 Spring 的大部分 bean 对象，在程序启动后就不会被回收。</p><p>将堆分为新生代和老年代，那么</p><ol><li>“朝生夕死” 的对象就可以放入新生代，采用 <strong>复制</strong> 算法，只需要付出少量存活对象的复制成本就可以完成一次垃圾回收。</li><li>而存活时间长的对象，就可以放入老年代，使用 <strong>标记-清除</strong> 或者 <strong>标记-整理</strong> 算法进行回收。</li><li>在虚拟机的默认设置中，新生代的大小要远小于老年代的大小。</li></ol><p>这样的好处在于，</p><ol><li>在分代的设计中，允许只回收新生代（Minor GC），如果能满足对象分配的要求，就不需要对整个堆进行回收（Full GC），STW 的时间就会减少。</li><li>可以通过调整新生代和老年代的比例来适应不同类型的应用程序，提高内存的利用率和性能。</li></ol><h4 id="3-4-垃圾回收器">3.4 垃圾回收器</h4><h5 id="概述-4">概述</h5><p>垃圾回收算法是内存回收的方法论，那么垃圾回收器就是内存回收的具体实现。</p><p>Java 虚拟机规范中对垃圾回收器如何实现并没有任何规定，因此不同的厂商、不同版本的虚拟机所提供的垃圾回收器可能会有很大差别，并且一般都会提供参数供用户根据应用特点和要求组合出各个年代所使用的回收器。</p><p>分代 GC 算法将堆分为新生代和老年代，主要目的是降低垃圾回收对系统的影响。在 HotSpot 虚拟机中对垃圾回收算法的实现有多种。</p><p>新生代有一批垃圾回收器，老年代也有一批垃圾回收器，且它们之间存在组合关系，不能随意搭配使用。有一个特殊的垃圾回收器 G1，它既可以回收新生代，又可以回收老年代。</p><p>图示：</p><p><img src="/java/jvm-a1fb6fd89ac6/image-20231105175018931.png" alt="垃圾回收器"></p><p><strong>如何查看 JVM 默认的垃圾回收器？</strong></p><p>1）在终端窗口中输入：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">java -XX:+PrintCommandLineFlags -version<br></code></pre></td></tr></table></figure><p>可以查看 JVM 启动时默认添加的参数。</p><p><img src="/java/jvm-a1fb6fd89ac6/image-20231105180718625.png" alt="查看"></p><p>可以看出 JDK 8 默认使用 ParallelScavenge + ParallelOld 回收器。</p><p>2）也可以使用下面的命令，查看所有关于 GC 的信息</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">java -XX:+PrintFlagsFinal -version | findstr <span class="hljs-string">&quot;GC&quot;</span><br></code></pre></td></tr></table></figure><p>3）在 arthas 中使用 dashboard、memory 命令可以展示垃圾回收信息</p><p><img src="/java/jvm-a1fb6fd89ac6/image-20231105181512385.png" alt="memory"></p><p>可以看出使用的是 Serial + SerialOld 组合的垃圾回收器。</p><h5 id="Serial-SerialOld">Serial + SerialOld</h5><p><img src="/java/jvm-a1fb6fd89ac6/image-20231105175646598.png" alt="Serial + SerialOld"></p><h6 id="Serial">Serial</h6><p>Serial 是一款新生代垃圾回收器，采用 <strong>复制</strong> 算法，底层是以单线程来串行回收。</p><p><strong>单线程</strong> 不仅仅说明它只会使用单个 CPU 或一条回收线程去完成垃圾回收，更重要的是在它进行垃圾回收时，必须暂停其他所有的工作线程，直到它回收结束。</p><p>特点：</p><ol><li>在单 CPU 处理器下吞吐量非常出色。</li><li>在用户的桌面应用场景中，分配给虚拟机管理的内存一般不会很大，回收几十或一两百兆的新生代，停顿时间可以控制在几十毫秒到一百多毫秒内，只要不是频繁发生，这点停顿是可以接受的。</li><li>但是在多 CPU 下吞吐量不如其他垃圾回收器，堆空间如果偏大，会使用户线程处于长时间的等待。</li></ol><p>适应场景：Java 编写的客户端程序或者硬件配置有限的场景。</p><h6 id="SerialOld">SerialOld</h6><p>SerialOld 同样使用单线程串行回收，采用的是 <strong>标记-整理</strong> 算法，特点和 Serial 一致，只不过在某些特殊情况下，CMS 会调用 SerialOld 进行垃圾回收。</p><p>通过虚拟机参数：<code>-XX:+UseSerialGC</code>，可以使用 Serial + SerialOld 组合的垃圾回收器。</p><h5 id="ParNew-CMS">ParNew + CMS</h5><h6 id="ParNew">ParNew</h6><p>ParNew 回收器其实就是 Serial 回收器的多线程版本，除了使用多条线程进行垃圾回收外，其余行为包括 Serial 回收器可用的所有控制参数、回收算法、STW、对象分配规则、回收策略等都与 Serial 回收器完全一样，在实现上，这两种回收器也共用了相当多的代码。</p><p><img src="/java/jvm-a1fb6fd89ac6/image-20231105181853219.png" alt="ParNew"></p><p>特点：</p><ol><li>在多 CPU 下停顿时间较短。</li><li>但吞吐量和停顿时间不如 G1，所以在 JDK 9 后不建议使用。</li></ol><p>适用场景：在 JDK 8 之前的版本，与 CMS 等老年代垃圾回收器搭配使用。</p><p>通过虚拟机参数：<code>-XX:+UseParNewGC</code>，可以使用 ParNew + SerialOld 组合的垃圾回收器。</p><p>新生代回收器选用 ParNew，老年代选用 CMS 是自 JDK 1.5 以来到 JDK 9，官方一直推荐的服务器端回收器最佳拍档。</p><blockquote><p>JDK 1.5 发布，HotSpot 推出了一款在强交互应用中几乎可称为具有划时代意义的垃圾回收器——CMS 回收器。这款回收器是 HotSpot 虚拟机中第一款真正意义上<em><strong>支持并发</strong></em>的垃圾回收器，它首次实现了让垃圾回收线程与用户线程（基本上）同时工作。</p></blockquote><p>自 JDK 9 开始，ParNew + CMS 回收器的组合就不再是官方推荐的服务端模式下的回收器解决方案了。官方希望它能完全被更为先进的，面向全堆的 G1 所取代，甚至还取消了 ParNew + SerialOld 以及 Serial + CMS 这两组回收器组合的支持，从此以后，ParNew 合并入 CMS，成为它专门处理新生代的组成部分。ParNew 可以说是 HotSpot 虚拟机中第一款退出历史舞台的垃圾回收器。</p><h6 id="CMS">CMS</h6><p>CMS（Concurrent Mark Sweep）垃圾回收器是一种以获取 <strong>最短停顿时间</strong> 为目标的回收器。</p><p>目前很大一部分 Java 应用集中在网站或者 B/S 系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。</p><p>CMS 回收器就非常符合这类应用的需求，是基于 “标记-清除” 算法实现的，它的运作过程相对于前面几种回收器来说更复杂一些，整个过程分为 4 个步骤，包括：</p><ul><li>初始标记（initial mark），仅仅只是标记 GC Roots 能直接关联到的对象，会 “STW”，但持续时间很短，速度很快。</li><li>并发标记（concurrent mark），从 GC Roots 的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但不需要停顿用户线程，可以与垃圾回收线程一起并发运行。</li><li>重新标记（remark），为了修正在并发标记期间，因用户程序继续运作而导致标记产生变动的对象的标记记录（增量更新），这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。</li><li>并发清除（concurrent sweep），清理标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以该阶段也可以与用户线程同时并发的。</li></ul><p>其中 <strong>初始标记</strong> 和 <strong>重新标记</strong> 仍然会 “STW”，但时间较短，所以从总体来说，CMS 回收器的回收过程是与用户线程一起并发执行的。</p><p><img src="/java/jvm-a1fb6fd89ac6/image-20230708154652640.png" alt="CMS"></p><p>通过参数：<code>-XX:+UseConcMarkSweepGC</code>，老年代使用 CMS 垃圾回收器。</p><p>缺点：</p><p>1）降低总吞吐量</p><p>对于面向并发设计的程序，都对处理器资源比较敏感，CMS 在并发标记阶段，虽然不会导致用户线程停顿，但会因为占用了一部分线程而导致应用程序变慢，降低总吞吐量。</p><p>CMS 默认启动的回收线程数是 (CPU 数量 + 3) / 4，也就是当 CPU 在 4 个以上时，并发回收时垃圾回收线程不少于 25% 的 CPU 资源，并且随着 CPU 数量的增加而下降。但是当 CPU 不足 4 个（如 2 个）时，CMS 对用户程序的影响就可能变得很大，本来 CPU 负载就比较大，还分出一半的运算能力去执行回收器线程，就可能导致用户程序的执行速度忽然降低了 50%，让人无法接受。</p><p>解决方案：升级配置，提升处理器核心数</p><p>2）并发失败（Concurrent Mode Failure）问题</p><p>CMS 回收器无法处理浮动垃圾（Floating Garbage），可能出现 “Concurrent Mode Failure” 失败而导致另一次 Full GC 的产生。</p><blockquote><p>执行 CMS GC 的过程中，用户线程也在运行，伴随程序运行自然就会有新的垃圾不断产生，这部分垃圾出现在标记过程之后，CMS 无法在当次回收中处理掉它们，只好留待下一次 GC 时再清理掉。这一部分垃圾就称为 “浮动垃圾”。</p></blockquote><p>由于在 CMS GC 阶段用户线程还在运行，就需要预留足够的内存给用户线程使用，因此 CMS 回收器不能像其他回收器那样等到老年代几乎完全被填满了再进行回收，需要预留一部分空间提供并发回收时的程序运作使用。</p><p>在 JDK 1.5 的默认设置下，CMS 回收器当老年代使用了 68% 的空间后就会被激活，这是一个偏保守的设置，如果在应用中老年代增长不是太快，可以适当调高参数 <code>-XX:CMSInitiatingOccupancyFraction</code> 的值来提高触发百分比，以便降低内存回收次数从而获取更好的性能。</p><p>在 JDK 1.6 中，CMS 回收器的启动阈值已经提升至 92%。要是 CMS 运行期间预留的内存无法满足程序需要，就会出现一次 “Concurrent Mode Failure” 失败，这时虚拟机将启动后备预案：临时启用 Serial Old 回收器来重新进行老年代的垃圾回收，这样停顿时间就很长了。</p><p>所以参数 <code>-XX:CM SInitiatingOccupancyFraction</code> 设置得太高很容易导致大量 “Concurrent Mode Failure” 失败，性能反而降低。</p><p>解决方案：必须预留足够的空间供并发回收时程序运行使用，配置 <code>-XX:CMSInitiatingOccupancyFraction</code> 的值来提高 CMS 的触发百分比，JDK 1.8 默认值是 92%，代表老年代的空间占用率达到 92% 的时候会触发回收过程。</p><p>3）内存碎片问题</p><p>CMS 是基于 “标记-清除” 算法实现的回收器，这意味着回收结束时会有大量空间碎片产生。空间碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很大空间剩余，但是无法找到足够大的 <strong>连续空间</strong> 来分配当前对象，不得不提前触发一次 Full GC。</p><p>解决方案：CMS 回收器提供了一个 <code>-XX:+UseCMSCompactAtFullCollection</code> 开关参数（默认开启），用于在 CMS 回收器不得不进行 Full GC 时开启内存碎片的合并整理过程，由于该过程无法并发，空间碎片的问题没有了，但停顿时间又会变长。虚拟机设计者还提供了另外一个参数 <code>-XX:CMSFullGCsBeforeCompaction</code>（JDK 9 后废除），该参数的作用是要求 CMS 回收器在执行过若干次（数量由参数值决定）不整理空间的 Full GC 之后，下一次进入 Full GC 前会先进行碎片整理（默认值为 0，表示每次进入 Full GC 时都进行碎片整理）。</p><p>适用场景：大型的互联网系统中用户请求数据量大、频率高的场景，比如订单接口、商品接口等。</p><h5 id="PS-PO">PS + PO</h5><h6 id="Parallel-Scavenge">Parallel Scavenge</h6><p>Parallel Scavenge 回收器是一个新生代回收器，它也是使用 <strong>复制</strong> 算法的回收器，又是 <strong>并行</strong> 的多线程回收器。</p><p>特点：</p><ol><li>CMS 等回收器的关注点是尽可能地缩短 STW 的时间，而 Parallel Scavenge 回收器的目标则是达到一个 <strong>可控制</strong> 的吞吐量。</li><li>由于与吞吐量关系密切，Parallel Scavenge 回收器也经常称为&quot;吞吐量优先&quot;回收器。</li><li>优点：可控制的吞吐量、高吞吐量、高效利用 CPU、垃圾回收的自适应的调节策略。</li></ol><p>STW 时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验，而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</p><p>Parallel Scavenge 回收器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾回收停顿时间的 <code>-XX:MaxGCPauseMillis</code> 参数以及直接设置吞吐量大小的 <code>-XX:GCTimeRatio</code> 参数：</p><p>1）MaxGCPauseMillis 参数允许的值是一个大于 0 的毫秒数，回收器将尽可能地保证内存回收花费的时间不超过设定值。</p><p>2）GCTimeRatio 参数的值应当是一个大于 0 且小于 100 的整数，也就是垃圾回收时间占总时间的比率，相当于是吞吐量的倒数。如果把此参数设置为 19，那允许的最大 GC 时间就占总时间的 5%（即 1 / (1 + 19)），默认值为 99，就是允许最大 1%（即 1 / (1 + 99)）的垃圾回收时间。</p><p>Parallel Scavenge 回收器的参数 <code>-XX:+UseAdaptiveSizePolicy</code> 值得关注。这是一个开关参数，当这个参数打开之后，就不需要手动指定新生代的大小（-Xmn）、Eden 与 Survivor 区的比例（-XX:SurvivorRatio）、晋升老年代对象年龄（-XX:PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况回收性能监控信息，动态调整这些参数以提供 <strong>最合适的停顿时间或者最大的吞吐量</strong>，这种调节方式称为 GC 自适应的调节策略（GC Ergonomics）。</p><p>如果对于回收器运作原理不太了解，手动优化存在困难的时候，使用 Parallel Scavenge 回收器配合自适应调节策略，把内存管理的调优任务交给虚拟机去完成将是一个不错的选择。</p><p>只需要把基本的内存数据设置好（如 -Xmx 设置最大堆），然后使用 MaxGCPauseMillis 参数（更关注最大停顿时间）或 GCTimeRatio（更关注吞吐量）参数给虚拟机设立一个优化目标，那具体细节参数的调节工作就由虚拟机完成了。</p><p>自适应调节策略也是 Parallel Scavenge 回收器与 ParNew 回收器的一个重要区别。</p><h6 id="ParallelOld">ParallelOld</h6><p>Parallel Old 是 Parallel Scavenge 收集器的老年代版本，使用多线程和 “标记-整理” 算法。</p><p>这个收集器是在 JDK 1.6 中才开始提供的，在此之前，新生代的 Parallel Scavenge 收集器一直处于比较尴尬的状态，原因是，如果新生代选择了 Parallel Scavenge 收集器，老年代除了 Serial Old 收集器外别无选择（Parallel Scavenge 收集器无法与 CMS 收集器配合工作），由于老年代 Serial Old 收集器在服务端应用性能上的 “拖累”，使用了 Parallel Scavenge 收集器也未必能在整体应用上获得吞吐量最大化的效果，在老年代很大而且硬件比较高级的环境中，这种组合的吞吐量甚至还不一定有 ParNew + CMS 的组合 “给力”。</p><p>直到 Parallel Old 收集器出现后，“吞吐量优先” 收集器终于有了比较名副其实的应用组合，在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge + Parallel Old 收集器。</p><p>使用参数：<code>-XX:+UseParallelGC</code> 或者 <code>-XX:+UseParallelOldGC</code> 可以使用 PS + PO 的组合。</p><h5 id="G1">G1</h5><h6 id="概述-5">概述</h6><p>在 JDK 9 之后，默认的垃圾回收器就是 G1（Garbage First）。</p><ul><li>Parallel Scavenge 回收器关注的是吞吐量，允许用户设置最大暂停时间，但是会减少新生代可用空间的大小。</li><li>CMS 关注最大暂停时间，但是吞吐量会下降。</li></ul><p>而 G1 回收器的目标就是融合上面两种垃圾回收器的优点：</p><ol><li>支持巨大的堆空间回收，并具有较大的吞吐量。</li><li>支持多 CPU 并行垃圾回收</li><li>允许 用户设置最大暂停时间。</li></ol><p>G1 垃圾回收器将堆内存划分成了一些大小相等的区域（Region），分为 Eden，Survivor、Old、Humongous 区。</p><p>每一个 Region 的大小为：</p><ol><li>可以通过 (堆空间大小 / 2048) 得到</li><li>也可以通过参数 <code>-XX:G1HeapRegionSize=值</code> 指定。取值范围为 1m 到 32m，且只能是 2 的幂数。</li></ol><p>如：</p><p><img src="/java/jvm-a1fb6fd89ac6/image-20240121145637502.png" alt="G1"></p><h6 id="垃圾回收方式">垃圾回收方式</h6><p>G1 垃圾回收器有两种方式：</p><ol><li>新生代回收（Young GC）</li><li>混合回收（Mixed GC）</li></ol><p>新生代回收，主要是回收 Eden 区和 Survivor 区中不用的对象，该过程会导致 STW。</p><p>在 G1 中可以通过参数 <code>-XX:MaxGCPauseMillis=n</code>（默认 200）设置每次垃圾回收时最大暂停时间毫秒数，G1 垃圾回收器会尽量保证暂停时间。</p><p>新生代的回收流程：</p><ol><li>首先新创建的对象会分配到 Eden 区，随着不断的添加，G1 会判断出新生代内存不足，阈值默认是 60%，即当新生代中 Eden 和 Survivor 占了总堆的 60% 以上时，会产生 Young GC。</li><li>标记 Eden 和 Survivor 区中的存活对象。</li><li>根据配置的最大暂停时间选择某些区域将存活对象复制到新的 Survivor 区中（对象年龄加 1），并清空这些区域，由于使用 “标记-复制” 算法，并不会产生内存碎片。</li><li>后续的 Young GC 与上面相同，只是将 Survivor 区中存活的对象搬运到另一个 Survivor 区。</li><li>当某个存活对象的年龄达到阈值，将被放入老年代。</li><li>注意，对于部分大小超过 Region 一半的大对象，会直接放入老年代，这部分老年代也被称为 Humongous 区（横跨多个 Region）</li><li>多次回收后，出现了很多 Old 区，当 Old 区在总堆占有率达到阈值（<code>-XX:InitiatingHeapOccupancePercent</code> 默认 45%）时，会触发混合回收，即 Mixed GC，回收所有新生代、老年代和 Humongous 区的对象，采用复制算法。</li></ol><p>注意：G1 在进行 Young GC 的过程中会记录每次垃圾回收时每个 Eden 区和 Survivor 区的平均耗时，以作为下次回收时的参考。这样就可以根据配置的最大暂停时间计算出本次回收时最多能回收 Region 区域的数量。</p><p>比如 <code>-XX:MaxGCPauseMillis=200</code> 每个 Region 回收耗时 40ms，那么这次回收最多只能回收 4 个 Region 区域。</p><p>混合回收，分为四个阶段：</p><ol><li>初始标记（initial mark）：仅仅只是标记 GC Roots 能直接关联到的对象，会 “STW”，但持续时间很短，速度很快。</li><li>并发标记（concurrent mark）：从 GC Roots 的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但不需要停顿用户线程，可以与垃圾回收线程一起并发运行。</li><li>重新标记（remark）：为了修正在并发标记期间，由于引用改变而漏标的对象（即由于引用的改变而重新存活的对象），对于引用的改变而变为垃圾的对象，G1 会等到下一次 Mixed GC 再去处理。所以 G1 的重复标记阶段，要远比 CMS 来的快。</li><li>并发清理（cleanup）：采用复制算法，不会产生内存碎片，可以和用户线程并行执行，对于该阶段，G1 也做了深层次的优化，它不会将所有的区域全部进行回收，对于老年代， G1 只会选择一些存活率较低的区域来进行回收，这样保证回收效率最高，这也是 G1 名称的由来。</li></ol><p>注意：如果清理过程中没有足够的空 Region 存放转移的对象，会触发 Full GC，使用单线程执行 “标记-整理” 算法， 此时会导致用户线程的暂停，所以尽量保证堆内存有一定多余的空间。</p><h5 id="总结-2">总结</h5><p>垃圾回收器的组合关系虽然很多，但是针对几个特定的版本，比较好的组合选择如下：</p><ul><li>JDK 8 及之前： ParNew + CMS（关注暂停时间）、Parallel Scavenge + Parallel Old（关注吞吐量）、 G1（JDK 8 之前不建议）</li><li>JDK 9 之后：G1（默认，较大堆并且关注暂停时间）</li></ul>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>jvm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis 中的 IO 模型</title>
    <link href="/java/redis-75ba9f9c982a/"/>
    <url>/java/redis-75ba9f9c982a/</url>
    
    <content type="html"><![CDATA[<h1>redis 中的 IO 模型</h1><p>之前我们讨论到 redis 为什么那么快时，提到了 redis 中的 IO 模型，为了说明 redis 中的 IO 模型，又不得不提到那几种 IO 模型。</p><h2 id="五种-IO-模型">五种 IO 模型</h2><p>在《操作系统》这门课中，我们已经知道了什么是用户空间和内核空间、什么是普通指令和特权指令、什么是用户态和内核态。</p><p>在某些情况下，用户程序需要调用一些特权资源或者是调用一些内核空间的操作，那么此时需要在用户态和内核态之间进行切换。</p><p>如 Linux 系统为了提高 IO 效率，会在用户空间和内核空间加入缓冲区：</p><ul><li>写数据（写到磁盘或网卡）时，将用户缓冲数据拷贝到内核缓冲区，然后写入磁盘或网卡。</li><li>读数据（读到内存）时，要从设备读取数据到内核缓冲区，然后拷贝到用户缓冲区。</li></ul><p>所以，用户程序在读写数据时，会向内核态申请，读取内核的数据，而内核数据要等待驱动程序从硬件上读取数据，当从磁盘或网卡上加载到数据之后，内核会将数据写入到内核的缓冲区中，然后再将数据拷贝到用户态的 buffer 中，然后再返回给应用程序。</p><p>这个过程的速度较慢，主要体现在下面两点：</p><ol><li>用户程序在 read 读数据时，如果内核空间没有将数据准备好，写入到 buffer，那么用户进程则需要等待。</li><li>数据的拷贝，数据需要从内核空间向用户空间拷贝。</li></ol><p>为了提升性能，我们希望 read 或者 wait for read 最好不要等待，或者等待的时间尽量的短。</p><p>上面描述的过程如下图所示：</p><p><img src="/java/redis-75ba9f9c982a/image-20240113032829044.png" alt="过程"></p><p>而在《UNIX 网络编程》一书中，描述了 5 种 IO 模型：</p><ul><li>阻塞 IO（Blocking IO）</li><li>非阻塞 IO（Nonblocking IO）</li><li>IO 多路复用（IO Multiplexing）</li><li>信号驱动 IO（Signal Driven IO）</li><li>异步 IO（Asynchronous IO）</li></ul><h3 id="阻塞-IO">阻塞 IO</h3><p>所谓阻塞 IO，是指在用户从发起读请求开始，一直到读取到数据，都是阻塞的状态。</p><p>过程如下图：</p><p><img src="/java/redis-75ba9f9c982a/image-20240113143358701.png" alt="阻塞 IO"></p><p>用户读取数据时，发起 recvform 命令，尝试从内核加载数据，如果内核没有数据，则用户进入阻塞，此时内核从硬件上读取数据，内核读取数据之后，会把数据拷贝到用户态，并且返回，整个过程，都是阻塞的，这就是阻塞 IO。顾名思义，阻塞 IO 就是两个阶段都必须阻塞等待。</p><p>阶段一：用户进程尝试读取数据（如网卡数据、磁盘数据），此时数据尚未到达，内核需要等待数据，用户进程也处于阻塞状态。</p><p>阶段二：数据到达并拷贝到内核缓冲区，代表已就绪，内核将内核数据拷贝到用户缓冲区，拷贝过程中，用户进程依然阻塞，只有当拷贝完成，用户进程重新恢复运行，处理数据。</p><p>在阻塞 IO 模型中，用户进程在两个阶段都是阻塞状态。</p><h3 id="非阻塞-IO">非阻塞 IO</h3><p>非阻塞 IO，就是指 recvfrom 操作会立即返回结果而不是阻塞用户进程。</p><p><img src="/java/redis-75ba9f9c982a/image-20240113143506342.png" alt="非阻塞 IO"></p><p>在非阻塞 IO 模型中，用户进程第一个阶段是非阻塞，而第二个阶段是阻塞状态。</p><p>虽然是非阻塞，但性能并没有得到提高。而且轮询机制会导致 CPU 空转，CPU 使用率暴增。</p><h3 id="IO-多路复用">IO 多路复用</h3><p>无论是阻塞 IO 还是非阻塞 IO，在一阶段，用户程序都需要调用 recvfrom 来获取数据，要么是阻塞，要么是不断轮询，都不能充分发挥 CPU 的作用。</p><p>所以这两种方式性能都不太好。</p><p>而在单线程下，只能依次处理 IO 事件，而像阻塞 IO 和非阻塞 IO 这种需要排队等待，如果正在处理的 IO 事件未就绪（数据不可读或不可写），线程就会被阻塞或者持续 CPU 导致空转，所有其他的 IO 事件都必须等待。</p><p>对于这种情况，我们不妨打个比喻，就像在餐馆点餐，多个顾客和一个服务员：</p><ul><li>阻塞 IO：顾客们排队等待，只能一个接一个的点，服务员也只能一次处理一个顾客的请求。</li><li>非阻塞 IO：顾客们也是排队等待，但是服务员不断询问队头的顾客，直到这个顾客点完为止。</li></ul><p>而现在的餐馆，一般是这样的，顾客进餐馆后，直接找到座位坐下，然后用手机扫描桌上的二维码进行点餐，服务员只需要在点餐台的电脑上查看有哪些顾客点了餐，并将这些交给厨师准备就可以了。</p><p>事实上，这样的流程就类似于 IO 多路复用，其模型如下：</p><p><img src="/java/redis-75ba9f9c982a/image-20240113144131327.png" alt="IO 多路复用"></p><p>在上面的例子中，服务员通过点餐台的电脑知道有顾客点好餐了，那么在 IO 模型中，用户进程是如何知道内核中数据是否就绪呢？</p><p>这个问题的解决依赖于 Linux 中的文件描述符（File Descriptor）简称 FD，它是一个从 0 开始的无符号整数，用来关联 Linux 中的一个文件。在 Linux 中，一切皆文件，如常规文件、视频、硬件设备等，当然也包括网络套接字（Socket）。</p><p>阶段一：用户进程调用 select，指定要监听的 FD 集合，那么内核就会监听 FD 对应的多个 socket，任意一个或多个 socket 数据就绪则返回 readable，这个过程中用户进程阻塞。</p><p>阶段二：用户进程找到就绪的 socket，依次调用 recvfrom 读取数据，内核将数据拷贝到用户空间后，用户进程处理数据。</p><p>当用户进程读取数据时，不再直接调用 recvfrom，而是调用 select 函数，select 函数会将需要监听的 FD 交给内核，由内核去检查 FD 的数据是否就绪了，如果数据就绪，就会通知用户进程数据就绪，然后来读取数据，再从内核中把数据拷贝给用户态，完成数据处理，如果 N 多个 FD 一个都没处理完，此时就进行等待。</p><p>像 select 这样的系统调用，存在多种，常见的有：</p><ul><li>select</li><li>poll</li><li>epoll</li></ul><p>大致说明它们的区别，select 和 poll 在监听的数据准备好后，会将用户进程监听的整个 FD 集合拷贝到用户空间，用户进程需要在其中遍历，找到真正处理好的数据。</p><p>而 epoll，则是在内核将数据准备好后，将准备好的数据直接拷贝到用户空间，避免了遍历的开销。</p><p>IO 复用模式，用户进程阻塞在 select、poll、epoll 等系统调用上，而不是阻塞在 recvfrom 上，可以确保去读数据的时候，数据是一定存在的，其效率比原来的阻塞 IO 和非阻塞 IO 性能都要高。</p><h4 id="select-模式">select 模式</h4><p>select 模式是 Linux 早期使用的 IO 多路复用技术。</p><p>相关源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 类型别名 __fd_mask</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> __fd_mask;<br><br><span class="hljs-comment">/* fd_set 记录要监听的fd集合，及其对应状态 */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-comment">// fds_bits 是 long 类型数组，长度为 1024 / 32 = 32</span><br>    <span class="hljs-comment">// 共 1024 个 bit 位，每个 bit 位代表一个 fd，0 代表未就绪，1 代表就绪</span><br>    <span class="hljs-comment">// bitmap 的形式</span><br>    __fd_mask fds_bits[__FD_SETSIZE / __NFDBITS];<br>    <span class="hljs-comment">// ...</span><br>&#125; fd_set;<br><br><span class="hljs-comment">/* select 函数，用于监听 fd_set，也就是多个 fd 的集合 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">select</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-type">int</span> nfds, <span class="hljs-comment">// 要监视的 fd_set 的最大 fd + 1</span></span><br><span class="hljs-params">    fd_set *readfds,<span class="hljs-comment">// 要监听读事件的 fd 集合</span></span><br><span class="hljs-params">    fd_set *writefds,   <span class="hljs-comment">// 要监听写事件的 fd 集合</span></span><br><span class="hljs-params">    fd_set *exceptfds,  <span class="hljs-comment">// 要监听异常事件的 fd 集合</span></span><br><span class="hljs-params">    <span class="hljs-keyword">struct</span> timeval *timeout <span class="hljs-comment">// 超时时间，null-用不超时；0-不阻塞等待；大于0-固定等待时间</span></span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure><p>将要处理的数据封装为 FD，并在用户空间创建 FD 的数组（大小为监听的 FD 的最大值 + 1，但最大不超过 1023），同时在数组中，需要标识控制哪些数据。</p><p>假设要监听的 socket 连接，其 FD 为 1、2、5，那么此时执行 select 函数，并将整个 fd 数组拷贝到内核空间，内核遍历整个数组，看是否有已经准备就绪的数据，若没有则内核进入阻塞，否则内核向用户进程返回可读条件，此时用户进程发起 recvfrom 系统调用，同时内核将 fd 数组再次拷贝到用户空间，拷贝完成后，向用户进程返回成功指示。</p><p>select 模式存在的问题是：</p><ul><li>整个 fd 数组在用户空间和内核空间需要拷贝两次。</li><li>由于内核将整个 fd 数组拷贝到用户空间，所以用户进程需要遍历整个 fd 数组才能知道哪些数据就绪。</li><li>整个 fd 数组的大小是固定的，是 1024。</li></ul><h4 id="poll-模式">poll 模式</h4><p>poll 模式对 select 模式做了简单改进，但性能提升不明显。</p><p>相关源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// pollfd 中的事件类型</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> POLLIN     <span class="hljs-comment">// 可读事件</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> POLLOUT    <span class="hljs-comment">// 可写事件</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> POLLERR    <span class="hljs-comment">// 错误事件</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> POLLNVAL   <span class="hljs-comment">// fd 未打开</span></span><br>...<br><br><span class="hljs-comment">// pollfd 结构</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pollfd</span> &#123;</span><br>    <span class="hljs-type">int</span> fd;        <span class="hljs-comment">// 要监听的 fd</span><br>    <span class="hljs-type">short</span> <span class="hljs-type">int</span> events;  <span class="hljs-comment">// 要监听的事件类型：读、写、异常</span><br>    <span class="hljs-type">short</span> <span class="hljs-type">int</span> revents; <span class="hljs-comment">// 实际发生的事件类型</span><br>&#125;;<br><br><span class="hljs-comment">// poll 函数</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">poll</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-keyword">struct</span> pollfd *fds, <span class="hljs-comment">// pollfd 数组，可以自定义大小</span></span><br><span class="hljs-params">    <span class="hljs-type">nfds_t</span> nfds,    <span class="hljs-comment">// 数组元素个数</span></span><br><span class="hljs-params">    <span class="hljs-type">int</span> timeout <span class="hljs-comment">// 超时时间</span></span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure><p>具体 IO 流程</p><ul><li>首先创建 pollfd 数组，向其中添加监听的 fd 的信息，由于可以自定义数组大小，所以理论上能够监听的 fd 的数量是无限的。</li><li>接着调用 poll 函数，将 pollfd 数组拷贝到内核空间，转为链表存储，无上限。</li><li>然后内核遍历 fd，判断是否就绪。</li><li>如果数据就绪或超时后，则拷贝 pollfd 数组到用户空间，返回就绪 fd 的数量 n。</li><li>用户进程判断 n 是否大于 0，大于 0 则遍历 pollfd 数组，找到就绪的 fd 进一步处理。</li></ul><p><strong>与 select 对比</strong></p><ul><li>select 模式中的 fd_set 大小固定为 1024，而 pollfd 在内核中采用链表，理论上无上限。</li><li>但是如果监听 fd 越多，每次遍历消耗时间也越久，性能反而会下降，所以实际上 poll 模式中的 fd 个数也不是无限的。</li></ul><h4 id="epoll-模式">epoll 模式</h4><p>epoll 模式是相对于 select 和 poll 的巨大的改进。它主要提供了 3 个函数。相关源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">eventpoll</span> &#123;</span><br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rb_root</span>  <span class="hljs-title">rbr</span>;</span>     <span class="hljs-comment">// 红黑树，记录要监听的 FD</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">rdlist</span>;</span> <span class="hljs-comment">// 链表，记录就绪的 FD</span><br>    <span class="hljs-comment">//...</span><br>&#125;;<br><br><span class="hljs-comment">// 1.创建一个 epoll 实例，内部是 event poll，返回对应的句柄 epfd</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">epoll_create</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span>;<br><br><span class="hljs-comment">// 2.将一个 FD 添加到 epoll 的红黑树中，并设置 ep_poll_callback</span><br><span class="hljs-comment">// callback 触发时，就把对应的 FD 加入到 rdlist 就绪列表中</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">epoll_ctl</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-type">int</span> epfd,     <span class="hljs-comment">// epoll 实例的句柄</span></span><br><span class="hljs-params">    <span class="hljs-type">int</span> op,       <span class="hljs-comment">// 要执行的操作，包括：ADD、MOD、DEL</span></span><br><span class="hljs-params">    <span class="hljs-type">int</span> fd,       <span class="hljs-comment">// 要监听的 FD</span></span><br><span class="hljs-params">    <span class="hljs-keyword">struct</span> epoll_event *event  <span class="hljs-comment">// 要监听的事件类型：读、写、异常等</span></span><br><span class="hljs-params">)</span>;<br><br><span class="hljs-comment">// 3.检查 rdlist 列表是否为空，不为空则返回就绪的 FD 的数量</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">epoll_wait</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-type">int</span> epfd,                   <span class="hljs-comment">// epoll 实例的句柄</span></span><br><span class="hljs-params">    <span class="hljs-keyword">struct</span> epoll_event *events, <span class="hljs-comment">// 空 event 数组，用于接收就绪的 FD</span></span><br><span class="hljs-params">    <span class="hljs-type">int</span> maxevents,              <span class="hljs-comment">// events 数组的最大长度</span></span><br><span class="hljs-params">    <span class="hljs-type">int</span> timeout   <span class="hljs-comment">// 超时时间，-1 用不超时；0 不阻塞；大于 0 为阻塞时间</span></span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure><p>具体 IO 流程：</p><ul><li>用户进程首先调用 epoll_create 创建 epoll 实例，并返回对应的句柄 epfd。</li><li>接着调用 epoll_ctl 将一个 fd 添加到 epoll 实例中的红黑树中，并设置对应的回调 ep_poll_callback。当该回调触发时，就会将对应的 fd 从红黑树中添加到就绪链表中。</li><li>然后调用 epoll_wait，此时会在用户空间创建一个空的 events 数组存放就绪的 fd，并检查就绪链表，该过程需要参考配置的 timeout，看是一直等待、等待指定的时间或者不等待。</li><li>假设此时数据准备完毕，那么就会触发 ep_poll_callback，并将就绪的 fd 添加到就绪队列，恰好此时调用了 epoll_wait，检查就绪队列发现有数据，就会将数据拷贝到 event 数组中，并返回对应就绪的 fd 的数量，用户进程收到响应后，从 events 中获取对应的数据，并处理。</li></ul><p>epoll 相比于 poll 和 select 的优化在什么地方？</p><ul><li>首先，select 模式，它主要做了两件事，即监听 fd，将 fd 拷贝到内核，以及等待这些 fd 就绪。而 epoll 模式将这两个功能拆分为了两个函数，epoll_ctl 就是监听 fd，而 epoll_wait 才是等待 fd 就绪，那么如果监听一个 fd，epoll 模式中只需要 <strong>执行一次</strong> epoll_ctl 将 fd 加入到红黑树即可，以后都是循环执行 epoll_wait，所以这就避免了在 select 模式中不断将整个 fd 数组在内核空间和用户空间的来回拷贝的情况。</li><li>其次，在 select 模式和 poll 模式中，每一次需要把内核中的所有 fd 都拷贝回用户空间，无论是就绪还是没就绪，而 epoll 模式只需要拷贝就绪的 fd，这也提升了性能，同时，用户进程也无需像在 select 和 poll 模式那样遍历整个 fd 数组，找到就绪的 fd，因为 epoll 模式中拷贝到用户空间的都是就绪的 fd，那么用户进程可以直接获取使用。</li><li>最后是 fd 的数量问题，select 模式中，能监听的 fd 数组的最大数量就是 1024，而在 poll 模式中，底层采用链表存储这些 fd，虽然允许监听的 fd 的数量没有上限，但是如果 fd 数量过多，遍历链表的性能不可忽略，而在 epoll 模式中，使用红黑树存储监听的 fd，而红黑树的性能是很稳定的，不会因为节点的增多导致查询性能的下降，所以 epoll 模式是真的可以尽可能多的监听 fd。</li></ul><h4 id="事件通知机制">事件通知机制</h4><p>当 fd 可读时，调用 epoll_wait 可以得到通知，但是通知的模式有两种：</p><ul><li>LevelTriggered：LT，当 fd 有数据可读时，会重复通知用户进程多次，每调用一次 epoll_wait 则通知一次，直到数据处理完毕，这是 epoll 的默认模式。</li><li>EdgeTriggered：ET，当 fd 有数据可读时，无论数据是否处理完毕，用户进程都只会被通知一次。</li></ul><p>一个例子：</p><ul><li>假设一个客户端 socket 对应的 fd 已经注册到了 epoll 实例中。</li><li>客户端 socket 发送了 2kb 的数据。</li><li>服务端调用 epoll_wait，并得到内核的可读通知。</li><li>那么服务端从 fd 读取了 1kb 数据。</li><li>由于数据没有读完毕，所以需要再次调用 epoll_wait 循环读取。</li></ul><p>如果采用 LT 模式，因为 fd 中仍有 1kb 数据未读，则循环调用 epoll_wait，此时用户进程会再一次得到可读通知。而如果采用 ET 模式，那么在第一次调用 epoll_wait 时，用户进程已经得到一次可读通知，后续即使数据没有读完，也不会再接受到可读通知。</p><p>采用 LT 模式，那么通知频率很高，会存在很多重复通知，影响性能，同时可能出现惊群现象，而 ET 模式只会通知一次，效率高，我们可以基于非阻塞 IO 循环读取解决数据读取不完整问题。</p><h3 id="信号驱动-IO">信号驱动 IO</h3><p>信号驱动 IO 是与内核建立 SIGIO 的信号处理程序并设置回调，当内核有 FD 就绪时，会发出 SIGIO 信号通知用户，期间用户应用可以执行其它业务，无需阻塞等待。</p><p>阶段一：用户进程调用 sigaction，注册信号处理函数，此时用户进程不进入阻塞，可以执行其它业务，当内核数据就绪后，回调用户进程的 SIGIO 处理函数。</p><p>阶段二：用户进程收到 SIGIO 回调信号，则调用 recvfrom，内核将数据拷贝到用户空间，接着用户进程处理数据。</p><p>但是当有大量 IO 操作时，信号较多，SIGIO 处理函数不能及时处理可能导致信号队列溢出，而且内核空间与用户空间的频繁信号交互性能也较低。</p><p><img src="/java/redis-75ba9f9c982a/image-20240113144831625.png" alt="信号驱动 IO"></p><h3 id="异步-IO">异步 IO</h3><p>用户进程先内核发起 aio_read 系统调用，该系统调用立即返回，并且在等待 IO 期间，用户进程不会阻塞，当内核将将数据从内核空间拷贝到用户空间后，由内核通知用户进程数据准备完毕。</p><p>与信号驱动 IO 的区别：</p><ul><li>信号驱动 IO 是由内核通知用户进程何时启动一个 IO 操作。</li><li>异步 IO 是由内核通知用户进程何时 IO 操作完成。</li></ul><p><img src="/java/redis-75ba9f9c982a/image-20240113145231698.png" alt="异步 IO"></p><h3 id="几种-IO-模型的对比">几种 IO 模型的对比</h3><p>前 4 种模型的主要区别在于阶段一的处理，因为它们的阶段二是一致的，都是在数据从内核复制到用户空间，进程阻塞于 recvfrom 调用。而异步 IO 没有阻塞阶段。</p><p>这里就可以描述同步 IO 和异步 IO：</p><ul><li>同步 IO：导致请求进程阻塞，直到 IO 操作完成。</li><li>异步 IO：不会导致请求进程阻塞。</li></ul><p>所以只有异步 IO 模型是一种异步 IO 操作。</p><p><img src="/java/redis-75ba9f9c982a/image-20240113145915698.png" alt="对比"></p><h2 id="redis-中的-IO-模型">redis 中的 IO 模型</h2>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-938c4142" role="button" aria-expanded="false" aria-controls="collapse-938c4142">        <div class="fold-arrow">▶</div>源码下载      </div>      <div class="fold-collapse collapse" id="collapse-938c4142">        <div class="fold-content">          <p><a href="https://github.com/redis/redis/releases">下载 redis 6.2.6</a></p>        </div>      </div>    </div>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-9997dce9" role="button" aria-expanded="false" aria-controls="collapse-9997dce9">        <div class="fold-arrow">▶</div>了解 java nio      </div>      <div class="fold-collapse collapse" id="collapse-9997dce9">        <div class="fold-content">          <p><a href="/java/javase-beb1cfdacc32/" title="java nio">java nio</a></p>        </div>      </div>    </div><p>我们在上面已经说明了五种 IO 模型，那么接下来说说在 redis 中的 IO 模型。</p><p>在 redis 中，通过 IO 多路复用来提高网络性能，并且支持各种不同的多路复用实现，如 epoll、evport、kqueue、select，并对这些实现进行了封装，提供了统一的高性能时间 API 库：</p><p>通过判断当前系统来选择具体的 IO 多路复用的实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Include the best multiplexing layer supported by this system.</span><br><span class="hljs-comment"> * The following should be ordered by performances, descending. */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> HAVE_EVPORT</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ae_evport.c&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> HAVE_EPOLL</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ae_epoll.c&quot;</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>        <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> HAVE_KQUEUE</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ae_kqueue.c&quot;</span></span><br>        <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>        <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ae_select.c&quot;</span></span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>并提供了统一的封装的 API（在 src/ae.c）。</p><p>下面主要来看看 ae_epoll.c 文件，重要方法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 创建多路复用程序</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">aeApiCreate</span><span class="hljs-params">(aeEventLoop *eventLoop)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    state-&gt;epfd = epoll_create(<span class="hljs-number">1024</span>);<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// 注册 fd</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">aeApiAddEvent</span><span class="hljs-params">(aeEventLoop *eventLoop, <span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> mask)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">if</span> (epoll_ctl(state-&gt;epfd,op,fd,&amp;ee) == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// 删除 fd</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">aeApiDelEvent</span><span class="hljs-params">(aeEventLoop *eventLoop, <span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> delmask)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">if</span> (mask != AE_NONE) &#123;<br>        epoll_ctl(state-&gt;epfd,EPOLL_CTL_MOD,fd,&amp;ee);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">/* Note, Kernel &lt; 2.6.9 requires a non null event pointer even for</span><br><span class="hljs-comment">         * EPOLL_CTL_DEL. */</span><br>        epoll_ctl(state-&gt;epfd,EPOLL_CTL_DEL,fd,&amp;ee);<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// 等待 fd 就绪</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">aeApiPoll</span><span class="hljs-params">(aeEventLoop *eventLoop, <span class="hljs-keyword">struct</span> timeval *tvp)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    retval = epoll_wait(state-&gt;epfd,state-&gt;events,eventLoop-&gt;setsize,<br>        tvp ? (tvp-&gt;tv_sec*<span class="hljs-number">1000</span> + (tvp-&gt;tv_usec + <span class="hljs-number">999</span>)/<span class="hljs-number">1000</span>) : <span class="hljs-number">-1</span>);<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>那么接下来通过源码流程来看一下 redis 的 IO 模型到底是怎样运行的。</p><p>首先你需要找到 redis 的启动函数 main 函数，在 server.c 文件中，源码如下，这里我只给出了有关 IO 模型的重点源码部分：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">// 初始化服务</span><br>    initServer();<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">// 开始监听事件循环</span><br>    aeMain(server.el);<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们继续看 initServer 函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">initServer</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">// aeCreateEventLoop 内部会调用 aeApiCreate</span><br>    server.el = aeCreateEventLoop(server.maxclients+CONFIG_FDSET_INCR);<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">/* Open the TCP listening socket for the user commands. */</span><br>    <span class="hljs-comment">// 监听 TCP 端口，创建 ServerSocket，并得到 FD</span><br>    <span class="hljs-keyword">if</span> (server.port != <span class="hljs-number">0</span> &amp;&amp;<br>        listenToPort(server.port,&amp;server.ipfd) == C_ERR) &#123;<br>        serverLog(LL_WARNING, <span class="hljs-string">&quot;Failed listening on port %u (TCP), aborting.&quot;</span>, server.port);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">/* Create an event handler for accepting new connections in TCP and Unix</span><br><span class="hljs-comment">     * domain sockets. */</span><br>    <span class="hljs-comment">// 创建一个事件处理器，处理客户端连接，内部调用 aeApiAddEvent 监听当前 serverSocket FD</span><br>    <span class="hljs-comment">// 而 acceptTcpHandler 就是一个接受 TCP 请求的处理器</span><br>    <span class="hljs-comment">// 当有客户端连接到 ServerSocket，那么就会触发 acceptTcpHandler，这类似于回调机制</span><br>    <span class="hljs-keyword">if</span> (createSocketAcceptHandler(&amp;server.ipfd, acceptTcpHandler) != C_OK) &#123;<br>        serverPanic(<span class="hljs-string">&quot;Unrecoverable error creating TCP socket accept handler.&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">/* Register before and after sleep handlers (note this needs to be done</span><br><span class="hljs-comment">     * before loading persistence since it is used by processEventsWhileBlocked. */</span><br>    <span class="hljs-comment">// 设置 epoll_wait 前的处理器</span><br>    aeSetBeforeSleepProc(server.el,beforeSleep);<br>    aeSetAfterSleepProc(server.el,afterSleep);<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>所以，initServer 函数，主要就做这么几件事，我们以 epoll 模式来说明：</p><ol><li>创建 epoll 实例，在内核中，相当于已经准备好了红黑树和链表。</li><li>接下来创建 ServerSocket，得到 FD，即上面代码中的 listenToPort。</li><li>然后将调用 createSocketAcceptHandler 函数，内部调用 aeApiAddEvent 监听当前的 server.ipfd，并绑定对应的回调处理方法，即 acceptTcpHandler，用于当客户端连接到 ServerSocket 时，触发该函数处理连接事件。</li><li>接下来你会发现调用了一个 aeSetBeforeSleepProc 函数，这是因为，在监听 FD 后，用户进程就会调用 epoll_wait 函数，等待 FD 就绪，这里就是在设置调用 epoll_wait 之前的处理器。</li></ol><p>当 initServer 调用完毕，那么准备工作就做好了，但是还没有开始真正调用 epoll_wait。</p><p>接下来看 aeMain 函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">aeMain</span><span class="hljs-params">(aeEventLoop *eventLoop)</span> &#123;<br>    eventLoop-&gt;stop = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (!eventLoop-&gt;stop) &#123;<br>        aeProcessEvents(eventLoop, AE_ALL_EVENTS|<br>                                   AE_CALL_BEFORE_SLEEP|<br>                                   AE_CALL_AFTER_SLEEP);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>继续跟进 aeProcessEvents</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">aeProcessEvents</span><span class="hljs-params">(aeEventLoop *eventLoop, <span class="hljs-type">int</span> flags)</span><br>&#123;<br>    <span class="hljs-comment">// 调用 epoll_wait 的前置处理器</span><br>    <span class="hljs-keyword">if</span> (eventLoop-&gt;beforesleep != <span class="hljs-literal">NULL</span> &amp;&amp; flags &amp; AE_CALL_BEFORE_SLEEP)<br>        eventLoop-&gt;beforesleep(eventLoop);<br><br>    <span class="hljs-comment">/* Call the multiplexing API, will return only on timeout or when</span><br><span class="hljs-comment">     * some event fires. */</span><br>    <span class="hljs-comment">// 等待 FD 就绪或者超时，返回就绪的 FD 的数量</span><br>    numevents = aeApiPoll(eventLoop, tvp);<br><br>    <span class="hljs-comment">/* After sleep callback. */</span><br>    <span class="hljs-comment">// 调用 epoll_wait 的后置处理器</span><br>    <span class="hljs-keyword">if</span> (eventLoop-&gt;aftersleep != <span class="hljs-literal">NULL</span> &amp;&amp; flags &amp; AE_CALL_AFTER_SLEEP)<br>        eventLoop-&gt;aftersleep(eventLoop);<br><br>    <span class="hljs-comment">// 循环处理就绪的 FD，调用对应的处理器</span><br>    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; numevents; j++) &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>此时一旦有客户端连接上来，那么 aeApiPoll 函数返回就绪 FD 的数量，并调用相应的处理器，对于 ServerSocket 来说，就是上面的 acceptTcpHandler 处理器，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">acceptTcpHandler</span><span class="hljs-params">(aeEventLoop *el, <span class="hljs-type">int</span> fd, <span class="hljs-type">void</span> *privdata, <span class="hljs-type">int</span> mask)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">while</span>(max--) &#123;<br>        <span class="hljs-comment">// 返回客户端连接的 FD</span><br>        cfd = anetTcpAccept(server.neterr, fd, cip, <span class="hljs-keyword">sizeof</span>(cip), &amp;cport);<br>        <span class="hljs-comment">// ... </span><br>        <span class="hljs-comment">// 接受连接的处理器</span><br>        acceptCommonHandler(connCreateAcceptedSocket(cfd),<span class="hljs-number">0</span>,cip);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 acceptCommonHandler 函数中的的一个重要函数是 createClient，创建客户端：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">client *<span class="hljs-title function_">createClient</span><span class="hljs-params">(connection *conn)</span> &#123;<br>    client *c = zmalloc(<span class="hljs-keyword">sizeof</span>(client));<br>    <span class="hljs-keyword">if</span> (conn) &#123;<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-comment">// 注册读处理器 readQueryFromClient，并在连接可读的时候被触发</span><br>        connSetReadHandler(conn, readQueryFromClient);<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">return</span> c;<br>&#125;<br></code></pre></td></tr></table></figure><p>整个服务端的注册和监听流程基本就是这样。</p><p>下面来看看客户端发送命令后的执行流程：</p><p>紧接着上面的 readQueryFromClient 函数，这是在客户端连接可读时触发的回调函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">readQueryFromClient</span><span class="hljs-params">(connection *conn)</span> &#123;<br>    <span class="hljs-comment">// 获取当前客户端，在客户端中有读写缓冲区</span><br>    client *c = connGetPrivateData(conn);<br><span class="hljs-comment">/* Check if we want to read from the client later when exiting from</span><br><span class="hljs-comment">     * the event loop. This is the case if threaded I/O is enabled. */</span><br>    <span class="hljs-comment">// 在 postponeClientRead 函数中，会调用 listAddNodeHead 函数将客户端添加到 server.clients_pending_read</span><br>    <span class="hljs-comment">// 队列，等待被写出</span><br>    <span class="hljs-keyword">if</span> (postponeClientRead(c)) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">// 获取查询缓冲区 querybuf 的大小</span><br>    qblen = sdslen(c-&gt;querybuf);<br>    <span class="hljs-keyword">if</span> (c-&gt;querybuf_peak &lt; qblen) c-&gt;querybuf_peak = qblen;<br>    c-&gt;querybuf = sdsMakeRoomFor(c-&gt;querybuf, readlen);<br>    <span class="hljs-comment">// 读取请求数据到 querybuf 缓冲区</span><br>    nread = connRead(c-&gt;conn, c-&gt;querybuf+qblen, readlen);<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">// 解析客户端中缓冲区字符串，转换为 redis 命令存入 c-&gt;argv 数组</span><br>    processInputBuffer(c);<br>&#125;<br></code></pre></td></tr></table></figure><p>跟入 processInputBuffer：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">processInputBuffer</span><span class="hljs-params">(client *c)</span> &#123;<br>    <span class="hljs-comment">// </span><br>    <span class="hljs-comment">/* We are finally ready to execute the command. */</span><br>    <span class="hljs-comment">// 真正开始执行命令</span><br>    <span class="hljs-keyword">if</span> (processCommandAndResetClient(c) == C_ERR) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>跟入 processCommandAndResetClient：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">processCommandAndResetClient</span><span class="hljs-params">(client *c)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">if</span> (processCommand(c) == C_OK) &#123;<br>        commandProcessed(c);<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>跟入 processCommand：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">processCommand</span><span class="hljs-params">(client *c)</span> &#123;<br>    <span class="hljs-comment">// 根据命令名称，查找命令对应的 command</span><br>    <span class="hljs-comment">/* Now lookup the command and check ASAP about trivial error conditions</span><br><span class="hljs-comment">     * such as wrong arity, bad command name and so forth. */</span><br>    c-&gt;cmd = c-&gt;lastcmd = lookupCommand(c-&gt;argv[<span class="hljs-number">0</span>]-&gt;ptr);<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">/* Exec the command */</span><br>    <span class="hljs-comment">// 执行命令</span><br>    <span class="hljs-keyword">if</span> (c-&gt;flags &amp; CLIENT_MULTI &amp;&amp;<br>        c-&gt;cmd-&gt;proc != execCommand &amp;&amp; c-&gt;cmd-&gt;proc != discardCommand &amp;&amp;<br>        c-&gt;cmd-&gt;proc != multiCommand &amp;&amp; c-&gt;cmd-&gt;proc != watchCommand &amp;&amp;<br>        c-&gt;cmd-&gt;proc != resetCommand)<br>    &#123;<br>        queueMultiCommand(c);<br>        <span class="hljs-comment">// 将执行结果写出</span><br>        addReply(c,shared.queued);<br>    &#125; <br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>跟入 addReply：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">addReply</span><span class="hljs-params">(client *c, robj *obj)</span> &#123;<br>    <span class="hljs-comment">// ... </span><br>    <span class="hljs-keyword">if</span> (sdsEncodedObject(obj)) &#123;<br>        <span class="hljs-comment">// 尝试将结果写入 c-&gt;buf 客户端写缓冲区，若 c-&gt;buf 写不下则写入 c-&gt;reply</span><br>        <span class="hljs-keyword">if</span> (_addReplyToBuffer(c,obj-&gt;ptr,sdslen(obj-&gt;ptr)) != C_OK)<br>            _addReplyProtoToList(c,obj-&gt;ptr,sdslen(obj-&gt;ptr));<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (obj-&gt;encoding == OBJ_ENCODING_INT) &#123;<br>        <span class="hljs-comment">/* For integer encoded strings we just convert it into a string</span><br><span class="hljs-comment">         * using our optimized function, and attach the resulting string</span><br><span class="hljs-comment">         * to the output buffer. */</span><br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">32</span>];<br>        <span class="hljs-type">size_t</span> len = ll2string(buf,<span class="hljs-keyword">sizeof</span>(buf),(<span class="hljs-type">long</span>)obj-&gt;ptr);<br>        <span class="hljs-keyword">if</span> (_addReplyToBuffer(c,buf,len) != C_OK)<br>            _addReplyProtoToList(c,buf,len);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        serverPanic(<span class="hljs-string">&quot;Wrong obj-&gt;encoding in addReply()&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么此时，结果就已经保存到了客户端的写缓冲区中，并且已经添加到了一个名为 server.clients_pending_read 的队列中，但是结果还没有写到 socket。</p><p>那么将结果写到 socket，这就要靠 beforeSleep 函数了，在这个函数中，有很多处理函数，用来处理不同的问题，其中与写结果相关的函数是 handleClientsWithPendingWritesUsingThreads</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">beforeSleep</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> aeEventLoop *eventLoop)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br> <span class="hljs-comment">/* Handle writes with pending output buffers. */</span><br>    handleClientsWithPendingWritesUsingThreads();<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>跟入 handleClientsWithPendingWritesUsingThreads：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">handleClientsWithPendingWritesUsingThreads</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">// 将迭代器指向 server.clients_pending_write 的队头</span><br>    listRewind(server.clients_pending_write,&amp;li);<br>    <span class="hljs-keyword">while</span>((ln = listNext(&amp;li))) &#123;<br>        client *c = listNodeValue(ln);<br>        <span class="hljs-keyword">if</span> (clientHasPendingReplies(c) &amp;&amp;<br>            <span class="hljs-comment">// 内部调用 aeApiAddEvent 监听 socket 的 FD 读事件</span><br>            <span class="hljs-comment">// 并绑定写处理器 sendReplyToClient，将响应写到客户端 socket</span><br>                connSetWriteHandler(c-&gt;conn, sendReplyToClient) == AE_ERR)<br>        &#123;<br>            freeClientAsync(c);<br>        &#125;<br>    &#125;<br>    listEmpty(server.clients_pending_write);<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>那么 sendReplyToClient 处理器就会调用 writeToClient 将结果写回到客户端。</p><p>最后再来看一下 redis 底层 IO 模型的整个流程：</p><p><img src="/java/redis-75ba9f9c982a/image-20240114145235824.png" alt="流程"></p><ul><li>首先会创建一个 ServerSocket，并将其 FD 注册到 EventLoop 上，这个 EventLoop 可以理解为一个 epoll 实例。</li><li>接着为 ServerSocket 绑定一个处理器 tcpAccpetHandler 来处理 ServerSocket 上的可读事件。</li><li>接下来执行 beforeSleep，执行完成如果还没有客户端连接上来，那么就调用 aeApiPoll 去等待就绪。</li><li>此时有客户端连接上来，就会触发 ServerSocket 上的读事件，并调用对应的处理器，将客户端 socket 的 FD 注册到 EventLoop 上。</li><li>此时 EventLoop 已经注册了 ServerSocket 和 Socket 的 FD，那么此时如果客户端 socket 可读，就会触发 socket 上的读事件，此时就会调用 readQueryFromClient 处理器，将请求数据写到客户端的查询缓冲区，并将其解析为 redis 命令，执行命令后将结果写到 buf 或者 reply，写好后将客户端加入到 server.clients_pending_write 队列。</li><li>然后在 beforeSleep 函数中，调用 handleClientsWithPendingWritesUsingThreads 函数，遍历 server.clients_pending_write 队列为每一个客户端绑定一个 sendReplyToClient 处理器，而 EventLoop 会监听 socket 连接的写事件，并在可写时调用这个处理器，真正的将客户端缓冲区的数据写到客户端的 socket 中。</li></ul><p>而实际上，你将整体看的简单一点，redis 的 IO 模型主要是上图中灰色的部分，它整体上就是 <strong>IO 多路复用和事件派发</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis 中有哪些高效的数据结构</title>
    <link href="/java/redis-25334f7a71a2/"/>
    <url>/java/redis-25334f7a71a2/</url>
    
    <content type="html"><![CDATA[<h1>redis 中有哪些高效的数据结构</h1><p>redis 性能如此优秀和高效的数据结构也离不开关系。</p><p>redis 中，数据是按键值对的方式存储的，而键值对又是按照一定的数据结构来组织的，操作键值对就是对数据结果进行 CRUD 操作。</p><p>所以高效的数据结构是 redis 快速处理数据的基础。</p><p>在 redis 中，值的数据类型有 String（字符串）、List（列表）、Hash（哈希）、Set（集合）和 Sorted Set（有序集合），而这些数据类型的底层则是由简单动态字符串、双向链表、压缩列表、哈希表、跳表以及整数数组构成的，它们的对应关系如下：</p><p><img src="/java/redis-25334f7a71a2/image-20240116172332248.png" alt="数据结构"></p><p>可以看到，String 类型的底层实现只有一种数据结构，也就是简单动态字符串。而 List、Hash、Set 和 Sorted Set 这四种数据类型，都有两种底层实现结构。通常情况下，我们会把这四种类型称为集合类型，它们的特点是 <strong>一个键对应了一个集合的数据</strong>。</p><p>而 redis 中的键则总是一个字符串对象 String。</p><p>为了实现客户端的键值访问，redis 使用一个全局哈希表来保存所有的键值对，而对于集合类型的值，则全局哈希表中存储的是指向该集合的指针（redis 用 c 写的）。</p><p><img src="/java/redis-25334f7a71a2/image-20240116173049145.png" alt="全局哈希表"></p><p>下面我们一一来看这些数据结构。</p>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-938c4142" role="button" aria-expanded="false" aria-controls="collapse-938c4142">        <div class="fold-arrow">▶</div>源码下载      </div>      <div class="fold-collapse collapse" id="collapse-938c4142">        <div class="fold-content">          <p><a href="https://github.com/redis/redis/releases">下载 redis 6.2.6</a></p>        </div>      </div>    </div><h2 id="1-简单动态字符串-SDS">1. 简单动态字符串 SDS</h2>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-076edf11" role="button" aria-expanded="false" aria-controls="collapse-076edf11">        <div class="fold-arrow">▶</div>源码位置      </div>      <div class="fold-collapse collapse" id="collapse-076edf11">        <div class="fold-content">          <figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">src</span><span class="hljs-punctuation">:</span><br>   <span class="hljs-bullet">-</span> <span class="hljs-string">sds.c</span><br>   <span class="hljs-bullet">-</span> <span class="hljs-string">sds.h</span><br></code></pre></td></tr></table></figure>        </div>      </div>    </div><p>redis 中保存的 key 是字符串，value 往往是字符串或者字符串的集合。所以字符串是 redis 中最常用的一种数据结构。</p><p>不过 redis 没有直接使用 c 语言中的字符串，因为 c 语言字符串存在很多问题：</p><ul><li>获取字符串长度的需要通过运算</li><li>非二进制安全</li><li>不可修改</li></ul><p>redis 构建了一种新的字符串结构，称为简单动态字符串（Simple Dynamic String），简称 SDS</p><p>例如，执行命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">set</span> name ocsio<br></code></pre></td></tr></table></figure><p>那么 redis 将在底层创建两个 SDS，其中一个是包含 “name” 的 SDS，另一个是包含 “ocsio” 的 SDS。</p><p>SDS 的结构体如下：以 sdshdr8 为例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">attribute__</span> ((__<span class="hljs-title">packed__</span>)) <span class="hljs-title">sdshdr8</span> &#123;</span><br>    <span class="hljs-type">uint8_t</span> len;  <span class="hljs-comment">/* buf[] 已经使用的长度 */</span><br>    <span class="hljs-type">uint8_t</span> alloc;  <span class="hljs-comment">/* 除去头信息和结束符的长度，申请的 buf 数组的长度*/</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> flags; <span class="hljs-comment">/* 其中 3bit 表示类型，剩余 5bit 未使用 */</span><br>    <span class="hljs-type">char</span> buf[];  <span class="hljs-comment">/* 字符数组 */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>值得说明的是，SDS 的结构体虽然包含 4 部分，但是 SDS 的指针是指向 buf 数组的，而不是结构体头部，这样的实现的好处在于：</p><ol><li>与 c 语言的字符串结构兼容</li><li>通过 SDS 的指针再向前就可以获取结构体头的大小（flag 字段），又可以进一步实际字符串的长度，这样保证了字符串的二进制安全。</li></ol><p>一些核心方法：</p><table><thead><tr><th>方法名称</th><th>含义</th></tr></thead><tbody><tr><td>sdsHdrSize</td><td>计算 SDS 头部的大小（将 type 与 7 进行与运算）</td></tr><tr><td>sdsReqType</td><td>根据字符串长度获取 SDS 的类型</td></tr><tr><td>sdsnewlen</td><td>根据初始值和初始长度创建 SDS</td></tr><tr><td>sdsfree</td><td>释放 SDS</td></tr><tr><td>sdsupdatelen</td><td>对第一个 \0 终止符进行截取</td></tr><tr><td>sdsclear</td><td>清除 buf 数组，并将 \0 终止符设置到字符串的第一个位置</td></tr><tr><td>sdsMakeRoomFor</td><td>将字符串扩容到指定长度</td></tr><tr><td>sdsRemoveFreeSpace</td><td>压缩 SDS，移除冗余的空间，即让 len = alloc</td></tr><tr><td>sdsAllocPtr</td><td>返回 SDS 结构体的大小</td></tr><tr><td>sdsAllocPtr</td><td>获取 SDS 的头指针</td></tr></tbody></table><p>下面主要来看一下 SDS 扩容的过程：</p><ol><li>首先判断 SDS 预留的空间是否大于 addlen，若大于则直接返回。</li><li>计算新的 SDS 需要占用的空间大小，若 newlen 小于 SDS_MAX_PREALLOC（1m），那么扩容为原来的 2 倍，否则在 newlen 的基础上加 1m 即可。</li><li>根据 newlen 计算新的 SDS 的类型，若新类型和原来的 SDS 类型一致，则进行 s_realloc_usable 扩容，否则申请新的空间对 SDS 将进行重构，并释放原来的 SDS 内存空间。</li><li>最后返回 SDS。</li></ol><p>源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c">sds <span class="hljs-title function_">sdsMakeRoomFor</span><span class="hljs-params">(sds s, <span class="hljs-type">size_t</span> addlen)</span> &#123;<br>    <span class="hljs-type">void</span> *sh, *newsh;<br>    <span class="hljs-type">size_t</span> avail = sdsavail(s);<br>    <span class="hljs-type">size_t</span> len, newlen, reqlen;<br>    <span class="hljs-type">char</span> type, oldtype = s[<span class="hljs-number">-1</span>] &amp; SDS_TYPE_MASK;<br>    <span class="hljs-type">int</span> hdrlen;<br>    <span class="hljs-type">size_t</span> usable;<br><br>    <span class="hljs-comment">/* Return ASAP if there is enough space left. */</span><br>    <span class="hljs-keyword">if</span> (avail &gt;= addlen) <span class="hljs-keyword">return</span> s;<br><br>    len = sdslen(s);<br>    sh = (<span class="hljs-type">char</span>*)s-sdsHdrSize(oldtype);<br>    reqlen = newlen = (len+addlen);<br>    assert(newlen &gt; len);   <span class="hljs-comment">/* Catch size_t overflow */</span><br>    <span class="hljs-keyword">if</span> (newlen &lt; SDS_MAX_PREALLOC)<br>        newlen *= <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">else</span><br>        newlen += SDS_MAX_PREALLOC;<br><br>    type = sdsReqType(newlen);<br><br>    <span class="hljs-comment">/* Don&#x27;t use type 5: the user is appending to the string and type 5 is</span><br><span class="hljs-comment">     * not able to remember empty space, so sdsMakeRoomFor() must be called</span><br><span class="hljs-comment">     * at every appending operation. */</span><br>    <span class="hljs-keyword">if</span> (type == SDS_TYPE_5) type = SDS_TYPE_8;<br><br>    hdrlen = sdsHdrSize(type);<br>    assert(hdrlen + newlen + <span class="hljs-number">1</span> &gt; reqlen);  <span class="hljs-comment">/* Catch size_t overflow */</span><br>    <span class="hljs-keyword">if</span> (oldtype==type) &#123;<br>        newsh = s_realloc_usable(sh, hdrlen+newlen+<span class="hljs-number">1</span>, &amp;usable);<br>        <span class="hljs-keyword">if</span> (newsh == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        s = (<span class="hljs-type">char</span>*)newsh+hdrlen;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">/* Since the header size changes, need to move the string forward,</span><br><span class="hljs-comment">         * and can&#x27;t use realloc */</span><br>        newsh = s_malloc_usable(hdrlen+newlen+<span class="hljs-number">1</span>, &amp;usable);<br>        <span class="hljs-keyword">if</span> (newsh == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-built_in">memcpy</span>((<span class="hljs-type">char</span>*)newsh+hdrlen, s, len+<span class="hljs-number">1</span>);<br>        s_free(sh);<br>        s = (<span class="hljs-type">char</span>*)newsh+hdrlen;<br>        s[<span class="hljs-number">-1</span>] = type;<br>        sdssetlen(s, len);<br>    &#125;<br>    usable = usable-hdrlen<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">if</span> (usable &gt; sdsTypeMaxSize(type))<br>        usable = sdsTypeMaxSize(type);<br>    sdssetalloc(s, usable);<br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-整数数组-IntSet">2. 整数数组 IntSet</h2>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-9d3fcfc2" role="button" aria-expanded="false" aria-controls="collapse-9d3fcfc2">        <div class="fold-arrow">▶</div>源码位置      </div>      <div class="fold-collapse collapse" id="collapse-9d3fcfc2">        <div class="fold-content">          <figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">src</span><span class="hljs-punctuation">:</span><br>   <span class="hljs-bullet">-</span> <span class="hljs-string">intset.c</span><br>   <span class="hljs-bullet">-</span> <span class="hljs-string">intset.h</span><br></code></pre></td></tr></table></figure>        </div>      </div>    </div><p>IntSet 是 redis 中的 Set 集合的一种实现方式，基于整数数组实现，并且具备长度可变、有序等高级特性，适用于去重，并且数据量较小的场景。</p><p>IntSet 的结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">intset</span> &#123;</span><br>    <span class="hljs-type">uint32_t</span> encoding;<br>    <span class="hljs-type">uint32_t</span> length;<br>    <span class="hljs-type">int8_t</span> contents[];<br>&#125; intset;<br></code></pre></td></tr></table></figure><p>其中 encoding 包含 3 种模式，表示存储的整数大小不同：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> INTSET_ENC_INT16 (sizeof(int16_t))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INTSET_ENC_INT32 (sizeof(int32_t))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INTSET_ENC_INT64 (sizeof(int64_t))</span><br></code></pre></td></tr></table></figure><p>redis 保证在 contents 数组的每一个元素的编码方式一致。</p><p>一些核心方法：</p><table><thead><tr><th>方法名称</th><th>含义</th></tr></thead><tbody><tr><td>intsetNew</td><td>创建一个空的 IntSet</td></tr><tr><td>intsetAdd</td><td>向 IntSet 中插入一个数</td></tr><tr><td>intsetRemove</td><td>从 IntSet 中删除一个数</td></tr><tr><td>intsetFind</td><td>一个数是否属于当前 IntSet</td></tr><tr><td></td><td></td></tr></tbody></table><p>下面主要来看一下 IntSet 的创建、新增、编码升级并新增、删除、查找的源码。</p><p>创建：</p><ul><li>分配内存，将编码设置为 int16 以节省内存，length 置为 0 并返回。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Create an empty intset. */</span><br>intset *<span class="hljs-title function_">intsetNew</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    intset *is = zmalloc(<span class="hljs-keyword">sizeof</span>(intset));<br>    is-&gt;encoding = intrev32ifbe(INTSET_ENC_INT16);<br>    is-&gt;length = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> is;<br>&#125;<br></code></pre></td></tr></table></figure><p>新增：</p><ul><li>判断编码，看是否需要升级</li><li>若不升级则找到应该插入的位置，利用二分查找</li><li>插入到正确的位置后更新 length</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c">intset *<span class="hljs-title function_">intsetAdd</span><span class="hljs-params">(intset *is, <span class="hljs-type">int64_t</span> value, <span class="hljs-type">uint8_t</span> *success)</span> &#123;<br>    <span class="hljs-comment">// _intsetValueEncoding 方法：获取当前 value 的编码</span><br>    <span class="hljs-type">uint8_t</span> valenc = _intsetValueEncoding(value);<br>    <span class="hljs-type">uint32_t</span> pos;<br>    <span class="hljs-keyword">if</span> (success) *success = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">/* Upgrade encoding if necessary. If we need to upgrade, we know that</span><br><span class="hljs-comment">     * this value should be either appended (if &gt; 0) or prepended (if &lt; 0),</span><br><span class="hljs-comment">     * because it lies outside the range of existing values. */</span><br>    <span class="hljs-comment">// 如果当前 value 的编码大于当前 IntSet 的编码则需要编码升级并新增</span><br>    <span class="hljs-keyword">if</span> (valenc &gt; intrev32ifbe(is-&gt;encoding)) &#123;<br>        <span class="hljs-comment">/* This always succeeds, so we don&#x27;t need to curry *success. */</span><br>        <span class="hljs-keyword">return</span> intsetUpgradeAndAdd(is,value);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">/* Abort if the value is already present in the set.</span><br><span class="hljs-comment">         * This call will populate &quot;pos&quot; with the right position to insert</span><br><span class="hljs-comment">         * the value when it cannot be found. */</span><br>        <span class="hljs-comment">// 查找当前 value 是否存在，同时将小于 value 的最大值赋值给 pos</span><br>        <span class="hljs-keyword">if</span> (intsetSearch(is,value,&amp;pos)) &#123;<br>            <span class="hljs-keyword">if</span> (success) *success = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">return</span> is;<br>        &#125;<br>        <span class="hljs-comment">// 保证插入时内存足够</span><br>        is = intsetResize(is,intrev32ifbe(is-&gt;length)+<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// value 应该插入在 IntSet 中间，则让后面的值依次后移</span><br>        <span class="hljs-keyword">if</span> (pos &lt; intrev32ifbe(is-&gt;length)) intsetMoveTail(is,pos,pos+<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">// 将 value 插入到 pos</span><br>    _intsetSet(is,pos,value);<br>    <span class="hljs-comment">// 更新 length</span><br>    is-&gt;length = intrev32ifbe(intrev32ifbe(is-&gt;length)+<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> is;<br>&#125;<br></code></pre></td></tr></table></figure><p>编码升级并新增：</p><ul><li>首先设置新的编码并重新申请内存空间</li><li>接着倒序遍历，将原来的数依次加入到新的位置</li><li>设置 value</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Upgrades the intset to a larger encoding and inserts the given integer. */</span><br><span class="hljs-type">static</span> intset *<span class="hljs-title function_">intsetUpgradeAndAdd</span><span class="hljs-params">(intset *is, <span class="hljs-type">int64_t</span> value)</span> &#123;<br>    <span class="hljs-type">uint8_t</span> curenc = intrev32ifbe(is-&gt;encoding);<br>    <span class="hljs-type">uint8_t</span> newenc = _intsetValueEncoding(value);<br>    <span class="hljs-type">int</span> length = intrev32ifbe(is-&gt;length);<br>    <span class="hljs-type">int</span> prepend = value &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/* First set new encoding and resize */</span><br>    is-&gt;encoding = intrev32ifbe(newenc);<br>    is = intsetResize(is,intrev32ifbe(is-&gt;length)+<span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">/* Upgrade back-to-front so we don&#x27;t overwrite values.</span><br><span class="hljs-comment">     * Note that the &quot;prepend&quot; variable is used to make sure we have an empty</span><br><span class="hljs-comment">     * space at either the beginning or the end of the intset. */</span><br>    <span class="hljs-comment">// 倒序遍历，为了不覆盖原来的值</span><br>    <span class="hljs-keyword">while</span>(length--)<br>        _intsetSet(is,length+prepend,_intsetGetEncoded(is,length,curenc));<br><br>    <span class="hljs-comment">/* Set the value at the beginning or the end. */</span><br>    <span class="hljs-comment">// 当前 value 的编码超出了原来的编码，所以 value 要么大于原来 IntSet 的最大值，要么小于原来的 IntSet 的最小值</span><br>    <span class="hljs-keyword">if</span> (prepend)<br>        _intsetSet(is,<span class="hljs-number">0</span>,value);<br>    <span class="hljs-keyword">else</span><br>        _intsetSet(is,intrev32ifbe(is-&gt;length),value);<br>    is-&gt;length = intrev32ifbe(intrev32ifbe(is-&gt;length)+<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> is;<br>&#125;<br></code></pre></td></tr></table></figure><p>删除：</p><ul><li>首先判断 value 的编码，若编码超出此时 IntSet 的编码则什么也不做。</li><li>在删除时，没有进行编码降级处理，由于 IntSet 曾经出现过超大的数，那么再次出现的概率并不低，贸然降级，不仅当前需要处理IntSet 的编码，而且以后升级的概况也很高，所以不降级，以避免麻烦与无用的时间消耗。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Delete integer from intset */</span><br>intset *<span class="hljs-title function_">intsetRemove</span><span class="hljs-params">(intset *is, <span class="hljs-type">int64_t</span> value, <span class="hljs-type">int</span> *success)</span> &#123;<br>    <span class="hljs-comment">// 当前 value 的编码</span><br>    <span class="hljs-type">uint8_t</span> valenc = _intsetValueEncoding(value);<br>    <span class="hljs-type">uint32_t</span> pos;<br>    <span class="hljs-keyword">if</span> (success) *success = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 若当前 value 的编码已经大于 IntSet 的编码，则 value 一定不在 IntSet 中</span><br>    <span class="hljs-keyword">if</span> (valenc &lt;= intrev32ifbe(is-&gt;encoding) &amp;&amp; intsetSearch(is,value,&amp;pos)) &#123;<br>        <span class="hljs-type">uint32_t</span> len = intrev32ifbe(is-&gt;length);<br><br>        <span class="hljs-comment">/* We know we can delete */</span><br>        <span class="hljs-keyword">if</span> (success) *success = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">/* Overwrite value with tail and update length */</span><br>        <span class="hljs-keyword">if</span> (pos &lt; (len<span class="hljs-number">-1</span>)) intsetMoveTail(is,pos+<span class="hljs-number">1</span>,pos);<br>        is = intsetResize(is,len<span class="hljs-number">-1</span>);<br>        is-&gt;length = intrev32ifbe(len<span class="hljs-number">-1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> is;<br>&#125;<br></code></pre></td></tr></table></figure><p>查找：</p><ul><li>二分查找</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 搜索 value 的位置，找到则返回 1，并将 pos 设置为 value 在 IntSet 中的位置</span><br><span class="hljs-comment">// 若 value 在 IntSet 中不存在，则返回 0，并将 pos 设置为 value 在 IntSet 应该插入的位置（小于 value 的最大值）</span><br><span class="hljs-type">static</span> <span class="hljs-type">uint8_t</span> <span class="hljs-title function_">intsetSearch</span><span class="hljs-params">(intset *is, <span class="hljs-type">int64_t</span> value, <span class="hljs-type">uint32_t</span> *pos)</span> &#123;<br>    <span class="hljs-type">int</span> min = <span class="hljs-number">0</span>, max = intrev32ifbe(is-&gt;length)<span class="hljs-number">-1</span>, mid = <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int64_t</span> cur = <span class="hljs-number">-1</span>;<br><br>    <span class="hljs-keyword">if</span> (intrev32ifbe(is-&gt;length) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// IntSet 为空</span><br>        <span class="hljs-keyword">if</span> (pos) *pos = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125; <span class="hljs-keyword">else</span> <br>        <span class="hljs-comment">// _intsetGet 方法返回在 pos 位置的 value 值</span><br>        <span class="hljs-keyword">if</span> (value &gt; _intsetGet(is,max)) &#123;<br>            <span class="hljs-comment">// value 已经大于 IntSet 的最大值</span><br>            <span class="hljs-keyword">if</span> (pos) *pos = intrev32ifbe(is-&gt;length);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value &lt; _intsetGet(is,<span class="hljs-number">0</span>)) &#123;<br>            <span class="hljs-comment">// value 已经小于 IntSet 的最小值</span><br>            <span class="hljs-keyword">if</span> (pos) *pos = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 下面是一个二分查找</span><br>    <span class="hljs-keyword">while</span>(max &gt;= min) &#123;<br>        mid = ((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)min + (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)max) &gt;&gt; <span class="hljs-number">1</span>;<br>        cur = _intsetGet(is,mid);<br>        <span class="hljs-keyword">if</span> (value &gt; cur) &#123;<br>            min = mid+<span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value &lt; cur) &#123;<br>            max = mid<span class="hljs-number">-1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (value == cur) &#123;<br>        <span class="hljs-keyword">if</span> (pos) *pos = mid;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (pos) *pos = min;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-哈希表-Dict">3. 哈希表 Dict</h2>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-cf7df53d" role="button" aria-expanded="false" aria-controls="collapse-cf7df53d">        <div class="fold-arrow">▶</div>源码位置      </div>      <div class="fold-collapse collapse" id="collapse-cf7df53d">        <div class="fold-content">          <figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">src</span><span class="hljs-punctuation">:</span><br>   <span class="hljs-bullet">-</span> <span class="hljs-string">dict.c</span><br>   <span class="hljs-bullet">-</span> <span class="hljs-string">dict.h</span><br></code></pre></td></tr></table></figure>        </div>      </div>    </div><p>redis 中的 Dict 和哈希表大同小异，所以我建议你阅读一下下面这篇文章。</p>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-2b13d6ba" role="button" aria-expanded="false" aria-controls="collapse-2b13d6ba">        <div class="fold-arrow">▶</div>建议阅读      </div>      <div class="fold-collapse collapse" id="collapse-2b13d6ba">        <div class="fold-content">          <p><a href="/algorithm-53bff467bc4b/" title="哈希表">哈希表</a></p>        </div>      </div>    </div><h3 id="3-1-相关结构">3.1 相关结构</h3><p>redis 中的 Dict 相较于前面的 SDS 和 IntSet，结构和实现更为复杂。其相关的数据结构有 3 种：</p><p>dictEntry：k-v 节点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictEntry</span> &#123;</span><br>    <span class="hljs-comment">// 键</span><br>    <span class="hljs-type">void</span> *key;<br>    <span class="hljs-comment">// 值，存储下面类型的任意一种</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>        <span class="hljs-type">void</span> *val;<br>        <span class="hljs-type">uint64_t</span> u64;<br>        <span class="hljs-type">int64_t</span> s64;<br>        <span class="hljs-type">double</span> d;<br>    &#125; v;<br>    <span class="hljs-comment">// next 指针，从这里可以看到 redis 使用的拉链法解决哈希冲突</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictEntry</span> *<span class="hljs-title">next</span>;</span><br>&#125; dictEntry;<br></code></pre></td></tr></table></figure><p>dictht：哈希表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* This is our hash table structure. Every dictionary has two of this as we</span><br><span class="hljs-comment"> * implement incremental rehashing, for the old to the new table. */</span><br><span class="hljs-comment">// 每个 dict 有 2 个 dictht 方便实现渐进式 rehash</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictht</span> &#123;</span><br>    <span class="hljs-comment">// 哈希桶，每个元素都是一个指向 dictEntry 的指针</span><br>    dictEntry **table;<br>    <span class="hljs-comment">// 哈希表大小</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> size;<br>    <span class="hljs-comment">// 掩码，总是等于 size-1，方便将取模运算优化为位运算</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> sizemask;<br>    <span class="hljs-comment">// 哈希表中已有的节点数量</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> used;<br>&#125; dictht;<br></code></pre></td></tr></table></figure><p>提一下这里的 sizemask，当哈希表的 size 为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span> 时，hash % size 可以等价为 hash &amp; sizemask。</p><p>dict：字典</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dict</span> &#123;</span><br>    <span class="hljs-comment">// dictType 结构体中保存了一组回调函数</span><br>    dictType *type;<br>    <span class="hljs-comment">// 指向一些特定的参数，配合 dictType 的回调函数</span><br>    <span class="hljs-type">void</span> *privdata;<br>    <span class="hljs-comment">// 存储哈希表，大小为 2，实现渐进式 rehash 操作</span><br>    <span class="hljs-comment">// ht[0] 用于平时存储节点，ht[1] 用于实现渐进式 rehash 操作</span><br>    dictht ht[<span class="hljs-number">2</span>];<br>    <span class="hljs-comment">// rehashidx 主要用于记录 rehash 进度</span><br>    <span class="hljs-type">long</span> rehashidx; <span class="hljs-comment">/* rehashing not in progress if rehashidx == -1 */</span><br>    <span class="hljs-comment">// 是否暂停 rehash，1 则暂停 0 则继续</span><br>    <span class="hljs-type">int16_t</span> pauserehash; <span class="hljs-comment">/* If &gt;0 rehashing is paused (&lt;0 indicates coding error) */</span><br>&#125; dict;<br></code></pre></td></tr></table></figure><p>下面看一看 dictType，这是 dict 中的一些公共方法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictType</span> &#123;</span><br>    <span class="hljs-comment">// 计算哈希值</span><br>    <span class="hljs-type">uint64_t</span> (*hashFunction)(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *key);<br>    <span class="hljs-comment">// 复制键</span><br>    <span class="hljs-type">void</span> *(*keyDup)(<span class="hljs-type">void</span> *privdata, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *key);<br>    <span class="hljs-comment">// 复制值</span><br>    <span class="hljs-type">void</span> *(*valDup)(<span class="hljs-type">void</span> *privdata, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *obj);<br>    <span class="hljs-comment">// 比较键</span><br>    <span class="hljs-type">int</span> (*keyCompare)(<span class="hljs-type">void</span> *privdata, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *key1, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *key2);<br>    <span class="hljs-comment">// 销毁键</span><br>    <span class="hljs-type">void</span> (*keyDestructor)(<span class="hljs-type">void</span> *privdata, <span class="hljs-type">void</span> *key);<br>    <span class="hljs-comment">// 销毁值</span><br>    <span class="hljs-type">void</span> (*valDestructor)(<span class="hljs-type">void</span> *privdata, <span class="hljs-type">void</span> *obj);<br>    <span class="hljs-comment">// 在 Dict 扩容时判断的一个条件</span><br>    <span class="hljs-type">int</span> (*expandAllowed)(<span class="hljs-type">size_t</span> moreMem, <span class="hljs-type">double</span> usedRatio);<br>&#125; dictType;<br></code></pre></td></tr></table></figure><p>这些结构体的关系如下图：</p><p><img src="/java/redis-25334f7a71a2/image-20240117152514698.png" alt="结构"></p><h3 id="3-2-哈希函数">3.2 哈希函数</h3><p>标准的哈希函数在 siphash.c 中实现，源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* The default hashing function uses SipHash implementation</span><br><span class="hljs-comment"> * in siphash.c. */</span><br><br><span class="hljs-type">uint64_t</span> <span class="hljs-title function_">siphash</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> *in, <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> inlen, <span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> *k)</span>;<br><span class="hljs-type">uint64_t</span> <span class="hljs-title function_">siphash_nocase</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> *in, <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> inlen, <span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> *k)</span>;<br><br><span class="hljs-type">uint64_t</span> <span class="hljs-title function_">dictGenHashFunction</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *key, <span class="hljs-type">int</span> len)</span> &#123;<br>    <span class="hljs-keyword">return</span> siphash(key,len,dict_hash_function_seed);<br>&#125;<br><br><span class="hljs-type">uint64_t</span> <span class="hljs-title function_">dictGenCaseHashFunction</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *buf, <span class="hljs-type">int</span> len)</span> &#123;<br>    <span class="hljs-keyword">return</span> siphash_nocase(buf,len,dict_hash_function_seed);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-3-扩容与缩容">3.3 扩容与缩容</h3><p>当 Dict 存储的 k-v 节点增多时，必然导致哈希冲突的概率增大，那么同一个哈希槽的链表就会过长从而查询效率会大大降低，所以 Dict 会进行扩容操作。</p><p>而除了扩容，Dict 在删除元素时，在满足相应的条件也会进行缩容操作。</p><p>Dict 在新增数据时，进行扩容的方法调用链：dictAdd -&gt; dictAddRaw -&gt; _dictKeyIndex -&gt; _dictExpandIfNeeded</p><p>其中比较重要的是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c">dictEntry *<span class="hljs-title function_">dictAddRaw</span><span class="hljs-params">(dict *d, <span class="hljs-type">void</span> *key, dictEntry **existing)</span><br>&#123;<br>    <span class="hljs-type">long</span> index;<br>    dictEntry *entry;<br>    dictht *ht;<br>    <span class="hljs-comment">// 检查是否在进行 rehash</span><br>    <span class="hljs-keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);<br><br>    <span class="hljs-comment">/* Get the index of the new element, or -1 if</span><br><span class="hljs-comment">     * the element already exists. */</span><br>    <span class="hljs-keyword">if</span> ((index = _dictKeyIndex(d, key, dictHashKey(d,key), existing)) == <span class="hljs-number">-1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-comment">/* Allocate the memory and store the new entry.</span><br><span class="hljs-comment">     * Insert the element in top, with the assumption that in a database</span><br><span class="hljs-comment">     * system it is more likely that recently added entries are accessed</span><br><span class="hljs-comment">     * more frequently. */</span><br>    <span class="hljs-comment">// 从这里可以看出当正在进行 rehash 则将 entry 节点插入到 ht[1] 否则插入到 ht[0]</span><br>    <span class="hljs-comment">// 并且是头插法</span><br>    ht = dictIsRehashing(d) ? &amp;d-&gt;ht[<span class="hljs-number">1</span>] : &amp;d-&gt;ht[<span class="hljs-number">0</span>];<br>    entry = zmalloc(<span class="hljs-keyword">sizeof</span>(*entry));<br>    entry-&gt;next = ht-&gt;table[index];<br>    ht-&gt;table[index] = entry;<br>    ht-&gt;used++;<br><br>    <span class="hljs-comment">/* Set the hash entry fields. */</span><br>    dictSetKey(d, entry, key);<br>    <span class="hljs-keyword">return</span> entry;<br>&#125;<br></code></pre></td></tr></table></figure><p>跟入 _dictKeyIndex</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">long</span> _dictKeyIndex(dict *d, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *key, <span class="hljs-type">uint64_t</span> hash, dictEntry **existing)<br>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> idx, table;<br>    dictEntry *he;<br>    <span class="hljs-keyword">if</span> (existing) *existing = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-comment">/* Expand the hash table if needed */</span><br>    <span class="hljs-keyword">if</span> (_dictExpandIfNeeded(d) == DICT_ERR)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span> (table = <span class="hljs-number">0</span>; table &lt;= <span class="hljs-number">1</span>; table++) &#123;<br>        idx = hash &amp; d-&gt;ht[table].sizemask;<br>        <span class="hljs-comment">/* Search if this slot does not already contain the given key */</span><br>        he = d-&gt;ht[table].table[idx];<br>        <span class="hljs-keyword">while</span>(he) &#123;<br>            <span class="hljs-keyword">if</span> (key==he-&gt;key || dictCompareKeys(d, key, he-&gt;key)) &#123;<br>                <span class="hljs-keyword">if</span> (existing) *existing = he;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>            &#125;<br>            he = he-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!dictIsRehashing(d)) <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> idx;<br>&#125;<br></code></pre></td></tr></table></figure><p>跟入 _dictExpandIfNeeded</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Expand the hash table if needed */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> _dictExpandIfNeeded(dict *d)<br>&#123;<br>    <span class="hljs-comment">/* Incremental rehashing already in progress. Return. */</span><br>    <span class="hljs-comment">// 如果正在进行 rehash，则直接返回 ok</span><br>    <span class="hljs-keyword">if</span> (dictIsRehashing(d)) <span class="hljs-keyword">return</span> DICT_OK;<br><br>    <span class="hljs-comment">/* If the hash table is empty expand it to the initial size. */</span><br>    <span class="hljs-comment">// 哈希表为空，则创建 DICT_HT_INITIAL_SIZE 大小的哈希表</span><br>    <span class="hljs-keyword">if</span> (d-&gt;ht[<span class="hljs-number">0</span>].size == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> dictExpand(d, DICT_HT_INITIAL_SIZE);<br><br>    <span class="hljs-comment">/* If we reached the 1:1 ratio, and we are allowed to resize the hash</span><br><span class="hljs-comment">     * table (global setting) or we should avoid it but the ratio between</span><br><span class="hljs-comment">     * elements/buckets is over the &quot;safe&quot; threshold, we resize doubling</span><br><span class="hljs-comment">     * the number of buckets. */</span><br>    <span class="hljs-comment">// 判断扩容逻辑</span><br>    <span class="hljs-comment">// 如果 ht[0] 的 used &gt;= size 且 (dict_can_resize 为 1 或者 used/size &gt; 5）则默认扩容为 used+1 的大小</span><br>    <span class="hljs-comment">// 但实际扩容后的大小不一定是 used+1，因为需要哈希表的大小为 2^n </span><br>    <span class="hljs-keyword">if</span> (d-&gt;ht[<span class="hljs-number">0</span>].used &gt;= d-&gt;ht[<span class="hljs-number">0</span>].size &amp;&amp;<br>        (dict_can_resize ||<br>         d-&gt;ht[<span class="hljs-number">0</span>].used/d-&gt;ht[<span class="hljs-number">0</span>].size &gt; dict_force_resize_ratio) &amp;&amp;<br>        dictTypeExpandAllowed(d))<br>    &#123;<br>        <span class="hljs-keyword">return</span> dictExpand(d, d-&gt;ht[<span class="hljs-number">0</span>].used + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> DICT_OK;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 dictExpand 方法内部有一个 _dictNextPower 方法，它可以返回比 size 大的最小的 2 的幂数，该方法保证哈希表的容量为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Our hash table capability is a power of two */</span><br><span class="hljs-type">static</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> _dictNextPower(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> size)<br>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> i = DICT_HT_INITIAL_SIZE;<br><br>    <span class="hljs-keyword">if</span> (size &gt;= LONG_MAX) <span class="hljs-keyword">return</span> LONG_MAX + <span class="hljs-number">1LU</span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (i &gt;= size)<br>            <span class="hljs-keyword">return</span> i;<br>        i *= <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>至于缩容的方法 dictResize，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Resize the table to the minimal size that contains all the elements,</span><br><span class="hljs-comment"> * but with the invariant of a USED/BUCKETS ratio near to &lt;= 1 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">dictResize</span><span class="hljs-params">(dict *d)</span><br>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> minimal;<br>    <span class="hljs-comment">// 如果 dict_can_resize 为 false 或者正在进行 rehash</span><br>    <span class="hljs-keyword">if</span> (!dict_can_resize || dictIsRehashing(d)) <span class="hljs-keyword">return</span> DICT_ERR;<br>    minimal = d-&gt;ht[<span class="hljs-number">0</span>].used;<br>    <span class="hljs-comment">// used &lt; 4 则重置为 4</span><br>    <span class="hljs-keyword">if</span> (minimal &lt; DICT_HT_INITIAL_SIZE)<br>        minimal = DICT_HT_INITIAL_SIZE;<br>    <span class="hljs-comment">// 重置大小为 minimal，当然是大于等于 minimal 的 2^n</span><br>    <span class="hljs-keyword">return</span> dictExpand(d, minimal);<br>&#125;<br></code></pre></td></tr></table></figure><p>如何判断何时需要缩容？在 t_hash.c 中的 hashTypeDeleted 函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Delete an element from a hash.</span><br><span class="hljs-comment"> * Return 1 on deleted and 0 on not found. */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">hashTypeDelete</span><span class="hljs-params">(robj *o, sds field)</span> &#123;<br>    <span class="hljs-type">int</span> deleted = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_ZIPLIST) &#123;<br>        <span class="hljs-comment">// 处理 ZipList</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_HT) &#123;<br>        <span class="hljs-keyword">if</span> (dictDelete((dict*)o-&gt;ptr, field) == C_OK) &#123;<br>            deleted = <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">/* Always check if the dictionary needs a resize after a delete. */</span><br>            <span class="hljs-comment">// 删除成功后，检查是否需要重置 Dict 大小，若需要则调用 dictResize</span><br>            <span class="hljs-keyword">if</span> (htNeedsResize(o-&gt;ptr)) dictResize(o-&gt;ptr);<br>        &#125;<br><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        serverPanic(<span class="hljs-string">&quot;Unknown hash encoding&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> deleted;<br>&#125;<br><br><span class="hljs-comment">// server.c </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">htNeedsResize</span><span class="hljs-params">(dict *dict)</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> size, used;<br>    <span class="hljs-comment">// 哈希桶大小</span><br>    size = dictSlots(dict);<br>    <span class="hljs-comment">// 哈希表中的节点个数</span><br>    used = dictSize(dict);<br>    <span class="hljs-comment">// size &gt; 4 且 used/size &lt; 0.1</span><br>    <span class="hljs-keyword">return</span> (size &gt; DICT_HT_INITIAL_SIZE &amp;&amp;<br>            (used*<span class="hljs-number">100</span>/size &lt; HASHTABLE_MIN_FILL));<br>&#125;<br></code></pre></td></tr></table></figure><p>总的来说，Dict 的扩容和缩容条件如下：</p><ul><li>Dict 每次新增 k-v 时会检查负载因子（LoadFactor = used/size），满足下面的条件则进行扩容：<ul><li>LoadFactory &gt;= 1 且服务器没有执行 bgsave 或者 bgrewriteaof 等后台进程。</li><li>LoadFactory &gt; 5</li></ul></li><li>Dict 在删除时也会检查 LoadFactory，若 size &gt; 4 且 LoadFactory &lt; 0.1 会进行缩容处理。</li></ul><p>同时扩容和缩容的大小也有一定的要求：</p><ul><li>如果是扩容，则新 size 为第一个大于等于 <a href="http://dict.ht">dict.ht</a>[0].used + 1 的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></li><li>如果是收缩，则新 size 为第一个大于等于 <a href="http://dict.ht">dict.ht</a>[0].used 的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span>（不得小于 4）</li></ul><h3 id="3-4-rehash">3.4 rehash</h3><p>通常情况下，Dict 的所有数据都存放在 ht[0] 中，但随着数据的增多，出现哈希冲突的概率也会增大，所以 Dict 需要进行扩容，此时就需要进行 rehash。</p><p>在 dictExpand 函数内部调用了 _dictExpand 函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> _dictExpand(dict *d, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> size, <span class="hljs-type">int</span>* malloc_failed)<br>&#123;<br>    <span class="hljs-keyword">if</span> (malloc_failed) *malloc_failed = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/* the size is invalid if it is smaller than the number of</span><br><span class="hljs-comment">     * elements already inside the hash table */</span><br>    <span class="hljs-keyword">if</span> (dictIsRehashing(d) || d-&gt;ht[<span class="hljs-number">0</span>].used &gt; size)<br>        <span class="hljs-keyword">return</span> DICT_ERR;<br><br>    dictht n; <span class="hljs-comment">/* the new hash table */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> realsize = _dictNextPower(size);<br><br>    <span class="hljs-comment">/* Detect overflows */</span><br>    <span class="hljs-keyword">if</span> (realsize &lt; size || realsize * <span class="hljs-keyword">sizeof</span>(dictEntry*) &lt; realsize)<br>        <span class="hljs-keyword">return</span> DICT_ERR;<br><br>    <span class="hljs-comment">/* Rehashing to the same table size is not useful. */</span><br>    <span class="hljs-keyword">if</span> (realsize == d-&gt;ht[<span class="hljs-number">0</span>].size) <span class="hljs-keyword">return</span> DICT_ERR;<br><br>    <span class="hljs-comment">/* Allocate the new hash table and initialize all pointers to NULL */</span><br>    n.size = realsize;<br>    n.sizemask = realsize<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">if</span> (malloc_failed) &#123;<br>        n.table = ztrycalloc(realsize*<span class="hljs-keyword">sizeof</span>(dictEntry*));<br>        *malloc_failed = n.table == <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">if</span> (*malloc_failed)<br>            <span class="hljs-keyword">return</span> DICT_ERR;<br>    &#125; <span class="hljs-keyword">else</span><br>        n.table = zcalloc(realsize*<span class="hljs-keyword">sizeof</span>(dictEntry*));<br><br>    n.used = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/* Is this the first initialization? If so it&#x27;s not really a rehashing</span><br><span class="hljs-comment">     * we just set the first hash table so that it can accept keys. */</span><br>    <span class="hljs-keyword">if</span> (d-&gt;ht[<span class="hljs-number">0</span>].table == <span class="hljs-literal">NULL</span>) &#123;<br>        d-&gt;ht[<span class="hljs-number">0</span>] = n;<br>        <span class="hljs-keyword">return</span> DICT_OK;<br>    &#125;<br><br>    <span class="hljs-comment">/* Prepare a second hash table for incremental rehashing */</span><br>    d-&gt;ht[<span class="hljs-number">1</span>] = n;<br>    d-&gt;rehashidx = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> DICT_OK;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个函数中，申请了比 size 大的最小的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span> 大小的哈希表，并将其赋值给 ht[1]，最后将 rehashidx 置为 0 表示开始 rehash。</p><p>Dict 根据 rehashidx 来判断是否开始 rehash，源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> dictIsRehashing(d) ((d)-&gt;rehashidx != -1)</span><br></code></pre></td></tr></table></figure><p>实际上，redis 采用的是一种渐进式的 rehash 策略，渐进式 rehash 是指 rehash 操作不是一次集中式完成的，对于 redis 来说，如果哈希表的 key 太多，这样可能导致 rehash 操作需要长时间进行，阻塞服务器，所以 redis 本身将 rehash 操作分散在了后续的每次增删改查中。</p><p>一旦确定进行 rehash，即将 rehashidx 置为 0，那么 redis 在对 Dict 进行增删改查的过程中，都会调用 _dictRehashStep 进行 dictRehash 操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> _dictRehashStep(dict *d) &#123;<br>    <span class="hljs-keyword">if</span> (d-&gt;pauserehash == <span class="hljs-number">0</span>) dictRehash(d,<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">dictRehash</span><span class="hljs-params">(dict *d, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-comment">// empty_visits 表示每次最多跳过 10 倍步长的空桶</span><br>    <span class="hljs-type">int</span> empty_visits = n*<span class="hljs-number">10</span>; <span class="hljs-comment">/* Max number of empty buckets to visit. */</span><br>    <span class="hljs-keyword">if</span> (!dictIsRehashing(d)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 将 ht[0] 中 rehashidx 上的所有键值对 rehash 到 ht[1] 中，随后 rehashidx++</span><br>    <span class="hljs-comment">// 当 rehash 结束，将 rehashidx 置为 -1，表示结束 rehash</span><br>    <span class="hljs-keyword">while</span>(n-- &amp;&amp; d-&gt;ht[<span class="hljs-number">0</span>].used != <span class="hljs-number">0</span>) &#123;<br>        dictEntry *de, *nextde;<br><br>        <span class="hljs-comment">/* Note that rehashidx can&#x27;t overflow as we are sure there are more</span><br><span class="hljs-comment">         * elements because ht[0].used != 0 */</span><br>        assert(d-&gt;ht[<span class="hljs-number">0</span>].size &gt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)d-&gt;rehashidx);<br>        <span class="hljs-keyword">while</span>(d-&gt;ht[<span class="hljs-number">0</span>].table[d-&gt;rehashidx] == <span class="hljs-literal">NULL</span>) &#123;<br>            d-&gt;rehashidx++;<br>            <span class="hljs-keyword">if</span> (--empty_visits == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        de = d-&gt;ht[<span class="hljs-number">0</span>].table[d-&gt;rehashidx];<br>        <span class="hljs-comment">/* Move all the keys in this bucket from the old to the new hash HT */</span><br>        <span class="hljs-keyword">while</span>(de) &#123;<br>            <span class="hljs-type">uint64_t</span> h;<br><br>            nextde = de-&gt;next;<br>            <span class="hljs-comment">/* Get the index in the new hash table */</span><br>            h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[<span class="hljs-number">1</span>].sizemask;<br>            de-&gt;next = d-&gt;ht[<span class="hljs-number">1</span>].table[h];<br>            d-&gt;ht[<span class="hljs-number">1</span>].table[h] = de;<br>            d-&gt;ht[<span class="hljs-number">0</span>].used--;<br>            d-&gt;ht[<span class="hljs-number">1</span>].used++;<br>            de = nextde;<br>        &#125;<br>        d-&gt;ht[<span class="hljs-number">0</span>].table[d-&gt;rehashidx] = <span class="hljs-literal">NULL</span>;<br>        d-&gt;rehashidx++;<br>    &#125;<br><br>    <span class="hljs-comment">/* Check if we already rehashed the whole table... */</span><br>    <span class="hljs-keyword">if</span> (d-&gt;ht[<span class="hljs-number">0</span>].used == <span class="hljs-number">0</span>) &#123;<br>        zfree(d-&gt;ht[<span class="hljs-number">0</span>].table);<br>        d-&gt;ht[<span class="hljs-number">0</span>] = d-&gt;ht[<span class="hljs-number">1</span>];<br>        _dictReset(&amp;d-&gt;ht[<span class="hljs-number">1</span>]);<br>        d-&gt;rehashidx = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* More to rehash... */</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>所以我们可以总结一些 rehash 的流程：</p><ol><li>首先按照特定的要求申请指定的内存空间，创建 dictht，并赋值给 ht[1]</li><li>设置 rehashidx 为 0， 表示开始进行 rehash</li><li>根据 rehashidx 将 ht[0] 中的每一个 dictEntry 都 rehash 到 ht[1]</li><li>将 ht[0] 的内存释放，将 ht[1] 赋值给 ht[0]，重置 ht[1]，设置 rehashidx 为 -1，表示 rehash 结束</li></ol><p>注意一点：在 rehash 的过程中，Dict 是同时使用 ht[0] 和 ht[1] 的，所有的查询会在 ht[0] 和 ht[1] 上进行，确保不会漏掉数据，而新增数据则在 ht[1] 上进行新增，确保 ht[0] 的数据只会减少，随着不断 rehash 而变成空表。</p><h2 id="4-压缩列表-ZipList">4. 压缩列表 ZipList</h2>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-e033605d" role="button" aria-expanded="false" aria-controls="collapse-e033605d">        <div class="fold-arrow">▶</div>源码位置      </div>      <div class="fold-collapse collapse" id="collapse-e033605d">        <div class="fold-content">          <figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">src</span><span class="hljs-punctuation">:</span><br>   <span class="hljs-bullet">-</span> <span class="hljs-string">ziplist.c</span><br>   <span class="hljs-bullet">-</span> <span class="hljs-string">ziplist.h</span><br></code></pre></td></tr></table></figure>        </div>      </div>    </div><p>ZipList 是为了提高存储效率而设计的一种特殊编码的双向链表，可以存储字符串或整数，在存储整数时采用整数的二进制而不是字符串形式存储，可以在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 的时间复杂度下完成 ZipList 两端的 push 和 pop 操作，但是由于每次操作都需要重新分配 ZipList 的内存，所以实际复杂度与 ZipList 的内存使用量有关。</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis 引入多线程</title>
    <link href="/java/redis-c5d4aef838ce/"/>
    <url>/java/redis-c5d4aef838ce/</url>
    
    <content type="html"><![CDATA[<h1>redis 引入多线程</h1><p>在 redis 6.0 中，就引入了多线程。</p><p>redis 一直被熟知的是它的单线程架构，虽然一些命令操作是后台线程或子进程完成的，但是从网络 IO 到实际的读写命令执行都是由单个线程完成的。</p><p>但随着硬件的性能提升，单个线程处理网络请求的速度跟不上底层网络硬件的速度。</p><p>为了应对这个问题，一般有两种方法。</p><p>第一种是，使用用户态网络协议栈（如 DPDK）取代内核网络协议栈，让网络请求的处理不在内核执行，直接在用户态处理。</p><p>对于 redis 来说，避免频繁让内核进行网络请求处理，可以很好地提升请求处理效率。但，这个方法要求在 redis 的整体架构中，添加对用户态网络协议栈的支持，需要修改 redis 源码中和网络相关的部分（如修改所有的网络收发请求函数），这会带来很多开发工作量，而且新增代码还可能引入新 Bug，导致系统不稳定。所以，redis 6.0 中并没有采用这个方法。</p><p>第二种是，采用多个 IO 线程来处理网络请求，提高网络请求处理的并行度。redis 6.0 就是采用的这种方法。</p><p>但是，redis 的多 IO 线程只是用来处理网络请求的，对于读写命令，redis 仍然使用单线程，这样就不用为了保证 Lua 脚本、事务的原子性，额外开发多线程互斥机制了，redis 线程模型实现就简单了。</p><h2 id="主线程和-IO-线程的协作">主线程和 IO 线程的协作</h2>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-68450473" role="button" aria-expanded="false" aria-controls="collapse-68450473">        <div class="fold-arrow">▶</div>结合这篇文章阅读      </div>      <div class="fold-collapse collapse" id="collapse-68450473">        <div class="fold-content">          <p><a href="/java/redis-75ba9f9c982a/" title="redis 中的 IO 模型">redis 中的 IO 模型</a></p>        </div>      </div>    </div><p>首先，主线程负责接受建立连接请求，当有客户端和实例建立 Socket 连接时，主线程会创建和客户端的连接，并将 Socket 放入全局等待队列 server.clients_pending_read 中，接着，主线程通过轮询的方式将 Socket 连接分配给 IO 线程。</p><p>主线程一旦将 Socket 分配给 IO 线程，那么就会进入阻塞，等待 IO 线程完成客户端的请求读取和解析，由于有多个 IO 线程在并行处理，那么这个过程很快。</p><p>等待 IO 线程解析完请求，主线程还是会以单线程的方式执行命令。</p><p>在源码中方法调用是：</p><p>server.c -&gt; initServer -&gt; acceptTcpHandler -&gt; acceptCommonHandler -&gt; createClient -&gt; readQueryFromClient -&gt; postponeClientRead</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">postponeClientRead</span><span class="hljs-params">(client *c)</span> &#123;<br>    <span class="hljs-keyword">if</span> (server.io_threads_active &amp;&amp;<br>        server.io_threads_do_reads &amp;&amp;<br>        !ProcessingEventsWhileBlocked &amp;&amp;<br>        !(c-&gt;flags &amp; (CLIENT_MASTER|CLIENT_SLAVE|CLIENT_PENDING_READ|CLIENT_BLOCKED))) <br>    &#123;<br>        c-&gt;flags |= CLIENT_PENDING_READ;<br>        <span class="hljs-comment">// 将客户端加入 clients_pending_read 队列中</span><br>        listAddNodeHead(server.clients_pending_read,c);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>将 Socket 连接分配给 IO 线程，方法调用是：server.c -&gt; beforeSleep -&gt; handleClientsWithPendingReadsUsingThreads</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">handleClientsWithPendingReadsUsingThreads</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!server.io_threads_active || !server.io_threads_do_reads) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> processed = listLength(server.clients_pending_read);<br>    <span class="hljs-keyword">if</span> (processed == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/* Distribute the clients across N different lists. */</span><br>    listIter li;<br>    listNode *ln;<br>    listRewind(server.clients_pending_read,&amp;li);<br>    <span class="hljs-type">int</span> item_id = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 通过遍历将 client 加入到 io_threads_list 中</span><br>    <span class="hljs-keyword">while</span>((ln = listNext(&amp;li))) &#123;<br>        client *c = listNodeValue(ln);<br>        <span class="hljs-type">int</span> target_id = item_id % server.io_threads_num;<br>        listAddNodeTail(io_threads_list[target_id],c);<br>        item_id++;<br>    &#125;<br><br>    <span class="hljs-comment">/* Give the start condition to the waiting threads, by setting the</span><br><span class="hljs-comment">     * start condition atomic var. */</span><br>    io_threads_op = IO_THREADS_OP_READ;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; server.io_threads_num; j++) &#123;<br>        <span class="hljs-type">int</span> count = listLength(io_threads_list[j]);<br>        setIOPendingCount(j, count);<br>    &#125;<br><br>    <span class="hljs-comment">/* Also use the main thread to process a slice of clients. */</span><br>    <span class="hljs-comment">// 使用主线程来执行客户端命令</span><br>    listRewind(io_threads_list[<span class="hljs-number">0</span>],&amp;li);<br>    <span class="hljs-keyword">while</span>((ln = listNext(&amp;li))) &#123;<br>        client *c = listNodeValue(ln);<br>        readQueryFromClient(c-&gt;conn);<br>    &#125;<br>    listEmpty(io_threads_list[<span class="hljs-number">0</span>]);<br><br>    <span class="hljs-comment">/* Wait for all the other threads to end their work. */</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> pending = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; server.io_threads_num; j++)<br>            pending += getIOPendingCount(j);<br>        <span class="hljs-keyword">if</span> (pending == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* Run the list of clients again to process the new buffers. */</span><br>    <span class="hljs-keyword">while</span>(listLength(server.clients_pending_read)) &#123;<br>        ln = listFirst(server.clients_pending_read);<br>        client *c = listNodeValue(ln);<br>        c-&gt;flags &amp;= ~CLIENT_PENDING_READ;<br>        listDelNode(server.clients_pending_read,ln);<br><br>        serverAssert(!(c-&gt;flags &amp; CLIENT_BLOCKED));<br>        <span class="hljs-keyword">if</span> (processPendingCommandsAndResetClient(c) == C_ERR) &#123;<br>            <span class="hljs-comment">/* If the client is no longer valid, we avoid</span><br><span class="hljs-comment">             * processing the client later. So we just go</span><br><span class="hljs-comment">             * to the next. */</span><br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        processInputBuffer(c);<br><br>        <span class="hljs-comment">/* We may have pending replies if a thread readQueryFromClient() produced</span><br><span class="hljs-comment">         * replies and did not install a write handler (it can&#x27;t).</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">if</span> (!(c-&gt;flags &amp; CLIENT_PENDING_WRITE) &amp;&amp; clientHasPendingReplies(c))<br>            clientInstallWriteHandler(c);<br>    &#125;<br><br>    <span class="hljs-comment">/* Update processed count on server */</span><br>    server.stat_io_reads_processed += processed;<br><br>    <span class="hljs-keyword">return</span> processed;<br>&#125;<br></code></pre></td></tr></table></figure><p>而当主线程执行完请求操作后，会将返回的结果写到缓冲区，然后主线程阻塞等待 IO 线程将这些结果写回到 Socket 中，并返回给客户端。</p><p>和 IO 线程读取和解析请求一样，IO 线程回写 Socket 时，也是有多个线程在并发执行，所以回写 Socket 的速度也很快。等到 IO 线程回写 Socket 完毕，主线程会清空全局队列，等待客户端的后续请求。</p><p>在源码中方法调用是：server.c -&gt; beforeSleep -&gt; handleClientsWithPendingWritesUsingThreads</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">handleClientsWithPendingWritesUsingThreads</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-type">int</span> processed = listLength(server.clients_pending_write);<br>    <span class="hljs-keyword">if</span> (processed == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">/* Return ASAP if there are no clients. */</span><br><br>    <span class="hljs-comment">/* If I/O threads are disabled or we have few clients to serve, don&#x27;t</span><br><span class="hljs-comment">     * use I/O threads, but the boring synchronous code. */</span><br>    <span class="hljs-comment">// 如果没有启用 IO 线程，那么会执行 handleClientsWithPendingWrites 函数</span><br>    <span class="hljs-keyword">if</span> (server.io_threads_num == <span class="hljs-number">1</span> || stopThreadedIOIfNeeded()) &#123;<br>        <span class="hljs-keyword">return</span> handleClientsWithPendingWrites();<br>    &#125;<br><br>    <span class="hljs-comment">/* Start threads if needed. */</span><br>    <span class="hljs-keyword">if</span> (!server.io_threads_active) startThreadedIO();<br><br>    <span class="hljs-comment">/* Distribute the clients across N different lists. */</span><br>    listIter li;<br>    listNode *ln;<br>    listRewind(server.clients_pending_write,&amp;li);<br>    <span class="hljs-type">int</span> item_id = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>((ln = listNext(&amp;li))) &#123;<br>        client *c = listNodeValue(ln);<br>        c-&gt;flags &amp;= ~CLIENT_PENDING_WRITE;<br><br>        <span class="hljs-comment">/* Remove clients from the list of pending writes since</span><br><span class="hljs-comment">         * they are going to be closed ASAP. */</span><br>        <span class="hljs-keyword">if</span> (c-&gt;flags &amp; CLIENT_CLOSE_ASAP) &#123;<br>            listDelNode(server.clients_pending_write, ln);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> target_id = item_id % server.io_threads_num;<br>        listAddNodeTail(io_threads_list[target_id],c);<br>        item_id++;<br>    &#125;<br><br>    <span class="hljs-comment">/* Give the start condition to the waiting threads, by setting the</span><br><span class="hljs-comment">     * start condition atomic var. */</span><br>    io_threads_op = IO_THREADS_OP_WRITE;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; server.io_threads_num; j++) &#123;<br>        <span class="hljs-type">int</span> count = listLength(io_threads_list[j]);<br>        setIOPendingCount(j, count);<br>    &#125;<br><br>    <span class="hljs-comment">/* Also use the main thread to process a slice of clients. */</span><br>    listRewind(io_threads_list[<span class="hljs-number">0</span>],&amp;li);<br>    <span class="hljs-keyword">while</span>((ln = listNext(&amp;li))) &#123;<br>        client *c = listNodeValue(ln);<br>        writeToClient(c,<span class="hljs-number">0</span>);<br>    &#125;<br>    listEmpty(io_threads_list[<span class="hljs-number">0</span>]);<br><br>    <span class="hljs-comment">/* Wait for all the other threads to end their work. */</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> pending = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; server.io_threads_num; j++)<br>            pending += getIOPendingCount(j);<br>        <span class="hljs-keyword">if</span> (pending == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* Run the list of clients again to install the write handler where</span><br><span class="hljs-comment">     * needed. */</span><br>    listRewind(server.clients_pending_write,&amp;li);<br>    <span class="hljs-keyword">while</span>((ln = listNext(&amp;li))) &#123;<br>        client *c = listNodeValue(ln);<br><br>        <span class="hljs-comment">/* Install the write handler if there are pending writes in some</span><br><span class="hljs-comment">         * of the clients. */</span><br>        <span class="hljs-keyword">if</span> (clientHasPendingReplies(c) &amp;&amp;<br>                connSetWriteHandler(c-&gt;conn, sendReplyToClient) == AE_ERR)<br>        &#123;<br>            freeClientAsync(c);<br>        &#125;<br>    &#125;<br>    listEmpty(server.clients_pending_write);<br><br>    <span class="hljs-comment">/* Update processed count on server */</span><br>    server.stat_io_writes_processed += processed;<br><br>    <span class="hljs-keyword">return</span> processed;<br>&#125;<br></code></pre></td></tr></table></figure><p>大致流程如下图：</p><p><img src="/java/redis-c5d4aef838ce/image-20240114173506524.png" alt="流程"></p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis 为什么那么快</title>
    <link href="/java/redis-8c60558ad544/"/>
    <url>/java/redis-8c60558ad544/</url>
    
    <content type="html"><![CDATA[<h1>redis 为什么那么快</h1><p>redis 之所以性能如此之快，主要有以下几个原因：</p><ol><li><strong>基于内存</strong>：redis 是一种基于内存的数据库，数据是存储在内存中，一般存储介质是 RAM，数据读写非常快，访问速度远超过磁盘读写。</li><li><strong>单线程模型</strong>：redis 使用单线程模型，那么它的所有操作都是在一个线程中进行，无需进行线程上下文切换，大大提高了 redis 的响应速度和运行效率。</li><li><strong>采用 I/O 多路复用模型</strong>：redis 在单线程的基础上，采用了 I/O 多路复用技术，实现了单个线程同时处理多个客户端连接的能力，从而提高 redis 的并发性能。</li><li><strong>redis 基于高效的数据结构</strong>：redis 提高多种高效的数据结构，如哈希表，有序集合，跳表等，多数都能在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 的时间复杂度下完成数据读写，这也是 redis 快速处理数据请求的原因之一。</li><li><strong>引入多线程</strong>：redis 在 6.0 引入了多线程，进一步提升了 I/O 性能，使得网络处理的请求并发进行，大大提升性能，还可以充分利用多核 CPU 的优势。</li></ol><h2 id="基于内存">基于内存</h2><p>内存想必就不用多说了，在计算机中，内存的数据读写速度是远大于磁盘的。</p><h2 id="单线程模型">单线程模型</h2><p>首先需要说明一个事实，我们通常说 redis 基于单线程，主要是指 redis 的网络 I/O 和数据读写是由一个线程完成的，这也是 redis 对外提供数据存储服务的主要流程。但是 redis 的其他功能，比如持久化、异步删除、集群数据同步等，都是由额外的线程进行的。</p><p>redis 为什么使用单线程，这就不得不提到多线程下的开销。</p><p>我们经常听到这样的言论：“使用多线程，可以增加系统吞吐率，提升效率”，对于一个多线程系统来说，如果资源分配合理，可以增加系统中处理请求的线程数，进而提高系统能够同时处理的请求数，也就是提高吞吐率。</p><p>但是在多线程系统中，如果没有良好的系统设计，实际上，随着线程的增多，系统的吞吐率开始增长缓慢，甚至下降。</p><p>主要在于，如果线程过多，那么会有多个并发的线程同时访问系统的共享资源，那么就必须要使用额外的锁机制，来保证资源的互斥访问，这就会带来额外的开销，要么就会进行线程上下文切换，要么会在 CPU 上自旋等待，这都是资源的浪费。</p><p>而且抛开持久化不说，redis 是存内存操作，执行速度非常快，它的性能瓶颈是网络延迟而不是执行速度，因此引入多线程也不会带来巨大的性能提升。</p><p>这也就是为什么 redis 使用单线程模型。</p>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-19c25ed0" role="button" aria-expanded="false" aria-controls="collapse-19c25ed0">        <div class="fold-arrow">▶</div>可能继续问到      </div>      <div class="fold-collapse collapse" id="collapse-19c25ed0">        <div class="fold-content">          <p>redis 为什么引入多线程？<a href="/java/redis-c5d4aef838ce/" title="redis 引入多线程">redis 引入多线程</a></p>        </div>      </div>    </div><h2 id="I-O-多路复用">I/O 多路复用</h2><a href="/java/redis-75ba9f9c982a/" title="redis 中的 IO 模型">redis 中的 IO 模型</a><h2 id="redis-中高效的数据结构">redis 中高效的数据结构</h2><a href="/java/redis-25334f7a71a2/" title="redis 中有哪些高效的数据结构">redis 中有哪些高效的数据结构</a><h2 id="引入多线程">引入多线程</h2><a href="/java/redis-c5d4aef838ce/" title="redis 引入多线程">redis 引入多线程</a>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java nio</title>
    <link href="/java/javase-beb1cfdacc32/"/>
    <url>/java/javase-beb1cfdacc32/</url>
    
    <content type="html"><![CDATA[<h1>JavaNIO</h1><p>Nio，non-blocking io 非阻塞 IO。</p><h2 id="1-NIO-三大组件">1. NIO 三大组件</h2><h3 id="1-1-Channel">1.1 Channel</h3><p>channel 类似于 stream，是读写数据的 <strong>双向通道</strong>，可以从 channel 将数据读入 buffer，也可以将 buffer 的数据写入 channel。</p><p>常见的 Channel 有</p><ul><li>FileChannel：文件的传输通道</li><li>DatagramChannel：UDP 编程的数据传输通道</li><li>SocketChannel：TCP 编程的数据传输通道，用于客户端和服务端</li><li>ServerSocketChannel：TCP 编程的数据传输通道，用于服务端</li></ul><h3 id="1-2-Buffer">1.2 Buffer</h3><p>buffer 是用来缓冲读写数据的，常见的 buffer 有：</p><ul><li>ByteBuffer<ul><li>MappedByteBuffer</li><li>DirectByteBuffer</li><li>HeapByteBuffer</li></ul></li><li>ShortBuffer 等</li></ul><h3 id="1-3-Selector">1.3 Selector</h3><p>在 Nio 出现之前，我们是如何开发服务器端的程序？</p><p>第一种思路是采用多线程，</p><p><img src="/java/javase-beb1cfdacc32/image-20240114211341124.png" alt="多线程设计"></p><p>当一个客户端连接到服务器，它表现为一个客户端和服务器之间的 socket 连接，我们针对这个 socket 就可以做一些读写的操作。</p><p>而如果有多个客户端连接，那么服务器可以开启与客户端数量相等的线程来分别处理这些连接。</p><p>这种方式的弊端在于：</p><ol><li>这种服务器无法处理高并发的连接请求，因为创建线程需要消耗一定的内存，随着连接数的增加，内存很有可能不足。</li><li>另外，随着线程数量的增多，而 CPU 的核数只有那么多，势必会导致频繁的线程上下文切换从而造成额外的开销。</li></ol><p>所以这种架构方式只适用于连接数少的服务器。</p><p>第二种思路是采用线程池的方式，</p><p><img src="/java/javase-beb1cfdacc32/image-20240114213119019.png" alt="线程池"></p><p>多线程的设计，由于线程数太多而导致内存占用高，并且过多的线程必然导致线程上下文切换的开销也增大。</p><p>所以线程池的设计主要就是限制了线程的数量。</p><p>但是此时的问题是，socket api 是处于阻塞模式，也就是说，一个线程只有处理完此时的 socket 连接，才能继续处理其他的 socket 连接，如果此时的 socket 连接什么也不做，但就是不断开，那么这个线程也在这里干等着，白白浪费了资源。</p><p>所以这种线程池的设计更加适用于一些短连接的场景，比如 HTTP 请求，你发送了请求，得到响应之后就可以断开了，当前线程又可以去处理其他请求了。</p><p>接下来我们看看 selector 的设计思路，</p><p><img src="/java/javase-beb1cfdacc32/image-20240114213101046.png" alt="selector"></p><p>我们不妨打个比喻，服务器就像是一家餐馆，线程就是餐馆的服务员，那么图中的 channel 就像是顾客。</p><p>而核心就是 selector 选择器就像是一个点餐电脑，一旦顾客扫描餐桌上的二维码点餐或者结账，那么这台电脑就可以收到并通知服务员处理。</p><p>所以 selector，它就是管理多个 channel，并且可以获得这些 channel 上所有发生的事件，具体分为可连接、可读、可写。一旦这些事件触发，selector 就可以让一个线程来处理这些读写操作。</p><p>还有一点是，channel 工作在非阻塞模式下，它不会出现像 socket 连接没断开之前，线程死等的情况，一旦某个 channel 上没有事件，那么线程还可以去处理另一个 channel，这样就大大提升了线程的利用率。</p><p>这种方式就比较适合处理高并发的场景。</p><h2 id="2-ByteBuffer">2. ByteBuffer</h2><h3 id="2-1-基本使用">2.1 基本使用</h3><p>有一普通文本文件 data.txt，内容为</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">1234567890abcd<br></code></pre></td></tr></table></figure><p>使用 FileChannel 来读取文件内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ByteBufferTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">RandomAccessFile</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomAccessFile</span>(<span class="hljs-string">&quot;data.txt&quot;</span>, <span class="hljs-string">&quot;rw&quot;</span>)) &#123;<br>            <span class="hljs-type">FileChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> file.getChannel();<br>            <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">10</span>);<br>            <span class="hljs-keyword">do</span> &#123;<br>                <span class="hljs-comment">// 向 buffer 写</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> channel.read(buffer);<br>                <span class="hljs-keyword">if</span> (len == -<span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">// 切换到 buffer 读模式</span><br>                buffer.flip();<br>                <span class="hljs-keyword">while</span> (buffer.hasRemaining()) &#123;<br>                    log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, (<span class="hljs-type">char</span>) buffer.get());<br>                &#125;<br>                <span class="hljs-comment">// 切换到 buffer 写模式</span><br>                buffer.clear();<br>            &#125; <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, e.toString());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">21</span>:<span class="hljs-number">54</span>:<span class="hljs-number">54</span> [DEBUG] [main] c.o.ByteBufferTest - <span class="hljs-number">1</span><br><span class="hljs-number">21</span>:<span class="hljs-number">54</span>:<span class="hljs-number">54</span> [DEBUG] [main] c.o.ByteBufferTest - <span class="hljs-number">2</span><br><span class="hljs-number">21</span>:<span class="hljs-number">54</span>:<span class="hljs-number">54</span> [DEBUG] [main] c.o.ByteBufferTest - <span class="hljs-number">3</span><br><span class="hljs-number">21</span>:<span class="hljs-number">54</span>:<span class="hljs-number">54</span> [DEBUG] [main] c.o.ByteBufferTest - <span class="hljs-number">4</span><br><span class="hljs-number">21</span>:<span class="hljs-number">54</span>:<span class="hljs-number">54</span> [DEBUG] [main] c.o.ByteBufferTest - <span class="hljs-number">5</span><br><span class="hljs-number">21</span>:<span class="hljs-number">54</span>:<span class="hljs-number">54</span> [DEBUG] [main] c.o.ByteBufferTest - <span class="hljs-number">6</span><br><span class="hljs-number">21</span>:<span class="hljs-number">54</span>:<span class="hljs-number">54</span> [DEBUG] [main] c.o.ByteBufferTest - <span class="hljs-number">7</span><br><span class="hljs-number">21</span>:<span class="hljs-number">54</span>:<span class="hljs-number">54</span> [DEBUG] [main] c.o.ByteBufferTest - <span class="hljs-number">8</span><br><span class="hljs-number">21</span>:<span class="hljs-number">54</span>:<span class="hljs-number">54</span> [DEBUG] [main] c.o.ByteBufferTest - <span class="hljs-number">9</span><br><span class="hljs-number">21</span>:<span class="hljs-number">54</span>:<span class="hljs-number">54</span> [DEBUG] [main] c.o.ByteBufferTest - <span class="hljs-number">0</span><br><span class="hljs-number">21</span>:<span class="hljs-number">54</span>:<span class="hljs-number">54</span> [DEBUG] [main] c.o.ByteBufferTest - a<br><span class="hljs-number">21</span>:<span class="hljs-number">54</span>:<span class="hljs-number">54</span> [DEBUG] [main] c.o.ByteBufferTest - b<br><span class="hljs-number">21</span>:<span class="hljs-number">54</span>:<span class="hljs-number">54</span> [DEBUG] [main] c.o.ByteBufferTest - c<br><span class="hljs-number">21</span>:<span class="hljs-number">54</span>:<span class="hljs-number">54</span> [DEBUG] [main] c.o.ByteBufferTest - d<br></code></pre></td></tr></table></figure><h3 id="2-2-内部结构">2.2 内部结构</h3><p>ByteBuffer 有下面三个重要属性：</p><ul><li>capacity</li><li>position</li><li>limit</li></ul><p>最初</p><p><img src="/java/javase-beb1cfdacc32/image-20240114220422251.png" alt="初始"></p><p>写模式下，position 是写入位置，limit 相当于容量，当向 ByteBuffer 中写入 4 个字节，</p><p><img src="/java/javase-beb1cfdacc32/image-20240114220657700.png" alt="写入 4 个字节"></p><p>当调用 flip，position 切换为读取位置，limit 切换为读取限制，</p><p><img src="/java/javase-beb1cfdacc32/image-20240114220825114.png" alt="读取模式"></p><p>此时读取 4 个字节，</p><p><img src="/java/javase-beb1cfdacc32/image-20240114220913243.png" alt="读取 4 个字节后"></p><p>当调用 clear 方法，</p><p><img src="/java/javase-beb1cfdacc32/image-20240114221020790.png" alt="clear"></p><p>而对于 compact 方法，是将未读取完的部分，向前压缩，并切换为写模式，在 compact 前，</p><p><img src="/java/javase-beb1cfdacc32/image-20240114221142132.png" alt="compact 前"></p><p>在 compact 后，</p><p><img src="/java/javase-beb1cfdacc32/image-20240114221319529.png" alt="compact 后"></p><p>所以对于 ByteBuffer，正确的使用姿势是：</p><ol><li>向 ByteBuffer 写入数据，如调用 channel.read(buffer)</li><li>调用 filp 切换为读模式</li><li>从 buffer 中读取数据，如调用 buffer.get()</li><li>调用 clear 或者 compact 切换到写模式</li><li>重复 1 ~ 4</li></ol>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-5b75660a" role="button" aria-expanded="false" aria-controls="collapse-5b75660a">        <div class="fold-arrow">▶</div>调试方法      </div>      <div class="fold-collapse collapse" id="collapse-5b75660a">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> io.netty.util.internal.StringUtil;<br><br><span class="hljs-keyword">import</span> java.nio.ByteBuffer;<br><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> io.netty.util.internal.MathUtil.isOutOfBounds;<br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> io.netty.util.internal.StringUtil.NEWLINE;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ByteBufferUtil</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">char</span>[] BYTE2CHAR = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">256</span>];<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">char</span>[] HEXDUMP_TABLE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">256</span> * <span class="hljs-number">4</span>];<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String[] HEXPADDING = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">16</span>];<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String[] HEXDUMP_ROWPREFIXES = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">65536</span> &gt;&gt;&gt; <span class="hljs-number">4</span>];<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String[] BYTE2HEX = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">256</span>];<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String[] BYTEPADDING = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">16</span>];<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">char</span>[] DIGITS = <span class="hljs-string">&quot;0123456789abcdef&quot;</span>.toCharArray();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++) &#123;<br>            HEXDUMP_TABLE[i &lt;&lt; <span class="hljs-number">1</span>] = DIGITS[i &gt;&gt;&gt; <span class="hljs-number">4</span> &amp; <span class="hljs-number">0x0F</span>];<br>            HEXDUMP_TABLE[(i &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>] = DIGITS[i &amp; <span class="hljs-number">0x0F</span>];<br>        &#125;<br><br>        <span class="hljs-type">int</span> i;<br><br>        <span class="hljs-comment">// Generate the lookup table for hex dump paddings</span><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; HEXPADDING.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">padding</span> <span class="hljs-operator">=</span> HEXPADDING.length - i;<br>            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(padding * <span class="hljs-number">3</span>);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; padding; j++) &#123;<br>                buf.append(<span class="hljs-string">&quot;   &quot;</span>);<br>            &#125;<br>            HEXPADDING[i] = buf.toString();<br>        &#125;<br><br>        <span class="hljs-comment">// Generate the lookup table for the start-offset header in each row (up to 64KiB).</span><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; HEXDUMP_ROWPREFIXES.length; i++) &#123;<br>            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-number">12</span>);<br>            buf.append(NEWLINE);<br>            buf.append(Long.toHexString(i &lt;&lt; <span class="hljs-number">4</span> &amp; <span class="hljs-number">0xFFFFFFFFL</span> | <span class="hljs-number">0x100000000L</span>));<br>            buf.setCharAt(buf.length() - <span class="hljs-number">9</span>, <span class="hljs-string">&#x27;|&#x27;</span>);<br>            buf.append(<span class="hljs-string">&#x27;|&#x27;</span>);<br>            HEXDUMP_ROWPREFIXES[i] = buf.toString();<br>        &#125;<br><br>        <span class="hljs-comment">// Generate the lookup table for byte-to-hex-dump conversion</span><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; BYTE2HEX.length; i++) &#123;<br>            BYTE2HEX[i] = <span class="hljs-string">&#x27; &#x27;</span> + StringUtil.byteToHexStringPadded(i);<br>        &#125;<br><br>        <span class="hljs-comment">// Generate the lookup table for byte dump paddings</span><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; BYTEPADDING.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">padding</span> <span class="hljs-operator">=</span> BYTEPADDING.length - i;<br>            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(padding);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; padding; j++) &#123;<br>                buf.append(<span class="hljs-string">&#x27; &#x27;</span>);<br>            &#125;<br>            BYTEPADDING[i] = buf.toString();<br>        &#125;<br><br>        <span class="hljs-comment">// Generate the lookup table for byte-to-char conversion</span><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; BYTE2CHAR.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i &lt;= <span class="hljs-number">0x1f</span> || i &gt;= <span class="hljs-number">0x7f</span>) &#123;<br>                BYTE2CHAR[i] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                BYTE2CHAR[i] = (<span class="hljs-type">char</span>) i;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 打印所有内容</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> buffer</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">debugAll</span><span class="hljs-params">(ByteBuffer buffer)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">oldlimit</span> <span class="hljs-operator">=</span> buffer.limit();<br>        buffer.limit(buffer.capacity());<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">origin</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-number">256</span>);<br>        appendPrettyHexDump(origin, buffer, <span class="hljs-number">0</span>, buffer.capacity());<br>        System.out.println(<span class="hljs-string">&quot;+--------+-------------------- all ------------------------+----------------+&quot;</span>);<br>        System.out.printf(<span class="hljs-string">&quot;position: [%d], limit: [%d]\n&quot;</span>, buffer.position(), oldlimit);<br>        System.out.println(origin);<br>        buffer.limit(oldlimit);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 打印可读取内容</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> buffer</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">debugRead</span><span class="hljs-params">(ByteBuffer buffer)</span> &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-number">256</span>);<br>        appendPrettyHexDump(builder, buffer, buffer.position(), buffer.limit() - buffer.position());<br>        System.out.println(<span class="hljs-string">&quot;+--------+-------------------- read -----------------------+----------------+&quot;</span>);<br>        System.out.printf(<span class="hljs-string">&quot;position: [%d], limit: [%d]\n&quot;</span>, buffer.position(), buffer.limit());<br>        System.out.println(builder);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">appendPrettyHexDump</span><span class="hljs-params">(StringBuilder dump, ByteBuffer buf, <span class="hljs-type">int</span> offset, <span class="hljs-type">int</span> length)</span> &#123;<br>        <span class="hljs-keyword">if</span> (isOutOfBounds(offset, length, buf.capacity())) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexOutOfBoundsException</span>(<br>                    <span class="hljs-string">&quot;expected: &quot;</span> + <span class="hljs-string">&quot;0 &lt;= offset(&quot;</span> + offset + <span class="hljs-string">&quot;) &lt;= offset + length(&quot;</span> + length<br>                            + <span class="hljs-string">&quot;) &lt;= &quot;</span> + <span class="hljs-string">&quot;buf.capacity(&quot;</span> + buf.capacity() + <span class="hljs-string">&#x27;)&#x27;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        dump.append(<br>                <span class="hljs-string">&quot;         +-------------------------------------------------+&quot;</span> +<br>                        NEWLINE + <span class="hljs-string">&quot;         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |&quot;</span> +<br>                        NEWLINE + <span class="hljs-string">&quot;+--------+-------------------------------------------------+----------------+&quot;</span>);<br><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">startIndex</span> <span class="hljs-operator">=</span> offset;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">fullRows</span> <span class="hljs-operator">=</span> length &gt;&gt;&gt; <span class="hljs-number">4</span>;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">remainder</span> <span class="hljs-operator">=</span> length &amp; <span class="hljs-number">0xF</span>;<br><br>        <span class="hljs-comment">// Dump the rows which have 16 bytes.</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; row &lt; fullRows; row++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">rowStartIndex</span> <span class="hljs-operator">=</span> (row &lt;&lt; <span class="hljs-number">4</span>) + startIndex;<br><br>            <span class="hljs-comment">// Per-row prefix.</span><br>            appendHexDumpRowPrefix(dump, row, rowStartIndex);<br><br>            <span class="hljs-comment">// Hex dump</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">rowEndIndex</span> <span class="hljs-operator">=</span> rowStartIndex + <span class="hljs-number">16</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> rowStartIndex; j &lt; rowEndIndex; j++) &#123;<br>                dump.append(BYTE2HEX[getUnsignedByte(buf, j)]);<br>            &#125;<br>            dump.append(<span class="hljs-string">&quot; |&quot;</span>);<br><br>            <span class="hljs-comment">// ASCII dump</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> rowStartIndex; j &lt; rowEndIndex; j++) &#123;<br>                dump.append(BYTE2CHAR[getUnsignedByte(buf, j)]);<br>            &#125;<br>            dump.append(<span class="hljs-string">&#x27;|&#x27;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// Dump the last row which has less than 16 bytes.</span><br>        <span class="hljs-keyword">if</span> (remainder != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">rowStartIndex</span> <span class="hljs-operator">=</span> (fullRows &lt;&lt; <span class="hljs-number">4</span>) + startIndex;<br>            appendHexDumpRowPrefix(dump, fullRows, rowStartIndex);<br><br>            <span class="hljs-comment">// Hex dump</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">rowEndIndex</span> <span class="hljs-operator">=</span> rowStartIndex + remainder;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> rowStartIndex; j &lt; rowEndIndex; j++) &#123;<br>                dump.append(BYTE2HEX[getUnsignedByte(buf, j)]);<br>            &#125;<br>            dump.append(HEXPADDING[remainder]);<br>            dump.append(<span class="hljs-string">&quot; |&quot;</span>);<br><br>            <span class="hljs-comment">// Ascii dump</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> rowStartIndex; j &lt; rowEndIndex; j++) &#123;<br>                dump.append(BYTE2CHAR[getUnsignedByte(buf, j)]);<br>            &#125;<br>            dump.append(BYTEPADDING[remainder]);<br>            dump.append(<span class="hljs-string">&#x27;|&#x27;</span>);<br>        &#125;<br><br>        dump.append(NEWLINE +<br>                <span class="hljs-string">&quot;+--------+-------------------------------------------------+----------------+&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">appendHexDumpRowPrefix</span><span class="hljs-params">(StringBuilder dump, <span class="hljs-type">int</span> row, <span class="hljs-type">int</span> rowStartIndex)</span> &#123;<br>        <span class="hljs-keyword">if</span> (row &lt; HEXDUMP_ROWPREFIXES.length) &#123;<br>            dump.append(HEXDUMP_ROWPREFIXES[row]);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            dump.append(NEWLINE);<br>            dump.append(Long.toHexString(rowStartIndex &amp; <span class="hljs-number">0xFFFFFFFFL</span> | <span class="hljs-number">0x100000000L</span>));<br>            dump.setCharAt(dump.length() - <span class="hljs-number">9</span>, <span class="hljs-string">&#x27;|&#x27;</span>);<br>            dump.append(<span class="hljs-string">&#x27;|&#x27;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">short</span> <span class="hljs-title function_">getUnsignedByte</span><span class="hljs-params">(ByteBuffer buffer, <span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">short</span>) (buffer.get(index) &amp; <span class="hljs-number">0xFF</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h3 id="2-3-常用方法">2.3 常用方法</h3><h4 id="分配空间">分配空间</h4><p>使用 allocate 方法为 ByteBuffer 分配空间，其它 buffer 类也有该方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Bytebuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">16</span>);<br></code></pre></td></tr></table></figure><h4 id="向-buffer-写入数据">向 buffer 写入数据</h4><p>主要有两种方式</p><ul><li>调用 channel 的 read 方法，可以理解为从 channel 中读出了数据然后写到 buffer 中</li><li>调用 buffer 的 put 方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">readBytes</span> <span class="hljs-operator">=</span> channel.read(buf);<br></code></pre></td></tr></table></figure><p>和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">buf.put((<span class="hljs-type">byte</span>)<span class="hljs-number">127</span>);<br></code></pre></td></tr></table></figure><h4 id="从-buffer-读取数据">从 buffer 读取数据</h4><p>同样有两种方式</p><ul><li>调用 channel 的 write 方法，可以理解为从 buffer 中读出了数据然后写到 channel 中</li><li>调用 buffer 自己的 get 方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">writeBytes</span> <span class="hljs-operator">=</span> channel.write(buf);<br></code></pre></td></tr></table></figure><p>和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> buf.get();<br></code></pre></td></tr></table></figure><p>get 方法会让 position 读指针向后走，如果想重复读取数据</p><ul><li>可以调用 rewind 方法将 position 重新置为 0</li><li>或者调用 get(int i) 方法获取索引 i 的内容，这个方法不会移动读指针</li></ul><h4 id="mark-和-reset">mark 和 reset</h4><p>mark 是在读取时，做一个标记，即使 position 改变，只要调用 reset 就能回到 mark 的位置，注意 rewind 和 flip 都会清除 mark 位置。</p><h4 id="字符串与-ByteBuffer-互转">字符串与 ByteBuffer 互转</h4><p>字符串转为 ByteBuffer，可以使用 encode 方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf1</span> <span class="hljs-operator">=</span> StandardCharsets.UTF_8.encode(<span class="hljs-string">&quot;你好&quot;</span>);<br><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf2</span> <span class="hljs-operator">=</span> Charset.forName(<span class="hljs-string">&quot;utf-8&quot;</span>).encode(<span class="hljs-string">&quot;你好&quot;</span>);<br></code></pre></td></tr></table></figure><p>而 ByteBuffer 转为字符串，使用 decode 方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">CharBuffer</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> StandardCharsets.UTF_8.decode(buf1);<br><span class="hljs-type">CharBuffer</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> StandardCharsets.UTF_8.decode(buf2);<br>System.out.println(str1);<br>System.out.println(str2);<br></code></pre></td></tr></table></figure><h4 id="分散读取和集中填充">分散读取和集中填充</h4><p>分散读取：使用如下方式读取，可以将数据填充至多个 buffer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">RandomAccessFile</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomAccessFile</span>(<span class="hljs-string">&quot;parts.txt&quot;</span>, <span class="hljs-string">&quot;rw&quot;</span>)) &#123;<br>    <span class="hljs-type">FileChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> file.getChannel();<br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">3</span>);<br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">3</span>);<br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">5</span>);<br>    channel.read(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteBuffer</span>[]&#123;a, b, c&#125;);<br>    a.flip();<br>    b.flip();<br>    c.flip();<br>    debugAll(a);<br>    debugAll(b);<br>    debugAll(c);<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">         +-------------------------------------------------+<br>         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|<span class="hljs-number">00000000</span>| <span class="hljs-number">6f</span> 6e <span class="hljs-number">65</span>                                        |one             |<br>+--------+-------------------------------------------------+----------------+<br>         +-------------------------------------------------+<br>         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|<span class="hljs-number">00000000</span>| <span class="hljs-number">74</span> <span class="hljs-number">77</span> <span class="hljs-number">6f</span>                                        |two             |<br>+--------+-------------------------------------------------+----------------+<br>         +-------------------------------------------------+<br>         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|<span class="hljs-number">00000000</span>| <span class="hljs-number">74</span> <span class="hljs-number">68</span> <span class="hljs-number">72</span> <span class="hljs-number">65</span> <span class="hljs-number">65</span>                                  |three           |<br>+--------+-------------------------------------------------+----------------+<br></code></pre></td></tr></table></figure><p>集中填充：使用如下方式写入，可以将多个 buffer 的数据填充至 channel</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">RandomAccessFile</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomAccessFile</span>(<span class="hljs-string">&quot;parts.txt&quot;</span>, <span class="hljs-string">&quot;rw&quot;</span>)) &#123;<br>    <span class="hljs-type">FileChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> file.getChannel();<br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">4</span>);<br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">4</span>);<br>    channel.position(<span class="hljs-number">11</span>);<br><br>    d.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[]&#123;<span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;u&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>&#125;);<br>    e.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[]&#123;<span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-string">&#x27;v&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>&#125;);<br>    d.flip();<br>    e.flip();<br>    debugAll(d);<br>    debugAll(e);<br>    channel.write(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteBuffer</span>[]&#123;d, e&#125;);<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 66 6f 75 72                                     |four            |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 66 69 76 65                                     |five            |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br></code></pre></td></tr></table></figure><p>文件内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">onetwothreefourfive<br></code></pre></td></tr></table></figure><h2 id="3-Channel-之文件编程">3. Channel 之文件编程</h2><h3 id="3-1-FileChannel">3.1 FileChannel</h3><h4 id="工作模式">工作模式</h4><p>FileChannel 只能工作在阻塞模式下</p><h4 id="获取">获取</h4><p>不能直接打开 FileChannel，必须通过 FileInputStream、FileOutputStream 或者 RandomAccessFile 来获取 FileChannel，它们都有 getChannel 方法</p><ul><li>通过 FileInputStream 获取的 channel 只能读</li><li>通过 FileOutputStream 获取的 channel 只能写</li><li>通过 RandomAccessFile 是否能读写根据构造 RandomAccessFile 时的读写模式决定</li></ul><h4 id="读取">读取</h4><p>会从 channel 读取数据填充 ByteBuffer，返回值表示读到了多少字节，-1 表示到达了文件的末尾</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">readBytes</span> <span class="hljs-operator">=</span> channel.read(buffer);<br></code></pre></td></tr></table></figure><h4 id="写入">写入</h4><p>写入的正确姿势如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ...;<br>buffer.put(...); <span class="hljs-comment">// 存入数据</span><br>buffer.flip();   <span class="hljs-comment">// 切换读模式</span><br><br><span class="hljs-keyword">while</span>(buffer.hasRemaining()) &#123;<br>    channel.write(buffer);<br>&#125;<br></code></pre></td></tr></table></figure><p>在 while 中调用 channel.write 是因为 write 方法并不能保证一次将 buffer 中的内容全部写入 channel</p><h4 id="关闭">关闭</h4><p>channel 必须关闭，不过调用了 FileInputStream、FileOutputStream 或 RandomAccessFile 的 close 方法会间接地调用 channel 的 close 方法。</p><h4 id="位置">位置</h4><p>获取当前位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span> <span class="hljs-variable">pos</span> <span class="hljs-operator">=</span> channel.position();<br></code></pre></td></tr></table></figure><p>设置当前位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span> <span class="hljs-variable">newPos</span> <span class="hljs-operator">=</span> ...;<br>channel.position(newPos);<br></code></pre></td></tr></table></figure><p>设置当前位置时，如果设置为文件的末尾</p><ul><li>这时读取会返回 -1</li><li>这时写入，会追加内容，但要注意如果 position 超过了文件末尾，再写入时在新内容和原末尾之间会有空洞（00）</li></ul><h4 id="大小">大小</h4><p>使用 size 方法获取文件的大小</p><h4 id="强制写入">强制写入</h4><p>操作系统出于性能的考虑，会将数据缓存，不是立刻写入磁盘。可以调用 force(true) 方法将文件内容和元数据（文件的权限等信息）立刻写入磁盘</p><h3 id="3-2-两个-Channel-传输数据">3.2 两个 Channel 传输数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">FROM</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;data.txt&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">TO</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;to.txt&quot;</span>;<br><br><span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.nanoTime();<br><span class="hljs-keyword">try</span> (<br>    <span class="hljs-type">FileChannel</span> <span class="hljs-variable">from</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(FROM).getChannel();<br>    <span class="hljs-type">FileChannel</span> <span class="hljs-variable">to</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(TO).getChannel();<br>) &#123;<br>    from.transferTo(<span class="hljs-number">0</span>, from.size(), to);<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace();<br>&#125;<br><span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.nanoTime();<br>System.out.println(<span class="hljs-string">&quot;transferTo 用时：&quot;</span> + (end - start) / <span class="hljs-number">1000_000.0</span>);<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">transferTo</span> 用时：<span class="hljs-number">8</span>.<span class="hljs-number">2011</span><br></code></pre></td></tr></table></figure><p>超过 2g 大小的文件传输</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestFileChannelTransferTo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> (<br>                <span class="hljs-type">FileChannel</span> <span class="hljs-variable">from</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;data.txt&quot;</span>).getChannel();<br>                <span class="hljs-type">FileChannel</span> <span class="hljs-variable">to</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;to.txt&quot;</span>).getChannel();<br>        ) &#123;<br>            <span class="hljs-comment">// 效率高，底层会利用操作系统的零拷贝进行优化</span><br>            <span class="hljs-type">long</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> from.size();<br>            <span class="hljs-comment">// left 变量代表还剩余多少字节</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> size; left &gt; <span class="hljs-number">0</span>; ) &#123;<br>                System.out.println(<span class="hljs-string">&quot;position:&quot;</span> + (size - left) + <span class="hljs-string">&quot; left:&quot;</span> + left);<br>                left -= from.transferTo((size - left), left, to);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际传输一个超大文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">position:<span class="hljs-number">0</span> left:<span class="hljs-number">7769948160</span><br>position:<span class="hljs-number">2147483647</span> left:<span class="hljs-number">5622464513</span><br>position:<span class="hljs-number">4294967294</span> left:<span class="hljs-number">3474980866</span><br>position:<span class="hljs-number">6442450941</span> left:<span class="hljs-number">1327497219</span><br></code></pre></td></tr></table></figure><h3 id="3-3-Path">3.3 Path</h3><p>jdk7 引入了 Path 和 Paths 类</p><ul><li>Path 用来表示文件路径</li><li>Paths 是工具类，用来获取 Path 实例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Path</span> <span class="hljs-variable">source</span> <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">&quot;1.txt&quot;</span>);     <span class="hljs-comment">// 相对路径，使用 user.dir 环境变量来定位 1.txt</span><br><span class="hljs-type">Path</span> <span class="hljs-variable">source</span> <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">&quot;d:\\1.txt&quot;</span>); <span class="hljs-comment">// 绝对路径，代表了 d:\1.txt</span><br><span class="hljs-type">Path</span> <span class="hljs-variable">source</span> <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">&quot;d:/1.txt&quot;</span>); <span class="hljs-comment">// 绝对路径，代表了 d:\1.txt</span><br><span class="hljs-type">Path</span> <span class="hljs-variable">projects</span> <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">&quot;d:\\data&quot;</span>, <span class="hljs-string">&quot;projects&quot;</span>);  <span class="hljs-comment">// 代表了 d:\data\projects</span><br></code></pre></td></tr></table></figure><ul><li><code>.</code> 代表了当前路径</li><li><code>..</code> 代表了上一级路径</li></ul><p>例如目录结构如下</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs 1c">d:<br><span class="hljs-string">|- data</span><br><span class="hljs-string">|- projects</span><br><span class="hljs-string">|- a</span><br><span class="hljs-string">|- b</span><br></code></pre></td></tr></table></figure><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Path</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">&quot;d:\\data\\projects\\a\\..\\b&quot;</span>);<br>System.out.println(path);<br>System.out.println(path.normalize()); <span class="hljs-comment">// 正常化路径</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">d</span>:\<span class="hljs-class"><span class="hljs-keyword">data</span>\projects\a\..\b</span><br><span class="hljs-title">d</span>:\<span class="hljs-class"><span class="hljs-keyword">data</span>\projects\b</span><br></code></pre></td></tr></table></figure><h3 id="3-4-Files">3.4 Files</h3><p>检查文件是否存在</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Path</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">&quot;helloword/data.txt&quot;</span>);<br>System.out.println(Files.exists(path));<br></code></pre></td></tr></table></figure><p>创建一级目录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Path</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">&quot;helloword/d1&quot;</span>);<br>Files.createDirectory(path);<br></code></pre></td></tr></table></figure><ul><li>如果目录已存在，会抛异常 FileAlreadyExistsException</li><li>不能一次创建多级目录，否则会抛异常 NoSuchFileException</li></ul><p>创建多级目录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Path</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">&quot;helloword/d1/d2&quot;</span>);<br>Files.createDirectories(path);<br></code></pre></td></tr></table></figure><p>拷贝文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Path</span> <span class="hljs-variable">source</span> <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">&quot;helloword/data.txt&quot;</span>);<br><span class="hljs-type">Path</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">&quot;helloword/target.txt&quot;</span>);<br><br>Files.copy(source, target);<br></code></pre></td></tr></table></figure><ul><li>如果文件已存在，会抛异常 FileAlreadyExistsException</li></ul><p>如果希望用 source 覆盖掉 target，需要用 StandardCopyOption 来控制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Files.copy(source, target, StandardCopyOption.REPLACE_EXISTING);<br></code></pre></td></tr></table></figure><p>移动文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Path</span> <span class="hljs-variable">source</span> <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">&quot;helloword/data.txt&quot;</span>);<br><span class="hljs-type">Path</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">&quot;helloword/data.txt&quot;</span>);<br><br>Files.move(source, target, StandardCopyOption.ATOMIC_MOVE);<br></code></pre></td></tr></table></figure><ul><li>StandardCopyOption.ATOMIC_MOVE 保证文件移动的原子性</li></ul><p>删除文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Path</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">&quot;helloword/target.txt&quot;</span>);<br><br>Files.delete(target);<br></code></pre></td></tr></table></figure><ul><li>如果文件不存在，会抛异常 NoSuchFileException</li></ul><p>删除目录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Path</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">&quot;helloword/d1&quot;</span>);<br><br>Files.delete(target);<br></code></pre></td></tr></table></figure><ul><li>如果目录还有内容，会抛异常 DirectoryNotEmptyException</li></ul><p>遍历目录文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">Path</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">&quot;D:\\environment\\jdk8\\jdk1.8.0_91&quot;</span>);<br>    <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">dirCount</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br>    <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">fileCount</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br>    <br>    Files.walkFileTree(path, <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleFileVisitor</span>&lt;Path&gt;()&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> FileVisitResult <span class="hljs-title function_">preVisitDirectory</span><span class="hljs-params">(Path dir, BasicFileAttributes attrs)</span> <br>            <span class="hljs-keyword">throws</span> IOException &#123;<br>            System.out.println(dir);<br>            dirCount.incrementAndGet();<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.preVisitDirectory(dir, attrs);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> FileVisitResult <span class="hljs-title function_">visitFile</span><span class="hljs-params">(Path file, BasicFileAttributes attrs)</span> <br>            <span class="hljs-keyword">throws</span> IOException &#123;<br>            System.out.println(file);<br>            fileCount.incrementAndGet();<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.visitFile(file, attrs);<br>        &#125;<br>    &#125;);<br>    System.out.println(dirCount);<br>    System.out.println(fileCount);<br>&#125;<br></code></pre></td></tr></table></figure><p>统计 jar 的数目</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Path</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">&quot;D:\\environment\\jdk8\\jdk1.8.0_91&quot;</span>);<br><span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">fileCount</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br>Files.walkFileTree(path, <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleFileVisitor</span>&lt;Path&gt;()&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> FileVisitResult <span class="hljs-title function_">visitFile</span><span class="hljs-params">(Path file, BasicFileAttributes attrs)</span> <br>        <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">if</span> (file.toFile().getName().endsWith(<span class="hljs-string">&quot;.jar&quot;</span>)) &#123;<br>            fileCount.incrementAndGet();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.visitFile(file, attrs);<br>    &#125;<br>&#125;);<br>System.out.println(fileCount);<br></code></pre></td></tr></table></figure><p>删除多级目录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Path</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">&quot;d:\\a&quot;</span>);<br>Files.walkFileTree(path, <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleFileVisitor</span>&lt;Path&gt;()&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> FileVisitResult <span class="hljs-title function_">visitFile</span><span class="hljs-params">(Path file, BasicFileAttributes attrs)</span> <br>        <span class="hljs-keyword">throws</span> IOException &#123;<br>        Files.delete(file);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.visitFile(file, attrs);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> FileVisitResult <span class="hljs-title function_">postVisitDirectory</span><span class="hljs-params">(Path dir, IOException exc)</span> <br>        <span class="hljs-keyword">throws</span> IOException &#123;<br>        Files.delete(dir);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.postVisitDirectory(dir, exc);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>拷贝多级目录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br><span class="hljs-type">String</span> <span class="hljs-variable">source</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;D:\\Snipaste-1.16.2-x64&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;D:\\Snipaste-1.16.2-x64aaa&quot;</span>;<br><br>Files.walk(Paths.get(source)).forEach(path -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">targetName</span> <span class="hljs-operator">=</span> path.toString().replace(source, target);<br>        <span class="hljs-comment">// 是目录</span><br>        <span class="hljs-keyword">if</span> (Files.isDirectory(path)) &#123;<br>            Files.createDirectory(Paths.get(targetName));<br>        &#125;<br>        <span class="hljs-comment">// 是普通文件</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Files.isRegularFile(path)) &#123;<br>            Files.copy(path, Paths.get(targetName));<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;);<br><span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>System.out.println(end - start);<br></code></pre></td></tr></table></figure><h2 id="4-Channel-之-TCP-网络编程">4. Channel 之 TCP 网络编程</h2><h3 id="4-1-阻塞-vs-非阻塞">4.1 阻塞 vs 非阻塞</h3><p>首先写一个测试代码来展示什么是阻塞，如下：</p><p>服务端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">16</span>);<br>    <span class="hljs-comment">// 创建服务器</span><br>    <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">ssc</span> <span class="hljs-operator">=</span> ServerSocketChannel.open();<br>    <span class="hljs-comment">// 绑定监听端口</span><br>    ssc.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">8080</span>));<br>    <span class="hljs-comment">// 连接集合</span><br>    List&lt;SocketChannel&gt; channels = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        log.debug(<span class="hljs-string">&quot;connecting&quot;</span>);<br>        <span class="hljs-comment">// accept 方法是阻塞方法，导致线程阻塞</span><br>        <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> ssc.accept();<br>        log.debug(<span class="hljs-string">&quot;connected, &#123;&#125;&quot;</span>, sc);<br>        channels.add(sc);<br>        <span class="hljs-keyword">for</span> (SocketChannel channel : channels) &#123;<br>            log.debug(<span class="hljs-string">&quot;before read &#123;&#125;&quot;</span>, channel);<br>            <span class="hljs-comment">// read 方法是阻塞方法，导致线程阻塞</span><br>            channel.read(buf);<br>            buf.flip();<br>            debugAll(buf);<br>            buf.clear();<br>            log.debug(<span class="hljs-string">&quot;after read &#123;&#125;&quot;</span>, channel);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> SocketChannel.open();<br>    sc.connect(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>));<br>    System.out.println(<span class="hljs-string">&quot;waiting...&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>你可以运行上面的服务端和客户端的代码，自行体会阻塞的含义。</p><p>在阻塞模式下，相关的方法如，accept、read 都会导致线程暂停，不会占用 CPU 资源，在单线程模式下（如上面的代码运行），阻塞方法之间几乎不能正常工作，需要多线程的支持。</p><p>但还是像之前说的，多线程下，有新的问题，体现在以下方面</p><ul><li>32 位 jvm 一个线程 320k，64 位 jvm 一个线程 1024k，如果连接数过多，必然导致 OOM，并且线程太多，反而会因为频繁上下文切换导致性能降低。</li><li>可以采用线程池技术来减少线程数和线程上下文切换，但治标不治本，如果有很多连接建立，但长时间 inactive，会阻塞线程池中所有线程，因此不适合长连接，只适合短连接。</li></ul><p>那如果我们将上面的例子改为非阻塞呢，如下：</p><p>服务端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">16</span>);<br>    <span class="hljs-comment">// 创建了服务器</span><br>    <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">ssc</span> <span class="hljs-operator">=</span> ServerSocketChannel.open();<br>    <span class="hljs-comment">// 设置为非阻塞模式</span><br>    ssc.configureBlocking(<span class="hljs-literal">false</span>);<br>    <span class="hljs-comment">// 绑定监听端口</span><br>    ssc.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">8080</span>));<br>    <span class="hljs-comment">// 连接集合</span><br>    List&lt;SocketChannel&gt; channels = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-comment">// 非阻塞，线程还会继续运行，如果没有连接建立，则 sc 为 null</span><br>        <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> ssc.accept();<br>        <span class="hljs-keyword">if</span> (sc != <span class="hljs-literal">null</span>) &#123;<br>            log.debug(<span class="hljs-string">&quot;connected... &#123;&#125;&quot;</span>, sc);<br>            <span class="hljs-comment">// 设置为非阻塞模式</span><br>            sc.configureBlocking(<span class="hljs-literal">false</span>);<br>            channels.add(sc);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (SocketChannel channel : channels) &#123;<br>            <span class="hljs-comment">// 非阻塞，线程仍然会继续运行，如果没有读到数据，则 read 返回 0</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">read</span> <span class="hljs-operator">=</span> channel.read(buffer);<br>            <span class="hljs-keyword">if</span> (read &gt; <span class="hljs-number">0</span>) &#123;<br>                buffer.flip();<br>                debugAll(buffer);<br>                buffer.clear();<br>                log.debug(<span class="hljs-string">&quot;after read...&#123;&#125;&quot;</span>, channel);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端代码不变，我们运行会发现，好像已经可以正常工作了，但是由于是非阻塞方法，那么线程在不断地运行，CPU 占用率飙升。</p><p>所以在非阻塞模式下，相关方法不会让线程暂停</p><ul><li>在 ServerSocketChannel.accept 在没有连接建立时，会返回 null，继续运行</li><li>在 SocketChannel.read 在没有数据可读时，会返回 0，但线程不必阻塞，可以去执行其它 SocketChannel 的 read 或是去执行 ServerSocketChannel.accept</li><li>写数据时，线程只是等待数据写入 Channel 即可，无需等 Channel 通过网络把数据发送出去</li></ul><p>但非阻塞模式下，即使没有连接建立或者没有可读数据，线程仍然不断运行，白白浪费了 CPU，而在数据复制过程中，线程实际还是阻塞的。</p><h3 id="4-2-Selector">4.2 Selector</h3><p>单线程配合 Selector 完成对多个 Channel 可读写事件的监控，这称之为 <strong>多路复用</strong>。</p><ul><li>多路复用仅针对网络 IO、普通文件 IO 无法利用多路复用</li><li>如果不使用 Selector 的非阻塞模式，线程大部分时间都在做无用功，而一旦使用 Selector 的非阻塞模式，那么 Selector 能够保证<ul><li>有可连接事件时才去连接</li><li>有可读事件才去读取</li><li>有可写事件才去写入，限于网络传输能力，Channel 未必时时可写，一旦 Channel 可写，会触发 Selector 的可写事件</li></ul></li></ul><p><img src="/java/javase-beb1cfdacc32/image-20240114213101046.png" alt="selector"></p><p>好处</p><ul><li>单线程配合 Selector 可以监控多个 Channel 的事件，事件发生线程才去处理。避免非阻塞模式下线程做无用功，白白浪费 CPU 资源</li><li>线程能够被充分利用</li><li>节约了线程的数量</li><li>减少了线程上下文切换</li></ul><h4 id="创建">创建</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Selector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> Selector.open();<br></code></pre></td></tr></table></figure><h4 id="绑定-Channel-事件">绑定 Channel 事件</h4><p>也称之为注册事件，绑定的事件 Selector 才会关心</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">channel.configureBlocking(<span class="hljs-literal">false</span>);<br><span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> channel.register(selector, 绑定事件);<br></code></pre></td></tr></table></figure><ul><li>channel 必须工作在非阻塞模式，而 FileChannel 没有非阻塞模式，因此不能配合 selector 一起使用</li><li>绑定的事件类型可以有<ul><li>connect 事件，客户端连接成功时触发</li><li>accept 事件，服务器端成功接受连接时触发</li><li>read 事件，数据可读入时触发，有因为接收能力弱，数据暂不能读入的情况</li><li>write 事件，数据可写出时触发，有因为发送能力弱，数据暂不能写出的情况</li></ul></li></ul><h4 id="监听-Channel-事件">监听 Channel 事件</h4><p>可以通过下面三种方法来监听是否有事件发生，方法的返回值代表有多少 channel 发生了事件</p><p>方法 1，阻塞直到绑定事件发生</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> selector.select();<br></code></pre></td></tr></table></figure><p>方法 2，阻塞直到绑定事件发生，或是超时（时间单位为 ms）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> selector.select(<span class="hljs-type">long</span> timeout);<br></code></pre></td></tr></table></figure><p>方法 3，不会阻塞，也就是不管有没有事件，立刻返回，自己根据返回值检查是否有事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> selector.selectNow();<br></code></pre></td></tr></table></figure><h4 id="Select-何时不阻塞">Select 何时不阻塞</h4><ul><li>事件发生时<ul><li>客户端发起连接请求，会触发 accept 事件</li><li>客户端发送数据过来，客户端正常、异常关闭时，都会触发 read 事件，另外如果发送的数据大于 buffer 缓冲区，会触发多次读取事件</li><li>channel 可写，会触发 write 事件</li><li>在 linux 下 nio bug 发生时</li></ul></li><li>调用 selector.wakeup()，wakeup 方法类似于 LockSupport.unpark() 方法，可以提前给信号量。</li><li>调用 selector.close()</li><li>selector 所在线程 interrupt</li></ul><h3 id="4-3-处理-accept-事件">4.3 处理 accept 事件</h3><h4 id="注意">注意</h4><ol><li>事件发生之后，要么取消（key.cancel），要么处理，不能什么都不做，否则下次该事件仍会触发，这是因为 Nio 底层使用的是水平触发。</li><li>在处理完事件后，必须将该事件的 key 从 selectionKeys 中删除，由于是在遍历过程中删除，需要使用 iterator 迭代器遍历。</li></ol><h4 id="cancel-的作用">cancel 的作用</h4><p>cancel 会取消注册在 selector 上的 channel，并从 keys 集合中删除 key，后续不会再监听事件。</p><h4 id="示例">示例</h4><p>服务端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">ssc</span> <span class="hljs-operator">=</span> ServerSocketChannel.open()) &#123;<br>        <span class="hljs-comment">// 绑定端口</span><br>        ssc.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">8080</span>));<br>        <span class="hljs-comment">// 创建 Selector</span><br>        <span class="hljs-type">Selector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> Selector.open();<br>        <span class="hljs-comment">// 设置为非阻塞模式</span><br>        ssc.configureBlocking(<span class="hljs-literal">false</span>);<br>        <span class="hljs-comment">// 将 ssc 注册到 selector 并关注可连接事件</span><br>        ssc.register(selector, SelectionKey.OP_ACCEPT);<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">// 阻塞直到监听的事件发生</span><br>            selector.select();<br>            <span class="hljs-comment">// 获取所有事件</span><br>            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();<br>            <span class="hljs-comment">// 遍历所有事件</span><br>            Iterator&lt;SelectionKey&gt; iter = selectionKeys.iterator();<br>            <span class="hljs-keyword">while</span> (iter.hasNext()) &#123;<br>                <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> iter.next();<br>                <span class="hljs-comment">// 判断是否是可连接事件</span><br>                <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;<br>                    <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> (ServerSocketChannel) key.channel();<br>                    <span class="hljs-comment">// 必须处理</span><br>                    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> c.accept();<br>                &#125;<br>                <span class="hljs-comment">// 处理完事件后，必须将事件移除</span><br>                iter.remove();<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> SocketChannel.open();<br>    sc.connect(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>));<br>    System.out.println(<span class="hljs-string">&quot;waiting...&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-4-处理-read-事件">4.4 处理 read 事件</h3><h4 id="为什么要删除事件的-key">为什么要删除事件的 key</h4><p>参考下面的代码，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">ssc</span> <span class="hljs-operator">=</span> ServerSocketChannel.open()) &#123;<br>        <span class="hljs-comment">// 绑定端口</span><br>        ssc.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">8080</span>));<br>        <span class="hljs-comment">// 创建 Selector</span><br>        <span class="hljs-type">Selector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> Selector.open();<br>        <span class="hljs-comment">// 设置为非阻塞模式</span><br>        ssc.configureBlocking(<span class="hljs-literal">false</span>);<br>        <span class="hljs-comment">// 将 ssc 注册到 selector 并关注可连接事件</span><br>        ssc.register(selector, SelectionKey.OP_ACCEPT);<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">// 阻塞直到监听的事件发生</span><br>            selector.select();<br>            <span class="hljs-comment">// 获取所有事件</span><br>            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();<br>            <span class="hljs-comment">// 遍历所有事件</span><br>            Iterator&lt;SelectionKey&gt; iter = selectionKeys.iterator();<br>            <span class="hljs-keyword">while</span> (iter.hasNext()) &#123;<br>                <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> iter.next();<br>                <span class="hljs-comment">// 判断是否是可连接事件</span><br>                <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;<br>                    <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> (ServerSocketChannel) key.channel();<br>                    <span class="hljs-comment">// 必须处理</span><br>                    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> c.accept();<br>                    <span class="hljs-comment">// 设置为非阻塞模式</span><br>                    sc.configureBlocking(<span class="hljs-literal">false</span>);<br>                    <span class="hljs-comment">// 将 sc 注册到 selector 并关注可读事件</span><br>                    sc.register(selector, SelectionKey.OP_READ);<br>                    log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, sc);<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isReadable()) &#123;<br>                    <span class="hljs-comment">// 判断是可读事件</span><br>                    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> (SocketChannel) key.channel();<br>                    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">16</span>);<br>                    c.read(buf);<br>                    buf.flip();<br>                    debugAll(buf);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果不删除处理完事件的 key，那么一旦客户端连接到服务端，并发送一个消息，运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">+--------+-------------------- all ------------------------+----------------+<br>position: [<span class="hljs-number">0</span>], limit: [<span class="hljs-number">2</span>]<br>         +-------------------------------------------------+<br>         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|<span class="hljs-number">00000000</span>| <span class="hljs-number">68</span> <span class="hljs-number">69</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> |hi..............|<br>+--------+-------------------------------------------------+----------------+<br>Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.NullPointerException<br>at cn.ocsio.Server.main(Server.java:<span class="hljs-number">45</span>)<br></code></pre></td></tr></table></figure><p>你可以看到，报了空指针异常。这是怎么回事呢？</p><p>我们来慢慢分析，当执行到 <code>ssc.register(selector, SelectionKey.OP_ACCEPT)</code> 时，会将该 ssckey 加入到一个 keys 集合，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> SelectionKey <span class="hljs-title function_">register</span><span class="hljs-params">(Selector sel, <span class="hljs-type">int</span> ops, Object att)</span> <span class="hljs-keyword">throws</span> ClosedChannelException &#123;<br>    <span class="hljs-keyword">synchronized</span> (regLock) &#123;<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> findKey(sel);<br>        <span class="hljs-keyword">if</span> (k != <span class="hljs-literal">null</span>) &#123;<br>            k.interestOps(ops);<br>            k.attach(att);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// New registration</span><br>            <span class="hljs-keyword">synchronized</span> (keyLock) &#123;<br>                <span class="hljs-comment">// ...</span><br>                k = ((AbstractSelector)sel).register(<span class="hljs-built_in">this</span>, ops, att);<br>                <span class="hljs-comment">// ssc 第一次注册到 Selector，所以进入下面的 addKey 方法</span><br>                <span class="hljs-comment">// 就是将 k 加入到一个 keys 的 SelectionKey 数组中</span><br>                addKey(k);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> k;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着 <code>selector.select()</code>，线程阻塞直到监听的事件发生，假设此时客户端连接到服务端，那么会将发生了事件的 key 即 sscKey 加入到另一个集合 selectedKeys 中，所以后续我们才可以遍历这个集合处理事件，但是这个集合有一个毛病，它只会主动添加而不会主动移除。</p><p>当第一次遍历该 selectedKeys 集合处理完客户端的连接事件后，并没有移除集合中 sscKey，那么当进入下一次循环，又会处理该 sscKey，但是此时已经没有客户端的连接事件了，那么调用 <code>c.accept()</code> 返回的是 null，而后续 <code>null.configureBlocking</code> 自然报空指针了。</p><p>我再用一个动图解释一下：</p><p><img src="/java/javase-beb1cfdacc32/image-20240114213101047.gif" alt="删除事件 Key"></p><h4 id="处理客户端的断开">处理客户端的断开</h4><p>对于客户端来说，可能是异常断开，也可能是调用 sc.close 方法正常断开，而不管是正常断开，还是异常断开，都会触发 sc 的可读事件，所以我们的服务器必须要对这两种情况做出处理。</p><ul><li>异常断开：我们在 catch 块中取消 key 即可。</li><li>正常断开：客户端会触发一次读事件，并且 read 方法返回 -1，所以我们根据这个来判断，并取消 key 即可。</li></ul><p>一旦取消了 key，那么该 key 就会从 keys 集合中移除，那么 Selector 就不会在监听该客户端连接了。</p><p>代码改进如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">ssc</span> <span class="hljs-operator">=</span> ServerSocketChannel.open()) &#123;<br>        <span class="hljs-comment">// 绑定端口</span><br>        ssc.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">8080</span>));<br>        <span class="hljs-comment">// 创建 Selector</span><br>        <span class="hljs-type">Selector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> Selector.open();<br>        <span class="hljs-comment">// 设置为非阻塞模式</span><br>        ssc.configureBlocking(<span class="hljs-literal">false</span>);<br>        <span class="hljs-comment">// 将 ssc 注册到 selector 并关注可连接事件</span><br>        ssc.register(selector, SelectionKey.OP_ACCEPT);<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">// 阻塞直到监听的事件发生</span><br>            selector.select();<br>            <span class="hljs-comment">// 获取所有事件</span><br>            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();<br>            <span class="hljs-comment">// 遍历所有事件</span><br>            Iterator&lt;SelectionKey&gt; iter = selectionKeys.iterator();<br>            <span class="hljs-keyword">while</span> (iter.hasNext()) &#123;<br>                <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> iter.next();<br>                <span class="hljs-comment">// 判断是否是可连接事件</span><br>                <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;<br>                    <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> (ServerSocketChannel) key.channel();<br>                    <span class="hljs-comment">// 必须处理</span><br>                    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> c.accept();<br>                    <span class="hljs-comment">// 设置为非阻塞模式</span><br>                    sc.configureBlocking(<span class="hljs-literal">false</span>);<br>                    <span class="hljs-comment">// 将 sc 注册到 selector 并关注可读事件</span><br>                    sc.register(selector, SelectionKey.OP_READ);<br>                    log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, sc);<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isReadable()) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-comment">// 判断是可读事件</span><br>                        <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> (SocketChannel) key.channel();<br>                        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">16</span>);<br>                        <span class="hljs-type">int</span> <span class="hljs-variable">read</span> <span class="hljs-operator">=</span> c.read(buf);<br>                        <span class="hljs-comment">// 处理客户端正常断开</span><br>                        <span class="hljs-keyword">if</span> (read == -<span class="hljs-number">1</span>) &#123;<br>                            key.cancel();<br>                        &#125; <span class="hljs-keyword">else</span> &#123;<br>                            buf.flip();<br>                            debugAll(buf);<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                        e.printStackTrace();<br>                        <span class="hljs-comment">// 处理客户端异常断开</span><br>                        key.cancel();<br>                    &#125;<br>                &#125;<br>                <span class="hljs-comment">// 处理完事件后，必须将事件移除</span><br>                iter.remove();<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> SocketChannel.open();<br>    sc.connect(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>));<br>    System.out.println(<span class="hljs-string">&quot;waiting...&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="消息边界问题">消息边界问题</h4><p>参考下面的代码：</p><p>服务端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">ssc</span> <span class="hljs-operator">=</span> ServerSocketChannel.open()) &#123;<br>        <span class="hljs-comment">// 绑定端口</span><br>        ssc.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">8080</span>));<br>        <span class="hljs-comment">// 创建 Selector</span><br>        <span class="hljs-type">Selector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> Selector.open();<br>        <span class="hljs-comment">// 设置为非阻塞模式</span><br>        ssc.configureBlocking(<span class="hljs-literal">false</span>);<br>        <span class="hljs-comment">// 将 ssc 注册到 selector 并关注可连接事件</span><br>        ssc.register(selector, SelectionKey.OP_ACCEPT);<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">// 阻塞直到监听的事件发生</span><br>            selector.select();<br>            <span class="hljs-comment">// 获取所有事件</span><br>            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();<br>            <span class="hljs-comment">// 遍历所有事件</span><br>            Iterator&lt;SelectionKey&gt; iter = selectionKeys.iterator();<br>            <span class="hljs-keyword">while</span> (iter.hasNext()) &#123;<br>                <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> iter.next();<br>                <span class="hljs-comment">// 判断是否是可连接事件</span><br>                <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;<br>                    <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> (ServerSocketChannel) key.channel();<br>                    <span class="hljs-comment">// 必须处理</span><br>                    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> c.accept();<br>                    <span class="hljs-comment">// 设置为非阻塞模式</span><br>                    sc.configureBlocking(<span class="hljs-literal">false</span>);<br>                    <span class="hljs-comment">// 将 sc 注册到 selector 并关注可读事件</span><br>                    sc.register(selector, SelectionKey.OP_READ);<br>                    log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, sc);<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isReadable()) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-comment">// 判断是可读事件</span><br>                        <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> (SocketChannel) key.channel();<br>                        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">4</span>);<br>                        <span class="hljs-type">int</span> <span class="hljs-variable">read</span> <span class="hljs-operator">=</span> c.read(buf);<br>                        <span class="hljs-comment">// 处理客户端正常断开</span><br>                        <span class="hljs-keyword">if</span> (read == -<span class="hljs-number">1</span>) &#123;<br>                            key.cancel();<br>                        &#125; <span class="hljs-keyword">else</span> &#123;<br>                            buf.flip();<br>                            <span class="hljs-type">CharBuffer</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> StandardCharsets.UTF_8.decode(buf);<br>                            System.out.println(str);<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                        e.printStackTrace();<br>                        <span class="hljs-comment">// 处理客户端异常断开</span><br>                        key.cancel();<br>                    &#125;<br>                &#125;<br>                <span class="hljs-comment">// 处理完事件后，必须将事件移除</span><br>                iter.remove();<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> SocketChannel.open();<br>    sc.connect(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>));<br>    sc.write(Charsets.UTF_8.encode(<span class="hljs-string">&quot;hello&quot;</span>));<br>    sc.write(Charsets.UTF_8.encode(<span class="hljs-string">&quot;world&quot;</span>));<br>    sc.write(Charsets.UTF_8.encode(<span class="hljs-string">&quot;你好&quot;</span>));<br>    System.in.read();<br>&#125;<br></code></pre></td></tr></table></figure><p>你会发现输出的结果是这样的，出现了乱码，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">hell<br>owor<br>ld�<br>�好<br></code></pre></td></tr></table></figure><p>事实上，由于我们的 buffer 缓冲区只有 4 个字节，而对于汉字的 UTF-8 编码，一个汉字占 3 个字节，所以一个 buffer 显然无法存储 “你好” 这两个汉字，所以会将第二个汉字拆开，就出现了上面的乱码现象。</p><p>如何处理？几种方案：</p><ul><li>一种思路是固定消息长度，数据包大小一样，服务器按预定长度读取，缺点是浪费带宽</li><li>另一种思路是按分隔符，如 \n 进行拆分，缺点是效率低</li><li>TLV 格式，即 Type 类型、Length 长度、Value 数据，类型和长度已知的情况下，就可以方便获取消息大小，分配合适的 buffer，缺点是 buffer 需要提前分配，如果内容过大，则影响 server 吞吐量<ul><li>Http 1.1 是 TLV 格式</li><li>Http 2.0 是 LTV 格式</li></ul></li></ul><p>下面我们按分隔符拆分，来解决黏包半包问题。</p><p>在 Channel 注册到 Selector 上时，除了指定是哪一个 Selector，关注的事件类型，还可以关联一个附件 attachment。</p><p>服务端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">split</span><span class="hljs-params">(ByteBuffer source)</span> &#123;<br>    source.flip();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; source.limit(); i++) &#123;<br>        <span class="hljs-comment">// 找到一条完整消息</span><br>        <span class="hljs-keyword">if</span> (source.get(i) == <span class="hljs-string">&#x27;\n&#x27;</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span> - source.position();<br>            <span class="hljs-comment">// 把这条完整消息存入新的 ByteBuffer</span><br>            <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(length);<br>            <span class="hljs-comment">// 从 source 读，向 target 写</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; length; j++) &#123;<br>                target.put(source.get());<br>            &#125;<br>            target.flip();<br>            <span class="hljs-type">CharBuffer</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> Charsets.UTF_8.decode(target);<br>            System.out.print(str);<br>        &#125;<br>    &#125;<br>    source.compact();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">Selector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> Selector.open();<br>    <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">ssc</span> <span class="hljs-operator">=</span> ServerSocketChannel.open();<br>    ssc.configureBlocking(<span class="hljs-literal">false</span>);<br>    ssc.register(selector, SelectionKey.OP_ACCEPT, <span class="hljs-literal">null</span>);<br>    ssc.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">8080</span>));<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        selector.select();<br>        Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();<br>        <span class="hljs-keyword">while</span> (iter.hasNext()) &#123;<br>            <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> iter.next();<br>            <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;<br>                <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> (ServerSocketChannel) key.channel();<br>                <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> channel.accept();<br>                sc.configureBlocking(<span class="hljs-literal">false</span>);<br>                <span class="hljs-comment">// attachment</span><br>                <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">16</span>);<br>                <span class="hljs-comment">// 将一个 byteBuffer 作为附件关联到 selectionKey 上</span><br>                sc.register(selector, SelectionKey.OP_READ, buffer);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isReadable()) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> (SocketChannel) key.channel();<br>                    <span class="hljs-comment">// 获取 selectionKey 上关联的附件</span><br>                    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> (ByteBuffer) key.attachment();<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">read</span> <span class="hljs-operator">=</span> channel.read(buffer);<br>                    <span class="hljs-keyword">if</span> (read == -<span class="hljs-number">1</span>) &#123;<br>                        key.cancel();<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        split(buffer);<br>                        <span class="hljs-comment">// 需要扩容</span><br>                        <span class="hljs-keyword">if</span> (buffer.position() == buffer.limit()) &#123;<br>                            <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">newBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(buffer.capacity() * <span class="hljs-number">2</span>);<br>                            buffer.flip();<br>                            newBuffer.put(buffer);<br>                            key.attach(newBuffer);<br>                        &#125;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                    key.cancel();<br>                &#125;<br>            &#125;<br>            iter.remove();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> SocketChannel.open();<br>    sc.connect(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>));<br>    sc.write(Charsets.UTF_8.encode(<span class="hljs-string">&quot;hello\n&quot;</span>));<br>    sc.write(Charsets.UTF_8.encode(<span class="hljs-string">&quot;world\n&quot;</span>));<br>    sc.write(Charsets.UTF_8.encode(<span class="hljs-string">&quot;你好\n&quot;</span>));<br>    System.in.read();<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">hello<br>world<br>你好<br></code></pre></td></tr></table></figure><h4 id="ByteBuffer-大小分配">ByteBuffer 大小分配</h4><ul><li>每个 channel 都需要记录可能被切分的消息，因为 ByteBuffer 不能被多个 channel 共同使用，否则会出现消息错乱，因此需要为每个 channel 维护一个独立的 ByteBuffer。</li><li>ByteBuffer 不能太大，比如一个 ByteBuffer 1Mb 的话，要支持百万连接就要 1Tb 内存，因此需要设计大小可变的 ByteBuffer<ul><li>一种思路是首先分配一个较小的 buffer，例如 4k，如果发现数据不够，再分配 8k 的 buffer，将 4k buffer 内容拷贝至 8k buffer，优点是消息连续容易处理，缺点是数据拷贝耗费性能。</li><li>另一种思路是用多个数组组成 buffer，一个数组不够，把多出来的内容写入新的数组，与前面的区别是消息存储不连续解析复杂，优点是避免了拷贝引起的性能损耗。</li></ul></li></ul><h3 id="4-5-处理-write-事件">4.5 处理 write 事件</h3><h4 id="一次无法写完例子">一次无法写完例子</h4><p>参照下面的代码：</p><p>服务端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">ssc</span> <span class="hljs-operator">=</span> ServerSocketChannel.open();<br>    ssc.configureBlocking(<span class="hljs-literal">false</span>);<br>    <span class="hljs-type">Selector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> Selector.open();<br>    ssc.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">8080</span>));<br>    ssc.register(selector, SelectionKey.OP_ACCEPT);<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        selector.select();<br>        Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();<br>        <span class="hljs-keyword">while</span> (iter.hasNext()) &#123;<br>            <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> iter.next();<br>            <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;<br>                <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> ssc.accept();<br>                sc.configureBlocking(<span class="hljs-literal">false</span>);<br>                sc.register(selector, SelectionKey.OP_READ);<br><br>                <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">30000000</span>; i++) &#123;<br>                    sb.append(<span class="hljs-string">&quot;a&quot;</span>);<br>                &#125;<br>                <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> Charset.defaultCharset().encode(sb.toString());<br>                <span class="hljs-keyword">while</span> (buf.hasRemaining()) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">write</span> <span class="hljs-operator">=</span> sc.write(buf);<br>                    System.out.println(write);<br>                &#125;<br>            &#125;<br>            iter.remove();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> SocketChannel.open();<br>    <span class="hljs-type">Selector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> Selector.open();<br>    sc.configureBlocking(<span class="hljs-literal">false</span>);<br>    sc.register(selector, SelectionKey.OP_CONNECT | SelectionKey.OP_READ);<br>    sc.connect(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>));<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        selector.select();<br>        Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();<br>        <span class="hljs-keyword">while</span> (iter.hasNext()) &#123;<br>            <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> iter.next();<br>            <span class="hljs-keyword">if</span> (key.isConnectable()) &#123;<br>                System.out.println(sc.finishConnect());<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isReadable()) &#123;<br>                <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>);<br>                count += sc.read(buf);<br>                buf.clear();<br>                System.out.println(count);<br>            &#125;<br>            iter.remove();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>服务端输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">3538917</span><br><span class="hljs-number">2490349</span><br><span class="hljs-number">3669988</span><br><span class="hljs-number">4194272</span><br><span class="hljs-number">0</span><br><span class="hljs-number">0</span><br><span class="hljs-number">2228207</span><br><span class="hljs-number">1966065</span><br><span class="hljs-number">0</span><br><span class="hljs-number">0</span><br><span class="hljs-number">11912202</span><br></code></pre></td></tr></table></figure><p>由于网络缓冲区有限，服务端无法一次性将这 30000000 个字节数据发给客户端，而输出结果出现 0 表示网络缓冲区满了，已经写不了了，所以又会不断地循环发送。</p><p>但这其实违背了非阻塞的初衷，我们希望的是当缓冲区满了，此时线程可以干其他的事，当可以写数据了，线程再来写，这就需要我们关注写事件了。</p><p>所以我们将代码改进如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">ssc</span> <span class="hljs-operator">=</span> ServerSocketChannel.open();<br>    ssc.configureBlocking(<span class="hljs-literal">false</span>);<br>    <span class="hljs-type">Selector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> Selector.open();<br>    ssc.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">8080</span>));<br>    ssc.register(selector, SelectionKey.OP_ACCEPT);<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        selector.select();<br>        Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();<br>        <span class="hljs-keyword">while</span> (iter.hasNext()) &#123;<br>            <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> iter.next();<br>            <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;<br>                <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> ssc.accept();<br>                sc.configureBlocking(<span class="hljs-literal">false</span>);<br>                <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">scKey</span> <span class="hljs-operator">=</span> sc.register(selector, SelectionKey.OP_READ);<br><br>                <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">30000000</span>; i++) &#123;<br>                    sb.append(<span class="hljs-string">&quot;a&quot;</span>);<br>                &#125;<br>                <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> Charset.defaultCharset().encode(sb.toString());<br>                <span class="hljs-type">int</span> <span class="hljs-variable">write</span> <span class="hljs-operator">=</span> sc.write(buf);<br>                System.out.println(<span class="hljs-string">&quot;实际写入的字节数：&quot;</span> + write);<br>                <span class="hljs-comment">// 如果有剩余字节未写完则关注写事件</span><br>                <span class="hljs-keyword">if</span> (buf.hasRemaining()) &#123;<br>                    <span class="hljs-comment">// 在原有事件的基础关注写事件</span><br>                    scKey.interestOps(scKey.interestOps() | SelectionKey.OP_WRITE);<br>                    scKey.attach(buf);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isWritable()) &#123;<br>                <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> (ByteBuffer) key.attachment();<br>                <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> (SocketChannel) key.channel();<br>                <span class="hljs-type">int</span> <span class="hljs-variable">write</span> <span class="hljs-operator">=</span> sc.write(buf);<br>                System.out.println(<span class="hljs-string">&quot;实际写入的字节数：&quot;</span> + write);<br>                <span class="hljs-comment">// 已经写完了</span><br>                <span class="hljs-keyword">if</span> (!buf.hasRemaining()) &#123;<br>                    key.interestOps(key.interestOps() - SelectionKey.OP_WRITE);<br>                    key.attach(<span class="hljs-literal">null</span>);<br>                &#125;<br>            &#125;<br>            iter.remove();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端不变。</p><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">实际写入的字节数：<span class="hljs-number">4587485</span><br>实际写入的字节数：<span class="hljs-number">2490349</span><br>实际写入的字节数：<span class="hljs-number">3669988</span><br>实际写入的字节数：<span class="hljs-number">6422479</span><br>实际写入的字节数：<span class="hljs-number">1966065</span><br>实际写入的字节数：<span class="hljs-number">2228207</span><br>实际写入的字节数：<span class="hljs-number">2097136</span><br>实际写入的字节数：<span class="hljs-number">131071</span><br>实际写入的字节数：<span class="hljs-number">1966065</span><br>实际写入的字节数：<span class="hljs-number">4325343</span><br>实际写入的字节数：<span class="hljs-number">115812</span><br></code></pre></td></tr></table></figure><p>所以，在非阻塞模式下，无法保证将 buffer 中所有数据都写入 channel，因此需要追踪 write 方法的返回值（代表实际写入字节数），并用 selector 监听所有 channel 的可写事件，每个 channel 都需要一个 key 来跟踪 buffer，但这样又会导致占用内存过多，就有两阶段策略：</p><ul><li>当消息处理器第一次写入消息时，才将 channel 注册到 selector 上</li><li>selector 检查 channel 上的可写事件，如果所有的数据写完了，就取消 channel 的注册</li><li>如果不取消，会每次可写均会触发 write 事件</li></ul><h4 id="write-为何要取消">write 为何要取消</h4><p>只要向 channel 发送数据时，socket 缓冲可写，这个事件会频繁触发，因此应当只在 socket 缓冲区写不下时再关注可写事件，数据写完之后再取消关注。</p><h3 id="4-6-多线程优化">4.6 多线程优化</h3><p>现代计算机，都是多核 CPU，所以我们在设计时需要充分压榨 CPU 的资源。</p><p>前面的代码都只有一个选择器 Selector，并没有充分利用多核 CPU，如何改进？我们可以做：分为两组选择器</p><ul><li>单线程配一个选择器，专门处理 accept 事件。</li><li>创建适当数量的线程，每个线程配一个选择器，轮流处理其他 IO 事件。</li></ul><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MultipleServer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">BossEventLoop</span>().register();<br>    &#125;<br><br>    <span class="hljs-meta">@Slf4j</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BossEventLoop</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br>        <span class="hljs-keyword">private</span> Selector boss;<br>        <span class="hljs-keyword">private</span> WorkerEventLoop[] workers;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>            <span class="hljs-keyword">if</span> (!start) &#123;<br>                <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">ssc</span> <span class="hljs-operator">=</span> ServerSocketChannel.open();<br>                ssc.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">8080</span>));<br>                ssc.configureBlocking(<span class="hljs-literal">false</span>);<br>                boss = Selector.open();<br>                ssc.register(boss, SelectionKey.OP_ACCEPT);<br>                workers = initEventLoops();<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-built_in">this</span>, <span class="hljs-string">&quot;boss&quot;</span>).start();<br>                log.debug(<span class="hljs-string">&quot;boss start...&quot;</span>);<br>                start = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> WorkerEventLoop[] initEventLoops() &#123;<br>            WorkerEventLoop[] workerEventLoops = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WorkerEventLoop</span>[<span class="hljs-number">2</span>];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; workerEventLoops.length; i++) &#123;<br>                workerEventLoops[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WorkerEventLoop</span>(i);<br>            &#125;<br>            <span class="hljs-keyword">return</span> workerEventLoops;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    boss.select();<br>                    Iterator&lt;SelectionKey&gt; iter = boss.selectedKeys().iterator();<br>                    <span class="hljs-keyword">while</span> (iter.hasNext()) &#123;<br>                        <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> iter.next();<br>                        iter.remove();<br>                        <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;<br>                            <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> ((ServerSocketChannel) key.channel()).accept();<br>                            sc.configureBlocking(<span class="hljs-literal">false</span>);<br>                            log.debug(<span class="hljs-string">&quot;&#123;&#125; connected&quot;</span>, sc.getRemoteAddress());<br>                            workers[index.getAndIncrement() % workers.length].register(sc);<br>                        &#125;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Slf4j</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WorkerEventLoop</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ConcurrentLinkedQueue&lt;Runnable&gt; tasks = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentLinkedQueue</span>&lt;&gt;();<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> index;<br>        <span class="hljs-keyword">private</span> Selector worker;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">WorkerEventLoop</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>            <span class="hljs-built_in">this</span>.index = index;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">(SocketChannel sc)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>            <span class="hljs-keyword">if</span> (!start) &#123;<br>                worker = Selector.open();<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-built_in">this</span>, <span class="hljs-string">&quot;worker-&quot;</span> + index).start();<br>                start = <span class="hljs-literal">true</span>;<br>            &#125;<br>            tasks.add(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    sc.register(worker, SelectionKey.OP_READ);<br>                    worker.selectNow();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;);<br>            worker.wakeup();<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    worker.select();<br>                    <span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> tasks.poll();<br>                    <span class="hljs-keyword">if</span> (task != <span class="hljs-literal">null</span>) &#123;<br>                        task.run();<br>                    &#125;<br>                    Set&lt;SelectionKey&gt; keys = worker.selectedKeys();<br>                    Iterator&lt;SelectionKey&gt; iter = keys.iterator();<br>                    <span class="hljs-keyword">while</span> (iter.hasNext()) &#123;<br>                        <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> iter.next();<br>                        <span class="hljs-keyword">if</span> (key.isReadable()) &#123;<br>                            <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> (SocketChannel) key.channel();<br>                            <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">128</span>);<br>                            <span class="hljs-keyword">try</span> &#123;<br>                                <span class="hljs-type">int</span> <span class="hljs-variable">read</span> <span class="hljs-operator">=</span> sc.read(buffer);<br>                                <span class="hljs-keyword">if</span> (read == -<span class="hljs-number">1</span>) &#123;<br>                                    key.cancel();<br>                                    sc.close();<br>                                &#125; <span class="hljs-keyword">else</span> &#123;<br>                                    buffer.flip();<br>                                    log.debug(<span class="hljs-string">&quot;&#123;&#125; message:&quot;</span>, sc.getRemoteAddress());<br>                                    debugAll(buffer);<br>                                &#125;<br>                            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                                e.printStackTrace();<br>                                key.cancel();<br>                                sc.close();<br>                            &#125;<br>                        &#125;<br>                        iter.remove();<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="如何拿到-CPU-个数">如何拿到 CPU 个数</h4><ul><li>Runtime.getRuntime().availableProcessors() 如果工作在 docker 容器下，因为容器不是物理隔离的，会拿到物理 CPU 个数，而不是容器申请时的个数</li><li>这个问题直到 jdk 10 才修复，使用 jvm 参数 UseContainerSupport 配置， 默认开启</li></ul><h2 id="5-Channel-之-UDP-网络编程">5. Channel 之 UDP 网络编程</h2><ul><li>UDP 是无连接的，client 发送数据不会管 server 是否开启</li><li>server 这边的 receive 方法会将接收到的数据存入 byte buffer，但如果数据报文超过 buffer 大小，多出来的数据会被抛弃</li></ul><p>示例：</p><p>服务器端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UdpServer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">DatagramChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> DatagramChannel.open()) &#123;<br>            channel.socket().bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">9999</span>));<br>            System.out.println(<span class="hljs-string">&quot;waiting...&quot;</span>);<br>            <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">32</span>);<br>            channel.receive(buffer);<br>            buffer.flip();<br>            debugAll(buffer);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UdpClient</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">DatagramChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> DatagramChannel.open()) &#123;<br>            <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> StandardCharsets.UTF_8.encode(<span class="hljs-string">&quot;hello&quot;</span>);<br>            <span class="hljs-type">InetSocketAddress</span> <span class="hljs-variable">address</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">9999</span>);<br>            channel.send(buffer, address);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>服务器端输出</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">waiting<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 68 65 6c 6c 6f                                  |hello           |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br></code></pre></td></tr></table></figure><h2 id="6-Nio-vs-Bio">6. Nio vs Bio</h2><h3 id="6-1-stream-vs-channel">6.1 stream vs channel</h3><ul><li>stream 不会自动缓冲数据，channel 会利用系统提供的发送缓冲区、接收缓冲区（更为底层）</li><li>stream 仅支持阻塞 API，channel 同时支持阻塞、非阻塞 API，网络 channel 可配合 selector 实现多路复用</li><li>二者均为全双工，即读写可以同时进行</li></ul><h3 id="6-2-IO-模型">6.2 IO 模型</h3><a href="/java/redis-75ba9f9c982a/" title="redis 中的 IO 模型">redis 中的 IO 模型</a><h3 id="6-3-零拷贝">6.3 零拷贝</h3><h4 id="传统-IO-问题">传统 IO 问题</h4><p>传统的 IO 将一个文件通过 socket 写出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">File</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;data.txt&quot;</span>);<br><span class="hljs-type">RandomAccessFile</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomAccessFile</span>(file, <span class="hljs-string">&quot;r&quot;</span>);<br><br><span class="hljs-type">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[(<span class="hljs-type">int</span>)f.length()];<br>file.read(buf);<br><br><span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> ...;<br>socket.getOutputStream().write(buf);<br></code></pre></td></tr></table></figure><p>内部工作流程是这样的：</p><p><img src="/java/javase-beb1cfdacc32/image-20240116164701069.png" alt="传统 IO"></p><ol><li>Java 本身并不具备 IO 读写能力，因此 read 方法调用后，要从 Java 程序的 <strong>用户态</strong> 切换至 <strong>内核态</strong>，去调用操作系统（Kernel）的读能力，将数据读入 <strong>内核缓冲区</strong>。这期间用户线程阻塞，操作系统使用 DMA（Direct Memory Access）来实现文件读，其间也不会使用 CPU，DMA（Direct Memory Access），无需 CPU 干预的数据拷贝。</li><li>从 <strong>内核态</strong> 切换回 <strong>用户态</strong>，将数据从 <strong>内核缓冲区</strong> 读入 <strong>用户缓冲区</strong>（即 byte[] buf），这期间 CPU 会参与拷贝，无法利用 DMA。</li><li>调用 write 方法，这时将数据从 <strong>用户缓冲区</strong>（byte[] buf）写入 <strong>socket 缓冲区</strong>，CPU 会参与拷贝。</li><li>接下来要向网卡写数据，这项能力 Java 又不具备，因此又得从 <strong>用户态</strong> 切换至 <strong>内核态</strong>，调用操作系统的写能力，使用 DMA 将 <strong>socket 缓冲区</strong> 的数据写入网卡，不会使用 CPU。</li></ol><p>可以看到中间环节较多，Java 的 IO 实际不是物理设备级别的读写，而是缓存的复制，底层的真正读写是操作系统来完成的</p><ul><li>用户态与内核态的切换发生了 3 次，这个操作比较重量级</li><li>数据拷贝了共 4 次</li></ul><h4 id="NIO-优化">NIO 优化</h4><p>通过 DirectByteBuf</p><ul><li>ByteBuffer.allocate(10)  HeapByteBuffer 使用的还是 Java 内存</li><li>ByteBuffer.allocateDirect(10)  DirectByteBuffer 使用的是操作系统内存</li></ul><p><img src="/java/javase-beb1cfdacc32/image-20240116165256948.png" alt="DBB"></p><p>大部分步骤与优化前相同，不再赘述。唯有一点：Java 可以使用 DirectByteBuf 将堆外内存映射到 jvm 内存中来直接访问使用</p><ul><li>这块内存不受 jvm 垃圾回收的影响，因此内存地址固定，有助于 IO 读写</li><li>Java 中的 DirectByteBuf 对象仅维护了此内存的虚引用，内存回收分成两步<ul><li>DirectByteBuf 对象被垃圾回收，将虚引用加入引用队列</li><li>通过专门线程访问引用队列，根据虚引用释放堆外内存</li></ul></li><li>减少了一次数据拷贝，用户态与内核态的切换次数没有减少</li></ul><p>进一步优化（底层采用了 linux 2.1 后提供的 sendFile 方法），Java 中对应着两个 channel 调用 transferTo/transferFrom 方法拷贝数据</p><p><img src="/java/javase-beb1cfdacc32/image-20240116165456610.png" alt="sendFile"></p><ol><li>Java 调用 transferTo 方法后，要从 Java 程序的 <strong>用户态</strong> 切换至 <strong>内核态</strong>，使用 DMA 将数据读入 <strong>内核缓冲区</strong>，不会使用 CPU</li><li>数据从 <strong>内核缓冲区</strong>传输到 <strong>socket 缓冲区</strong>，CPU 会参与拷贝</li><li>最后使用 DMA 将 <strong>socket 缓冲区</strong> 的数据写入网卡，不会使用 CPU</li></ol><p>可以看到</p><ul><li>只发生了一次用户态与内核态的切换</li><li>数据拷贝了 3 次</li></ul><p>进一步优化（linux 2.4）</p><p><img src="/java/javase-beb1cfdacc32/image-20240116165602285.png" alt="进一步优化"></p><ol><li>Java 调用 transferTo 方法后，要从 Java 程序的 <strong>用户态</strong> 切换至 <strong>内核态</strong>，使用 DMA 将数据读入 <strong>内核缓冲区</strong>，不会使用 CPU</li><li>只会将一些 offset 和 length 信息拷入 <strong>socket 缓冲区</strong>，几乎无消耗</li><li>使用 DMA 将 <strong>内核缓冲区</strong> 的数据写入网卡，不会使用 CPU</li></ol><p>整个过程仅只发生了一次用户态与内核态的切换，数据拷贝了 2 次。所谓的零拷贝，并不是真正无拷贝，而是在不会拷贝重复数据到 jvm 内存中，零拷贝的优点有</p><ul><li>更少的用户态与内核态的切换</li><li>不利用 CPU 计算，减少 CPU 缓存伪共享</li><li>零拷贝适合小文件传输</li></ul><h3 id="6-3-AIO">6.3 AIO</h3><p>AIO 用来解决数据复制阶段的阻塞问题</p><ul><li>同步意味着，在进行读写操作时，线程需要等待结果，还是相当于闲置</li><li>异步意味着，在进行读写操作时，线程不必等待结果，而是将来由操作系统来通过回调方式由另外的线程来获得结果</li></ul><blockquote><p>异步模型需要底层操作系统（Kernel）提供支持</p><ul><li>Windows 系统通过 IOCP 实现了真正的异步 IO</li><li>Linux 系统异步 IO 在 2.6 版本引入，但其底层实现还是用多路复用模拟了异步 IO，性能没有优势</li></ul></blockquote><h4 id="文件-AIO">文件 AIO</h4><p>先来看看 AsynchronousFileChannel</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AioDemo1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-type">AsynchronousFileChannel</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> AsynchronousFileChannel.open(Paths.get(<span class="hljs-string">&quot;1.txt&quot;</span>), StandardOpenOption.READ);<br>            <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">2</span>);<br>            log.debug(<span class="hljs-string">&quot;begin...&quot;</span>);<br>            s.read(buffer, <span class="hljs-number">0</span>, <span class="hljs-literal">null</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">CompletionHandler</span>&lt;Integer, ByteBuffer&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">completed</span><span class="hljs-params">(Integer result, ByteBuffer attachment)</span> &#123;<br>                    log.debug(<span class="hljs-string">&quot;read completed...&#123;&#125;&quot;</span>, result);<br>                    buffer.flip();<br>                    debugAll(buffer);<br>                &#125;<br><br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">failed</span><span class="hljs-params">(Throwable exc, ByteBuffer attachment)</span> &#123;<br>                    log.debug(<span class="hljs-string">&quot;read failed...&quot;</span>);<br>                &#125;<br>            &#125;);<br><br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        log.debug(<span class="hljs-string">&quot;do other things...&quot;</span>);<br>        System.in.read();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">13:44:56 [DEBUG] [main] c.i.aio.AioDemo1 - begin...<br>13:44:56 [DEBUG] [main] c.i.aio.AioDemo1 - do other things...<br>13:44:56 [DEBUG] [Thread-5] c.i.aio.AioDemo1 - read completed...2<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 61 0d                                           |a.              |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br></code></pre></td></tr></table></figure><p>可以看到</p><ul><li>响应文件读取成功的是另一个线程 Thread-5</li><li>主线程并没有 IO 操作阻塞</li></ul><h4 id="守护线程">守护线程</h4><p>默认文件 AIO 使用的线程都是守护线程，所以最后要执行 <code>System.in.read()</code> 以避免守护线程意外结束</p><h4 id="网络-AIO">网络 AIO</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AioServer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">AsynchronousServerSocketChannel</span> <span class="hljs-variable">ssc</span> <span class="hljs-operator">=</span> AsynchronousServerSocketChannel.open();<br>        ssc.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">8080</span>));<br>        ssc.accept(<span class="hljs-literal">null</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">AcceptHandler</span>(ssc));<br>        System.in.read();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">closeChannel</span><span class="hljs-params">(AsynchronousSocketChannel sc)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.printf(<span class="hljs-string">&quot;[%s] %s close\n&quot;</span>, Thread.currentThread().getName(), sc.getRemoteAddress());<br>            sc.close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReadHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">CompletionHandler</span>&lt;Integer, ByteBuffer&gt; &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AsynchronousSocketChannel sc;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">ReadHandler</span><span class="hljs-params">(AsynchronousSocketChannel sc)</span> &#123;<br>            <span class="hljs-built_in">this</span>.sc = sc;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">completed</span><span class="hljs-params">(Integer result, ByteBuffer attachment)</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (result == -<span class="hljs-number">1</span>) &#123;<br>                    closeChannel(sc);<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                System.out.printf(<span class="hljs-string">&quot;[%s] %s read\n&quot;</span>, Thread.currentThread().getName(), sc.getRemoteAddress());<br>                attachment.flip();<br>                System.out.println(Charset.defaultCharset().decode(attachment));<br>                attachment.clear();<br>                <span class="hljs-comment">// 处理完第一个 read 时，需要再次调用 read 方法来处理下一个 read 事件</span><br>                sc.read(attachment, attachment, <span class="hljs-built_in">this</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">failed</span><span class="hljs-params">(Throwable exc, ByteBuffer attachment)</span> &#123;<br>            closeChannel(sc);<br>            exc.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WriteHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">CompletionHandler</span>&lt;Integer, ByteBuffer&gt; &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AsynchronousSocketChannel sc;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-title function_">WriteHandler</span><span class="hljs-params">(AsynchronousSocketChannel sc)</span> &#123;<br>            <span class="hljs-built_in">this</span>.sc = sc;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">completed</span><span class="hljs-params">(Integer result, ByteBuffer attachment)</span> &#123;<br>            <span class="hljs-comment">// 如果作为附件的 buffer 还有内容，需要再次 write 写出剩余内容</span><br>            <span class="hljs-keyword">if</span> (attachment.hasRemaining()) &#123;<br>                sc.write(attachment);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">failed</span><span class="hljs-params">(Throwable exc, ByteBuffer attachment)</span> &#123;<br>            exc.printStackTrace();<br>            closeChannel(sc);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AcceptHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">CompletionHandler</span>&lt;AsynchronousSocketChannel, Object&gt; &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AsynchronousServerSocketChannel ssc;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">AcceptHandler</span><span class="hljs-params">(AsynchronousServerSocketChannel ssc)</span> &#123;<br>            <span class="hljs-built_in">this</span>.ssc = ssc;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">completed</span><span class="hljs-params">(AsynchronousSocketChannel sc, Object attachment)</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                System.out.printf(<span class="hljs-string">&quot;[%s] %s connected\n&quot;</span>, Thread.currentThread().getName(), sc.getRemoteAddress());<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">16</span>);<br>            <span class="hljs-comment">// 读事件由 ReadHandler 处理</span><br>            sc.read(buffer, buffer, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReadHandler</span>(sc));<br>            <span class="hljs-comment">// 写事件由 WriteHandler 处理</span><br>            sc.write(Charset.defaultCharset().encode(<span class="hljs-string">&quot;server hello!&quot;</span>), ByteBuffer.allocate(<span class="hljs-number">16</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">WriteHandler</span>(sc));<br>            <span class="hljs-comment">// 处理完第一个 accpet 时，需要再次调用 accept 方法来处理下一个 accept 事件</span><br>            ssc.accept(<span class="hljs-literal">null</span>, <span class="hljs-built_in">this</span>);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">failed</span><span class="hljs-params">(Throwable exc, Object attachment)</span> &#123;<br>            exc.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>javase</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>javase</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>跳表</title>
    <link href="/algorithm-efec1a8327be/"/>
    <url>/algorithm-efec1a8327be/</url>
    
    <content type="html"><![CDATA[<h1>跳表</h1><h2 id="概述">概述</h2><p>跳表（Skip List）是一种数据结构，用于在 <strong>有序元素</strong> 的集合中进行 <strong>快速查找、插入和删除操作</strong>。跳表的设计灵感源自平衡树，但相比之下，跳表的实现相对简单，在某些情况下可以在时间复杂度上达到与平衡树类似的性能。</p><p>跳表的核心思想是 <strong>通过在多个层上引入 “跳跃” 操作来加速查找</strong>。每个元素在最底层上都存在，而更高层的节点则通过跳跃链接连接到底层节点，形成类似于塔状的结构。这些跳跃链接允许在查找时跳过一些节点，从而减少查找的时间。</p><p>基本跳表的性质如下：</p><ol><li>每个元素都包含在底层（第 0 层）。</li><li>每一层的元素是从底层元素按照 <strong>某种概率随机提升</strong> 的结果，通常是按照一定的规则或概率选择提升。</li><li>最低层包含所有元素。</li><li>跳表的每一层都是一个有序链表，且相邻元素在不同层次之间具有跳跃链接。</li></ol><p>跳表的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，在某些情况下可以在查找操作上与平衡树（如红黑树）媲美。虽然跳表的实现相对简单，但它需要维护合适的平衡，以确保性能。跳表在高性能的数据结构中被广泛应用，特别是在需要高效查找的情况下。</p><h2 id="基本思想">基本思想</h2><p>跳表是一种类似于链表的数据结构，更加准确的说，跳表是对有序链表的改进。为方便讨论，后续所有有序链表默认为 <strong>升序</strong> 排序。</p><p>一个有序链表的查找操作，从头部开始逐个比较，直到当前节点的值大于或等于目标节点的值。很明显，这个操作的复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</p><p>跳表在有序链表的基础上，引入了 <strong>分层</strong> 的概念。</p><p>首先，跳表的每一层都是一个有序链表，特别地，最底层是完全的有序链表。每个位于第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 层的节点有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span> 的概率出现在第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7429em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 层，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span> 为常数。</p><p>在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个节点的跳表中，包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mi>p</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{p}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3262em;vertical-align:-0.4811em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4811em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 个元素的层为第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 层，易得 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mfrac><mn>1</mn><mi>p</mi></mfrac></msub><mi>n</mi></mrow><annotation encoding="application/x-tex">L(n)=log_{\frac{1}{p}}n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2787em;vertical-align:-0.5842em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.7538em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span style="top:-3.2255em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4829em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5842em;"><span></span></span></span></span></span></span><span class="mord mathnormal">n</span></span></span></span>。</p><p>在跳表中查找，就是从第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 层开始，水平地逐个比较直至当前节点的下一个节点大于等于目标节点，然后移动至下一层。重复这个过程直至到达第一层且无法继续进行操作。此时，若下一个节点是目标节点，则成功查找，反之，则元素不存在。这样一来，查找的过程中会跳过一些没有必要的比较，所以相比于有序链表的查询，跳表的查询更快。可以证明，跳表查询的平均复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</p><h2 id="简单理解">简单理解</h2><p>总的来说，跳表是 <strong>可以实现二分查找的有序链表</strong>。</p><p>下图是一个简单的 <strong>有序单链表</strong>，单链表的特性就是每个元素存放下一个元素的引用。即通过第一个元素可以找到第二个元素，通过第二个元素可以找到第三个元素，依次类推，直到找到最后一个元素。</p><p><img src="/algorithm-efec1a8327be/image-20240116222915643.png" alt="普通链表"></p><p>假设要找上图链表中的 10，只能从头开始遍历链表，直到找到 10。查找路径：1、3、4、5、7、8、9、10。</p><p>查找效率较低，平均时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。如何提高链表的查找速度？如下图所示，从链表中每两个元素抽出来，加一级索引，一级索引指向了原始链表，即通过一级索引 7 的 down 指针可以找到原始链表的 7。那现在怎么查找 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>10</mn></mrow><annotation encoding="application/x-tex">10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">10</span></span></span></span> 这个元素呢？</p><p><img src="/algorithm-efec1a8327be/image-20240116223304203.png" alt="一级索引"></p><p>先在第一级索引找 1、4、7、9，遍历到一级索引的 9 时，发现 9 的后继节点是 13，比 10 大，停止向后，通过 9 找到原始链表的 9，然后再往后遍历找到了要找的 10，遍历结束。加了一级索引后，查找路径：1、4、7、9、10，查找节点需要遍历的元素相对少了，不需要对 10 之前的所有数据都遍历，查找的效率提升了。</p><p>那如果加二级索引呢？如下图所示，查找路径：1、7、9、10。这就是跳表的思想，用 “空间换时间”，通过给链表建立索引，提高了查找的效率。</p><p><img src="/algorithm-efec1a8327be/image-20240116223516241.png" alt="二级索引"></p><p>从上面例子来看，提升的效率并不明显，本来需要遍历 8 个元素，优化了半天，还需要遍历 4 个元素，这是因为数据量太少了，当数据量足够大时，效率提升会很大。</p><p>如下图所示，假如有序单链表现在有 10000 个元素，分别是 0 ~ 9999。建了很多级索引，最高级的索引，就两个元素 0、5000，次高级索引四个元素 0、2500、5000、7500，依次类推，当查找 7890 这个元素时，查找路径为 0、5000、7500、…、7890，通过最高级索引直接跳过了 5000 个元素，次高层索引直接跳过了 2500 个元素，<strong>从而使得链表能够实现二分查找</strong>。由此可以看出，当元素数量较多时，索引提高的效率比较大，近似于二分查找。</p><p><img src="/algorithm-efec1a8327be/image-20240116224724285.png" alt="元素较多"></p><h2 id="复杂度分析">复杂度分析</h2><h3 id="时间复杂度">时间复杂度</h3><p>查找元素的过程是从最高层开始，一层一层遍历最后下沉到原始链表。所以，时间复杂度 = 跳表的高度 × 每一层遍历元素的个数。</p><p>假设每两个节点会抽出一个节点作为更上一层的节点。</p><p>原始的链表有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个元素，则一级索引有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">n/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord">/2</span></span></span></span> 个元素、二级索引有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mn>4</mn></mrow><annotation encoding="application/x-tex">n/4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord">/4</span></span></span></span> 个元素、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 级索引就有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi mathvariant="normal">/</mi><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">n/2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0991em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord">/</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span> 个元素。最高级索引一般有 2 个元素，即最高级索引 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span></span></span></span> 满足 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>=</mo><mi>n</mi><mi mathvariant="normal">/</mi><msup><mn>2</mn><mi>h</mi></msup></mrow><annotation encoding="application/x-tex">2 = n/2^h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0991em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord">/</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span></span></span></span></span></span></span></span>，即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo>=</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">h = log_2n - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，最高级索引 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span></span></span></span> 为索引层的高度加上原始数据一层，跳表的总高度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo>=</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi></mrow><annotation encoding="application/x-tex">h = log_2n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">n</span></span></span></span>。</p><p>若每两个节点抽出一个节点作为更上一层的节点时，每一层最多遍历 3 个节点（自行证明），所以时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><h3 id="空间复杂度">空间复杂度</h3><p>跳表通过建立索引，来提高查找元素的效率，典型的&quot;空间换时间&quot;的思想，所以在空间上做了一些牺牲。</p><p>假如原始链表包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个元素</p><p>如果每两个节点抽一个节点作为索引，则一级索引元素个数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">n/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord">/2</span></span></span></span>、二级索引元素个数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mn>4</mn></mrow><annotation encoding="application/x-tex">n/4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord">/4</span></span></span></span>、三级索引元素个数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mn>8</mn></mrow><annotation encoding="application/x-tex">n/8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord">/8</span></span></span></span> 以此类推。所以，索引节点的总和是：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>+</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>4</mn><mo>+</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>8</mn><mo>+</mo><mo>…</mo><mo>+</mo><mn>8</mn><mo>+</mo><mn>4</mn><mo>+</mo><mn>2</mn><mo>=</mo><mi>n</mi><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">n/2 + n/4 + n/8 + … + 8 + 4 + 2 = n-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord">/2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord">/4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord">/8</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span>，<strong>空间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></strong>。</p><p>如果每三个节点抽一个节点做为索引，索引总和数就是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mn>3</mn><mo>+</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>9</mn><mo>+</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>27</mn><mo>+</mo><mo>…</mo><mo>+</mo><mn>9</mn><mo>+</mo><mn>3</mn><mo>+</mo><mn>1</mn><mo>=</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">n/3 + n/9 + n/27 + … + 9 + 3 + 1= n/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord">/3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord">/9</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord">/27</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">9</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord">/2</span></span></span></span>，减少了一半。所以可以通过较少索引数来减少空间复杂度，但是相应的肯定会造成查找效率有一定下降，实际根据应用场景来控制这个阈值。</p><p>但是索引节点往往只需要存储 key 和几个指针，并不需要存储完整的对象，所以当对象比索引节点大很多时，索引占用的额外空间就可以忽略了。</p><p>举个例子：现在需要用跳表来给所有学生建索引，学生有很多属性：学号、姓名、性别、身份证号、年龄、家庭住址、身高、体重等。学生的各种属性只需要在原始链表中存储一份即可，只需要用学生的学号（<code>int</code> 类型的数据）建立索引，所以索引相对原始数据而言，占用的空间可以忽略。</p><h2 id="过程">过程</h2><h3 id="节点定义">节点定义</h3><p>下面是跳表节点的定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SkipNode</span> &#123;<br>    <span class="hljs-comment">// 节点的值</span><br>    <span class="hljs-type">int</span> value;<br>    <span class="hljs-comment">// 该节点的所有 next 指针</span><br>    SkipNode[] next;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SkipNode</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-built_in">this</span>.value = value;<br>        next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SkipNode</span>[MAX_LEVEL];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>下图中，每个圈出来的是一个节点，紫色的节点是 head 节点，每个节点维护一个 next 数组，next[level] 表示第 level 层的下一个节点，图中省略 next 中为 null 的指向。原始链表的 level 为 0。</p><p><img src="/algorithm-efec1a8327be/image-20240116225525481.png" alt="跳表"></p><h3 id="比-value-小的最右节点">比 value 小的最右节点</h3><blockquote><p>在【查找】、【新增】、【删除】方法中都会使用到该方法</p></blockquote><p>在整个跳表中查找比 value 小的最右边的节点，如下图，假设需要查找 value = 10，则比 value 小的最右边的节点就是 9。</p><p>其查找规则如下：</p><ul><li>若 next 指针为 null，或者 next 指向的节点值 nextVal ≥ value，则向下找</li><li>若 next 指针不为 null，且 next 指向的节点值 nextVal ＜ value，则向右找</li></ul><p>在这个过程中，使用一个 path 数组记录查找的过程并返回，以便后续进行【新增】和【删除】时更方便的插入节点。</p><p><img src="/algorithm-efec1a8327be/image-20240116225741911.png" alt="比 value 小的最右节点"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> SkipNode[] findLessSkipNode(<span class="hljs-type">int</span> value) &#123;<br>    <span class="hljs-comment">// 记录查找的路径, 方便后续进行新增和删除</span><br>    SkipNode[] path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SkipNode</span>[MAX_LEVEL];<br>    <span class="hljs-type">SkipNode</span> <span class="hljs-variable">curr</span> <span class="hljs-operator">=</span> head;<br>    <span class="hljs-comment">// 逐层往下</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">level</span> <span class="hljs-operator">=</span> MAX_LEVEL - <span class="hljs-number">1</span>; level &gt;= <span class="hljs-number">0</span>; level--) &#123;<br>        <span class="hljs-keyword">while</span> (curr.next[level] != <span class="hljs-literal">null</span> &amp;&amp; curr.next[level].value &lt; value) &#123;<br>            curr = curr.next[level];<br>        &#125;<br>        <span class="hljs-comment">// 记录路径</span><br>        path[level] = curr;<br>    &#125;<br>    <span class="hljs-keyword">return</span> path;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="查找">查找</h3><p>首先找到【比 value 小的最右节点】，即 path 路径数组的第一个元素（level = 0），该节点的下一个节点要么就是 value 节点，要么值大于 value 则没有 value 节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>    SkipNode[] path = findLessSkipNode(value);<br>    <span class="hljs-type">SkipNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> path[<span class="hljs-number">0</span>].next[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">return</span> node != <span class="hljs-literal">null</span> &amp;&amp; node.value == value;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="新增">新增</h3><p>跳表的原始链表需要保持有序，所以我们会向查找元素一样，找到元素应该插入的位置。</p><p>如下图所示，要插入数据 6，整个过程类似于查找 6，整个的查找路径为 1、4、5。查找到最底层原始链表的元素 5 时，发现 5 小于 6 但是后继节点 7 大于 6，所以应该把 6 插入到 5 之后 7 之前。</p><p><img src="/algorithm-efec1a8327be/image-20240116230003745.png" alt="插入 6"></p><p>但是，只将 6 插入到最底层就可以了吗？</p><p>假如一直向原始链表中插入数据，但是不更新上层的数据，那么在某一层中，会出现两个节点之间的数据非常多的情况，在极端情况下，跳表退化为单链表，查找效率变为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，所以需要维护上层的索引。</p><p>如何维护？</p><p>假如跳表每一层的晋升概率是 1/2，最理想的情况就是在原始链表中每隔一个元素抽取一个元素作为一级索引，也就是，在 <strong>原始链表中随机选择 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">n/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord">/2</span></span></span></span> 个元素作为一级索引，在一级索引中随机选择 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mn>4</mn></mrow><annotation encoding="application/x-tex">n/4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord">/4</span></span></span></span> 个元素作为二级索引 …</strong>。</p><p>虽然这样做是随机抽取的元素，不能达到每隔一个元素抽取一个元素的理想情况，极端情况，一级索引为原始链表的前一半元素，但是这样的概率太小，在原始链表中 <strong>元素数量足够多</strong> 且 <strong>抽取足够随机</strong> 的话，我们可以认为得到的索引是均匀的。</p><p>所以，可以维护一个这样的索引：<strong>随机选 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">n/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord">/2</span></span></span></span> 个元素做为一级索引、随机选 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mn>4</mn></mrow><annotation encoding="application/x-tex">n/4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord">/4</span></span></span></span> 个元素做为二级索引、随机选 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mn>8</mn></mrow><annotation encoding="application/x-tex">n/8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord">/8</span></span></span></span> 个元素做为三级索引，依次类推，一直到最顶层索引</strong>。这里每层索引的元素个数已经确定，且每层索引元素选取的足够随机，所以可以通过索引来提升跳表的查找效率。</p><p>如何实现？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">randomLevel</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">level</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// MAX_LEVEL 表示该跳表的最高层数</span><br>    <span class="hljs-comment">// SKIP_LIST 表示晋升概率</span><br>    <span class="hljs-keyword">while</span> (Math.random() &lt; SKIP_LIST &amp;&amp; level &lt; MAX_LEVEL) &#123;<br>        level++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> level;<br>&#125;<br></code></pre></td></tr></table></figure><p>晋升概率 <code>SKIP_LIST</code> 设置为 1/2，则每两个元素抽出一个元素作为上一级索引的节点。如果想节省空间利用率，可以适当的降低代码中的 <code>SKIP_LIST</code>，从而减少索引元素个数。</p><p>新增数据时维护索引的时间复杂度是多少呢？<strong>元素插入到单链表的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></strong>，索引的高度最多为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">logn</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span></span></span></span>，当插入一个元素 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 时，最坏的情况就是元素 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 需要插入到每层索引中，所以插入数据到各层索引中，最坏时间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</p><p>假设插入 6 时，它能晋升到二级索引，那么最终的跳表如图：</p><p><img src="/algorithm-efec1a8327be/image-20240116230141837.png" alt="最终结果"></p><p>所以，整个新增过程：</p><ol><li>首先随机一个节点所能晋升到的最高层数 level</li><li>从 0 到 level 依次创建节点，此时 path 数组发挥重要作用</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>    SkipNode[] path = findLessSkipNode(value);<br>    <span class="hljs-type">SkipNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SkipNode</span>(value);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">level</span> <span class="hljs-operator">=</span> randomLevel();<br>    <span class="hljs-comment">// 修改路径节点的 next 指针以及新增节点的 next 指针</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; level; i++) &#123;<br>        node.next[i] = path[i].next[i];<br>        path[i].next[i] = node;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="删除">删除</h3><p>跳表删除数据时，要把每一层中对应节点也要删掉。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">erase</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>    SkipNode[] path = findLessSkipNode(value);<br>    <span class="hljs-type">SkipNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> path[<span class="hljs-number">0</span>].next[<span class="hljs-number">0</span>];<br>    <span class="hljs-comment">// 没有找到 value 节点</span><br>    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span> || node.value != value) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; MAX_LEVEL; i++) &#123;<br>        <span class="hljs-keyword">if</span> (path[i].next[i] != node) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        path[i].next[i] = node.next[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>跳表中，删除元素的时间复杂度是多少呢？</p><p>删除元素的过程跟查找元素的过程类似，只不过在查找的路径上如果发现了要删除的元素 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>，则执行删除操作。跳表中，每一层其实都是一个有序的单链表，单链表删除元素的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，层数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">logn</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span></span></span></span> 则最多需要删除 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">logn</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span></span></span></span> 个元素，所以删除元素的总时间包含 <em>查找元素的时间</em> + <em>删除 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">logn</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span></span></span></span> 个元素的时间</em> 为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo><mo>+</mo><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn) + O(logn) = 2 O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，所以，时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</p><h2 id="模板代码">模板代码</h2>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-dc73f5fd" role="button" aria-expanded="false" aria-controls="collapse-dc73f5fd">        <div class="fold-arrow">▶</div>模板代码      </div>      <div class="fold-collapse collapse" id="collapse-dc73f5fd">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SkipList</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> <span class="hljs-variable">SKIP_LIST</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.5f</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_LEVEL</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">SkipNode</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SkipNode</span>(-<span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SkipNode</span> &#123;<br>        <span class="hljs-type">int</span> value;<br>        SkipNode[] next;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">SkipNode</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>            <span class="hljs-built_in">this</span>.value = value;<br>            next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SkipNode</span>[MAX_LEVEL];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> SkipNode[] findLessSkipNode(<span class="hljs-type">int</span> value) &#123;<br>        SkipNode[] path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SkipNode</span>[MAX_LEVEL];<br>        <span class="hljs-type">SkipNode</span> <span class="hljs-variable">curr</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">level</span> <span class="hljs-operator">=</span> MAX_LEVEL - <span class="hljs-number">1</span>; level &gt;= <span class="hljs-number">0</span>; level--) &#123;<br>            <span class="hljs-keyword">while</span> (curr.next[level] != <span class="hljs-literal">null</span> &amp;&amp; curr.next[level].value &lt; value) &#123;<br>                curr = curr.next[level];<br>            &#125;<br>            path[level] = curr;<br>        &#125;<br>        <span class="hljs-keyword">return</span> path;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        SkipNode[] path = findLessSkipNode(value);<br>        <span class="hljs-type">SkipNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> path[<span class="hljs-number">0</span>].next[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">return</span> node != <span class="hljs-literal">null</span> &amp;&amp; node.value == value;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        SkipNode[] path = findLessSkipNode(value);<br>        <span class="hljs-type">SkipNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SkipNode</span>(value);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">level</span> <span class="hljs-operator">=</span> randomLevel();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; level; i++) &#123;<br>            node.next[i] = path[i].next[i];<br>            path[i].next[i] = node;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">erase</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        SkipNode[] path = findLessSkipNode(value);<br>        <span class="hljs-type">SkipNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> path[<span class="hljs-number">0</span>].next[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span> || node.value != value) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; MAX_LEVEL; i++) &#123;<br>            <span class="hljs-keyword">if</span> (path[i].next[i] != node) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            path[i].next[i] = node.next[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">randomLevel</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">level</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (Math.random() &lt; SKIP_LIST &amp;&amp; level &lt; MAX_LEVEL) &#123;<br>            level++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> level;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>哈希表</title>
    <link href="/algorithm-53bff467bc4b/"/>
    <url>/algorithm-53bff467bc4b/</url>
    
    <content type="html"><![CDATA[<h1>HashTable</h1><h2 id="简介">简介</h2><p><strong>哈希表（Hash Table）</strong>：也叫散列表。是根据关键码值（Key）直接进行访问的数据结构。</p><p>哈希表通过键 key 和映射函数 Hash(key) 计算出对应的值 value，把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做哈希函数（散列函数），存放记录的数组叫做哈希表（散列表）。</p><p>哈希表的关键思想是使用哈希函数，将键 key 映射到对应表的某个区块中。将算法思想分为两个部分：</p><ul><li><strong>向哈希表中插入一个关键码值</strong>：哈希函数决定该关键字的对应值应该存放到表中的哪个区块，并将对应值存放到该区块中。</li><li><strong>在哈希表中搜索一个关键码值</strong>：使用相同的哈希函数从哈希表中查找对应的区块，并在特定的区块搜索该关键字对应的值。</li></ul><h2 id="哈希函数">哈希函数</h2><h3 id="简介-2">简介</h3><p>哈希（Hash）是指通过 <strong>哈希函数</strong> 将 <strong>输入数据</strong> 映射为 <strong>固定长度的输出</strong>，通常是一串 <strong>数字</strong> 和 <strong>字母</strong> 的组合。这个输出被称为哈希值，哈希值的长度是固定的，不受输入数据大小的影响。</p><p>哈希函数是一个算法，它将输入数据（例如文件、文本、密码等）转换为一个固定大小的字符串，通常是一段数字和字母的混合。哈希函数的设计要求尽可能地满足以下几个特点：</p><ol><li><strong>输入输出域</strong>：输入域可以认为是无穷的，而输出域相对有限（也可是无穷的）</li><li><strong>确定性</strong>：对于相同的输入，哈希函数总是产生 <strong>相同的哈希值</strong>。</li><li><strong>固定长度输出</strong>：哈希函数的输出长度是固定的，不管输入数据的大小如何。</li><li><strong>快速计算</strong>：哈希函数应该在合理的时间内计算出哈希值。</li><li><strong>预映射域均匀分布</strong>：优秀的哈希函数应该能够将输入数据在哈希值空间中 <strong>均匀分布</strong>，以减少 <strong>哈希碰撞</strong> 的可能性。哈希碰撞：在一个哈希函数中，不同输入映射到相同哈希值（输出）</li><li><strong>不可逆性</strong>：从哈希值无法轻易地推导出原始输入数据。好的哈希函数应该是单向的，即难以从哈希值还原出原始数据。</li><li><strong>抗碰撞性</strong>：哈希函数应该避免不同的输入映射到相同的哈希值，尽管无法完全避免碰撞，但优秀的哈希函数应该在实际应用中降低碰撞的可能性。</li><li><strong>雪崩效应</strong>：输入数据的微小变化应该导致哈希值的显著变化，这被称为雪崩效应。这有助于确保即使输入数据发生轻微更改，其哈希值也会截然不同。</li><li><strong>抗攻击性</strong>：好的哈希算法应该对常见的攻击如碰撞攻击、预像攻击、彩虹表攻击等具有较高的抵抗能力。</li></ol><p>哈希在计算机科学和密码学中具有广泛的应用，包括但不限于：</p><ul><li><strong>数据完整性验证</strong>：通过比较哈希值，可以验证数据是否在传输或存储过程中被篡改。</li><li><strong>密码存储</strong>：用户密码通常不会以明文形式存储，而是将其哈希后存储。当用户登录时，系统将输入密码进行哈希，并与存储的哈希值进行比较。</li><li><strong>数字签名</strong>：数字签名使用哈希函数和加密技术，以确保数据的来源和完整性。</li><li><strong>散列存储</strong>：哈希函数在散列表（HashTable）等数据结构中用于快速查找和访问数据。</li></ul><p>总之，哈希在计算中起着重要的作用，可以帮助保障数据的安全性、完整性和快速处理。</p><h3 id="常见哈希函数">常见哈希函数</h3><p>常见的哈希算法包括：</p><ol><li>MD5（Message Digest Algorithm 5）：MD5 是一种广泛使用的哈希算法，输出 128 位（16 字节）的哈希值。然而，由于其安全性不足，已经不推荐用于加密目的。</li><li>SHA-1（Secure Hash Algorithm 1）：SHA-1 产生 160 位（20 字节）的哈希值，也因为安全性问题逐渐被淘汰。</li><li>SHA-256（Secure Hash Algorithm 256）：SHA-256 是 SHA-2 家族的一部分，输出 256 位（32 字节）的哈希值，广泛用于加密和数据完整性验证。</li><li>SHA-3（Secure Hash Algorithm 3)）：SHA-3 是 SHA-2 之后发布的哈希算法标准，输出的哈希值长度可以是 224、256、384 或 512 位，提供更高的安全性。</li><li>bcrypt：bcrypt 是一种针对密码存储的哈希算法，通过加盐和多轮哈希来增加安全性，通常用于用户密码的加密存储。</li><li>scrypt：scrypt 是另一种专门用于密码存储的哈希函数，具有内存硬化（memory-hard）特性，增加了攻击者使用专用硬件攻击的难度。</li><li>SHAKE（SHA-3 SHAKE Extendable-Output Function）：SHAKE 允许指定不同的输出长度，提供更大范围的哈希值长度。</li></ol><p>这只是其中的一部分常见哈希算法，每种算法都有自己的优缺点和适用场景。在选择哈希算法时，应根据具体需求考虑其安全性、性能以及适用性。</p><p><strong>在 Java 类库（JDK 11）中支持的 hash 算法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.security.MessageDigest;<br><span class="hljs-keyword">import</span> java.security.NoSuchAlgorithmException;<br><span class="hljs-keyword">import</span> java.security.Security;<br><span class="hljs-keyword">import</span> java.util.Formatter;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JdkHash</span> &#123;<br>    <span class="hljs-keyword">private</span> MessageDigest hash;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">JdkHash</span><span class="hljs-params">(String algorithm)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            hash = MessageDigest.getInstance(algorithm);<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchAlgorithmException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">hashcode</span><span class="hljs-params">(String input)</span> &#123;<br>        <span class="hljs-type">Formatter</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Formatter</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">byte</span> b : hash.digest(input.getBytes())) &#123;<br>            f.format(<span class="hljs-string">&quot;%02x&quot;</span>, b);<br>        &#125;<br>        <span class="hljs-keyword">return</span> f.toString();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;支持的算法: &quot;</span>);<br>        <span class="hljs-keyword">for</span> (String messageDigest : Security.getAlgorithms(<span class="hljs-string">&quot;MessageDigest&quot;</span>)) &#123;<br>            System.out.print(messageDigest + <span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">支持的算法: <br>SHA3-<span class="hljs-number">512</span> SHA-<span class="hljs-number">1</span> SHA-<span class="hljs-number">384</span> SHA3-<span class="hljs-number">384</span> SHA-<span class="hljs-number">224</span> SHA-<span class="hljs-number">512</span>/<span class="hljs-number">256</span> SHA-<span class="hljs-number">256</span> MD2 SHA-<span class="hljs-number">512</span>/<span class="hljs-number">224</span> SHA3-<span class="hljs-number">256</span> SHA-<span class="hljs-number">512</span> MD5 SHA3-<span class="hljs-number">224</span><br></code></pre></td></tr></table></figure><h3 id="哈希冲突">哈希冲突</h3><h4 id="简介-3">简介</h4><p>对于不同的关键字 key，可能得到同一个哈希地址，即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mi>e</mi><mi>y</mi><mn>1</mn><mo mathvariant="normal">≠</mo><mi>k</mi><mi>e</mi><mi>y</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">key1 \neq key2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal" style="margin-right:0.03588em;">ey</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal" style="margin-right:0.03588em;">ey</span><span class="mord">2</span></span></span></span>，但是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mi>a</mi><mi>s</mi><mi>h</mi><mo stretchy="false">(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mi>h</mi><mi>a</mi><mi>s</mi><mi>h</mi><mo stretchy="false">(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">hash(key1)=hash(key2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ha</span><span class="mord mathnormal">s</span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal" style="margin-right:0.03588em;">ey</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ha</span><span class="mord mathnormal">s</span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal" style="margin-right:0.03588em;">ey</span><span class="mord">2</span><span class="mclose">)</span></span></span></span>，这种现象就称为 <strong>哈希冲突</strong>，也叫 <strong>哈希碰撞</strong>。</p><p>一般情况下，哈希冲突只能尽可能的减少，但不可能完全避免。因为哈希函数是从关键字集合到地址集合的映射，通常来说关键字集合比较大，它的元素理论上包括所有可能的关键字，而地址集合的元素仅为哈希表中的地址值。这就导致了哈希冲突的必然性。</p><p>下面以 <strong>除留取余法</strong> 作为哈希函数，来说明哈希碰撞。</p><p>假设 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>19</mn><mo separator="true">,</mo><mn>24</mn><mo separator="true">,</mo><mn>6</mn><mo separator="true">,</mo><mn>33</mn><mo separator="true">,</mo><mn>51</mn><mo separator="true">,</mo><mn>15</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[19,24,6,33,51,15]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">19</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">24</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">33</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">51</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">15</span><span class="mclose">]</span></span></span></span>，用散列存储的方式存储在一个长度为 11 的数组中，将这组数据分别模上数组的长度，以余数作为该元素在数组中的存储位置，则得到如下的哈希表：</p><p><img src="/algorithm-53bff467bc4b/image-20240116215739503.png" alt="哈希表"></p><p>若此时需要插入数据 72，经过哈希函数计算出索引为 6，但此时数组中 6 的位置已经被其他元素占据了，这就是 <strong>哈希冲突</strong>。</p><h4 id="开放定址法">开放定址法</h4><p>开放定址法是指当发生地址冲突时，按照某种方法继续探测哈希表中的其他存储单元，直到找到空位置为止。</p><p>72 模 11 后得到 6，而此时 6 的位置已经被其他元素占用了，那么将 6 加 1 得到 7， 此时发现 7 的位置也被占用了，那就再加 1 得到下一个地址为 8，而此时 8 仍然被占用，再接着加 1 得到 9，此时 9 处为空，则将 72 存入其中，即得到如下哈希表：</p><p><img src="/algorithm-53bff467bc4b/image-20240116215912273.png" alt="线性探测再散列"></p><p>像上边的这种探测方法称为 <strong>线性探测再散列</strong>。</p><p>当然除此之外还有 <strong>二次探测再散列</strong>，探测地址的方式为原哈希地址加上 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>d</mi><mo>=</mo><mo>±</mo><msup><mn>1</mn><mn>2</mn></msup><mo separator="true">,</mo><mo>±</mo><msup><mn>2</mn><mn>2</mn></msup><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mo>±</mo><msup><mi>m</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(d=\pm1^2,\pm2^2,...,\pm m^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord">±</span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">±</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">±</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，经过二次探测再散列后会得到求得 72 的哈希地址为 5，存储如下图所示：</p><p><img src="/algorithm-53bff467bc4b/image-20240116220032152.png" alt="二次探测再散列"></p><h4 id="再哈希法">再哈希法</h4><p>再哈希法即选取若干个不同的哈希函数，在产生哈希冲突的时候计算另一个哈希函数，直到不再发生冲突为止。</p><h4 id="建立公共溢出区">建立公共溢出区</h4><p>专门维护一个溢出表，当发生哈希冲突时，将值填入溢出表。</p><h4 id="拉链法">拉链法</h4><p>拉链法是指在碰到哈希冲突的时候，将冲突的元素以链表的形式进行存储。也就是凡是哈希地址为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 的元素都插入到同一个链表中，元素插入的位置可以是表头（<strong>头插法</strong>），也可以是表尾（<strong>尾插法</strong>）。</p><p>以一组新的数据 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>19</mn><mo separator="true">,</mo><mn>24</mn><mo separator="true">,</mo><mn>6</mn><mo separator="true">,</mo><mn>33</mn><mo separator="true">,</mo><mn>51</mn><mo separator="true">,</mo><mn>15</mn><mo separator="true">,</mo><mn>25</mn><mo separator="true">,</mo><mn>72</mn><mo separator="true">,</mo><mn>37</mn><mo separator="true">,</mo><mn>17</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>55</mn><mo separator="true">,</mo><mn>83</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[19,24,6,33,51,15,25,72,37,17,4,55,83]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">19</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">24</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">33</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">51</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">15</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">25</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">72</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">37</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">17</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">55</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">83</span><span class="mclose">]</span></span></span></span> 为例，使用 <strong>拉链法</strong> 解决哈希冲突的结果如下：</p><p><img src="/algorithm-53bff467bc4b/image-20240116220238449.png" alt="拉链法"></p><p>虽然拉链法是一种很好的处理哈希冲突的方法，但是在一些极端情况下也会出现问题，如这样一组数据 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>48</mn><mo separator="true">,</mo><mn>15</mn><mo separator="true">,</mo><mn>26</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>70</mn><mo separator="true">,</mo><mn>82</mn><mo separator="true">,</mo><mn>59</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[48,15,26,4,70,82,59]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">48</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">15</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">26</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">70</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">82</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">59</span><span class="mclose">]</span></span></span></span>，散列存储在长度为 11 的数组中：</p><p><img src="/algorithm-53bff467bc4b/image-20240116220550344.png" alt="退化为链表"></p><p>可以发现，此时的哈希表已经退化成了一个链表，在这样的数据结构中去查找某个元素的话，时间复杂度又变回了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，不符合预期。因此，当哈希表中的链表过长时就需要对其进行优化。</p><p>二叉查找树的查询效率是远远高于链表的。因此，当哈希表中的链表过长时可以把这个链表变成一棵红黑树。</p><p>上面的一组数据优化后可得到如下结果：</p><p><img src="/algorithm-53bff467bc4b/image-20240116220803208.png" alt="红黑树结构"></p><p>红黑树是一个可以自平衡的二叉查找树。它的查询的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。通过这样的优化可以提高哈希表的查询效率。</p><h3 id="hashCode">hashCode</h3><h4 id="Object-hashCode">Object.hashCode</h4><ul><li>Object 的 hashCode 方法默认是生成随机数作为 hash 值（会缓存在对象头当中）</li><li>包含相同 <strong>值</strong> 的不同对象，它们的 hashCode 不一样，不能够用 hash 值来反映对象的 <strong>值</strong> 特征，因此诸多子类都会重写 hashCode 方法</li></ul><h4 id="String-hashCode">String.hashCode</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> hash;<br>    <span class="hljs-keyword">if</span> (h == <span class="hljs-number">0</span> &amp;&amp; value.length &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">char</span> val[] = value;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; value.length; i++) &#123;<br>            h = <span class="hljs-number">31</span> * h + val[i];<br>            <span class="hljs-comment">// 优化 h = (h &lt;&lt; 5) - h + val[i]</span><br>        &#125;<br>        hash = h;<br>    &#125;<br>    <span class="hljs-keyword">return</span> h;<br>&#125;<br></code></pre></td></tr></table></figure><p>计算类似于：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>×</mo><mn>3</mn><msup><mn>1</mn><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>+</mo><mi>s</mi><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo>×</mo><mn>3</mn><msup><mn>1</mn><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow></msup><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><mi>s</mi><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">s[0] × 31 ^ {n - 1} + s[1] × 31 ^ {n - 2} + ... + s[n - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord">3</span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord">3</span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">...</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></p><ul><li>经验表明如果每次乘的是较大质数，可以有更好地降低 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mi>a</mi><mi>s</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">hash</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">ha</span><span class="mord mathnormal">s</span><span class="mord mathnormal">h</span></span></span></span> 冲突</li><li>【乘 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>31</mn></mrow><annotation encoding="application/x-tex">31</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">31</span></span></span></span>】可以等价为【乘 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>32</mn></mrow><annotation encoding="application/x-tex">32</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">32</span></span></span></span> - <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span></span></span></span>】，进一步可以转为更高效地【左移 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5</span></span></span></span> 位 - <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span></span></span></span>】</li></ul><h2 id="HashTable">HashTable</h2><h3 id="简介-4">简介</h3><p>下面实现一个简单的哈希表。</p><p>使用 <strong>拉链法</strong> 解决哈希冲突，底层由 <strong>数组（桶）加单链表</strong> 组成（和 Java 的 HashMap 类似）。</p><h3 id="节点">节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span> &#123;<br>    <span class="hljs-type">int</span> hash;<br>    Object key;<br>    Object value;<br>    Entry next;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Entry</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, Object key, Object value)</span> &#123;<br>        <span class="hljs-built_in">this</span>.hash = hash;<br>        <span class="hljs-built_in">this</span>.key = key;<br>        <span class="hljs-built_in">this</span>.value = value;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="哈希函数-2">哈希函数</h3><p>使用 Java 中 Object.hashCode 方法生成哈希值，该哈希值对底层数组的长度进行取模运算得到元素映射的桶的索引，在数组长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span> 的条件下，优化为 <strong>位运算</strong>，即</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>h</mi><mi>a</mi><mi>s</mi><mi>h</mi><mi mathvariant="normal">%</mi><mtext>数组长度</mtext><mo>=</mo><mi>h</mi><mi>a</mi><mi>s</mi><mi>h</mi><mi mathvariant="normal">&amp;</mi><mo stretchy="false">(</mo><mtext>数组长度</mtext><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">hash \%数组长度=hash\&amp;(数组长度-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8056em;vertical-align:-0.0556em;"></span><span class="mord mathnormal">ha</span><span class="mord mathnormal">s</span><span class="mord mathnormal">h</span><span class="mord">%</span><span class="mord cjk_fallback">数组长度</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ha</span><span class="mord mathnormal">s</span><span class="mord mathnormal">h</span><span class="mord">&amp;</span><span class="mopen">(</span><span class="mord cjk_fallback">数组长度</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span> &#123;<br>    <span class="hljs-keyword">return</span> key.hashCode() &amp; (table.length - <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="查找">查找</h3><ul><li>根据 <strong>哈希函数</strong> 找到该 key 所在的桶（若存在）</li><li>遍历该桶找到该 key 对应的 Entry 节点，返回其 value</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">get</span><span class="hljs-params">(Object key)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> hash(key);<br>    <span class="hljs-keyword">if</span> (table[idx] == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-type">Entry</span> <span class="hljs-variable">curr</span> <span class="hljs-operator">=</span> table[idx];<br>    <span class="hljs-keyword">while</span> (curr != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (curr.key.equals(key)) &#123;<br>            <span class="hljs-keyword">return</span> curr.value;<br>        &#125;<br>        curr = curr.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="新增">新增</h3><ul><li>根据 <strong>哈希函数</strong> 找到该 key 所在的桶（若存在）</li><li>将键和值封装在 Entry 节点挂在该桶下，若该桶已有节点则挂在该桶尾节点后面作为新的尾节点（尾插）</li><li>若键已存在则更新其值</li><li>若更新后 size 超过阈值（threshold）则需要扩容</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(Object key, Object value)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> hash(key);<br>    <span class="hljs-keyword">if</span> (table[idx] == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 直接新增</span><br>        table[idx] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(key.hashCode(), key, value);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 沿着链表查找, 若 key 已存在则更新, 否则新增</span><br>        <span class="hljs-type">Entry</span> <span class="hljs-variable">curr</span> <span class="hljs-operator">=</span> table[idx];<br>        <span class="hljs-keyword">while</span> (curr.next != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 更新</span><br>            <span class="hljs-keyword">if</span> (curr.key.equals(key)) &#123;<br>                curr.value = value;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            curr = curr.next;<br>        &#125;<br>        curr.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(key.hashCode(), key, value);<br>    &#125;<br>    size++;<br>    <span class="hljs-comment">// size 超过阈值则扩容</span><br>    <span class="hljs-keyword">if</span> (size &gt; threshold) &#123;<br>        grow();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="扩容">扩容</h3><p>在 <strong>哈希表</strong> 的每个桶，最多拆分为两个桶，即一个单链表最多拆分为两个单链表，可以按照下面的规则进行划分：</p><ul><li>若 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mi>a</mi><mi>s</mi><mi>h</mi><mi mathvariant="normal">&amp;</mi><mi>t</mi><mi>a</mi><mi>b</mi><mi>l</mi><mi>e</mi><mi mathvariant="normal">.</mi><mi>l</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>t</mi><mi>h</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">hash\&amp;table.length=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ha</span><span class="mord mathnormal">s</span><span class="mord mathnormal">h</span><span class="mord">&amp;</span><span class="mord mathnormal">t</span><span class="mord mathnormal">ab</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 为一组</li><li>若 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mi>a</mi><mi>s</mi><mi>h</mi><mi mathvariant="normal">&amp;</mi><mi>t</mi><mi>a</mi><mi>b</mi><mi>l</mi><mi>e</mi><mi mathvariant="normal">.</mi><mi>l</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>t</mi><mi>h</mi><mo mathvariant="normal">≠</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">hash\&amp;table.length \neq 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ha</span><span class="mord mathnormal">s</span><span class="mord mathnormal">h</span><span class="mord">&amp;</span><span class="mord mathnormal">t</span><span class="mord mathnormal">ab</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 为另一组</li></ul><p>每一次扩容的新的桶大小为原桶大小的 2 倍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">grow</span><span class="hljs-params">()</span> &#123;<br>    Entry[] newT = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>[table.length &lt;&lt; <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; table.length; i++) &#123;<br>        <span class="hljs-type">Entry</span> <span class="hljs-variable">curr</span> <span class="hljs-operator">=</span> table[i];<br>        <span class="hljs-keyword">if</span> (curr != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 拆分链表</span><br>            <span class="hljs-type">Entry</span> <span class="hljs-variable">pa</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-type">Entry</span> <span class="hljs-variable">pb</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-type">Entry</span> <span class="hljs-variable">headA</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-type">Entry</span> <span class="hljs-variable">headB</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">while</span> (curr != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> ((curr.hash &amp; table.length) == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (pa != <span class="hljs-literal">null</span>) &#123;<br>                        pa.next = curr;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        headA = curr;<br>                    &#125;<br>                    pa = curr;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">if</span> (pb != <span class="hljs-literal">null</span>) &#123;<br>                        pb.next = curr;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        headB = curr;<br>                    &#125;<br>                    pb = curr;<br>                &#125;<br>                curr = curr.next;<br>            &#125;<br>            <span class="hljs-comment">// pa 链表的位置不变, pb 链表的位置加上原 table.length 即可</span><br>            <span class="hljs-keyword">if</span> (pa != <span class="hljs-literal">null</span>) &#123;<br>                pa.next = <span class="hljs-literal">null</span>;<br>                newT[i] = headA;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (pb != <span class="hljs-literal">null</span>) &#123;<br>                pb.next = <span class="hljs-literal">null</span>;<br>                newT[i + table.length] = headB;<br>            &#125;<br>        &#125;<br>    &#125;<br>    table = newT;<br>    <span class="hljs-comment">// 更新阈值</span><br>    threshold = (<span class="hljs-type">int</span>) (loadFactor * table.length);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="删除">删除</h3><ul><li>根据 <strong>哈希函数</strong> 找到该 key 所在的桶（若存在）</li><li>遍历该桶找到该 key 对应的 Entry 节点，从单链表中删除该节点</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">remove</span><span class="hljs-params">(Object key)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> hash(key);<br>    <span class="hljs-keyword">if</span> (table[idx] == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-type">Entry</span> <span class="hljs-variable">curr</span> <span class="hljs-operator">=</span> table[idx];<br>    <span class="hljs-type">Entry</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">while</span> (curr != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (curr.key.equals(key)) &#123;<br>            <span class="hljs-keyword">if</span> (prev == <span class="hljs-literal">null</span>) &#123;<br>                table[idx] = curr.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                prev.next = curr.next;<br>            &#125;<br>            size--;<br>            <span class="hljs-keyword">return</span> curr.value;<br>        &#125;<br>        prev = curr;<br>        curr = curr.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="模板代码">模板代码</h3>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-a8163d0f" role="button" aria-expanded="false" aria-controls="collapse-a8163d0f">        <div class="fold-arrow">▶</div>模板代码      </div>      <div class="fold-collapse collapse" id="collapse-a8163d0f">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashTable</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span> &#123;<br>        <span class="hljs-type">int</span> hash;<br>        Object key;<br>        Object value;<br>        Entry next;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Entry</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, Object key, Object value)</span> &#123;<br>            <span class="hljs-built_in">this</span>.hash = hash;<br>            <span class="hljs-built_in">this</span>.key = key;<br>            <span class="hljs-built_in">this</span>.value = value;<br>        &#125;<br>    &#125;<br><br>    Entry[] table = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>[<span class="hljs-number">16</span>];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">float</span> <span class="hljs-variable">loadFactor</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.75f</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">threshold</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) (loadFactor * table.length);<br><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">get</span><span class="hljs-params">(Object key)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> hash(key);<br>        <span class="hljs-keyword">if</span> (table[idx] == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-type">Entry</span> <span class="hljs-variable">curr</span> <span class="hljs-operator">=</span> table[idx];<br>        <span class="hljs-keyword">while</span> (curr != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (curr.key.equals(key)) &#123;<br>                <span class="hljs-keyword">return</span> curr.value;<br>            &#125;<br>            curr = curr.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(Object key, Object value)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> hash(key);<br>        <span class="hljs-keyword">if</span> (table[idx] == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 直接新增</span><br>            table[idx] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(key.hashCode(), key, value);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 沿着链表查找, 有重复的 key 则更新, 否则新增</span><br>            <span class="hljs-type">Entry</span> <span class="hljs-variable">curr</span> <span class="hljs-operator">=</span> table[idx];<br>            <span class="hljs-keyword">while</span> (curr.next != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (curr.key.equals(key)) &#123;<br>                    curr.value = value;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                curr = curr.next;<br>            &#125;<br>            curr.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(key.hashCode(), key, value);<br>        &#125;<br>        size++;<br>        <span class="hljs-comment">// size 超过阈值则扩容</span><br>        <span class="hljs-keyword">if</span> (size &gt; threshold) &#123;<br>            grow();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">remove</span><span class="hljs-params">(Object key)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> hash(key);<br>        <span class="hljs-keyword">if</span> (table[idx] == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-type">Entry</span> <span class="hljs-variable">curr</span> <span class="hljs-operator">=</span> table[idx];<br>        <span class="hljs-type">Entry</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span> (curr != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (curr.key.equals(key)) &#123;<br>                <span class="hljs-keyword">if</span> (prev == <span class="hljs-literal">null</span>) &#123;<br>                    table[idx] = curr.next;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    prev.next = curr.next;<br>                &#125;<br>                size--;<br>                <span class="hljs-keyword">return</span> curr.value;<br>            &#125;<br>            prev = curr;<br>            curr = curr.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">grow</span><span class="hljs-params">()</span> &#123;<br>        Entry[] newT = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>[table.length &lt;&lt; <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; table.length; i++) &#123;<br>            <span class="hljs-type">Entry</span> <span class="hljs-variable">curr</span> <span class="hljs-operator">=</span> table[i];<br>            <span class="hljs-keyword">if</span> (curr != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 拆分链表</span><br>                <span class="hljs-type">Entry</span> <span class="hljs-variable">pa</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>                <span class="hljs-type">Entry</span> <span class="hljs-variable">pb</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>                <span class="hljs-type">Entry</span> <span class="hljs-variable">headA</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>                <span class="hljs-type">Entry</span> <span class="hljs-variable">headB</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>                <span class="hljs-keyword">while</span> (curr != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">if</span> ((curr.hash &amp; table.length) == <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-keyword">if</span> (pa != <span class="hljs-literal">null</span>) &#123;<br>                            pa.next = curr;<br>                        &#125; <span class="hljs-keyword">else</span> &#123;<br>                            headA = curr;<br>                        &#125;<br>                        pa = curr;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-keyword">if</span> (pb != <span class="hljs-literal">null</span>) &#123;<br>                            pb.next = curr;<br>                        &#125; <span class="hljs-keyword">else</span> &#123;<br>                            headB = curr;<br>                        &#125;<br>                        pb = curr;<br>                    &#125;<br>                    curr = curr.next;<br>                &#125;<br>                <span class="hljs-comment">// pa 链表的位置不变, pb 链表的位置加上原 table.length 即可</span><br>                <span class="hljs-keyword">if</span> (pa != <span class="hljs-literal">null</span>) &#123;<br>                    pa.next = <span class="hljs-literal">null</span>;<br>                    newT[i] = headA;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (pb != <span class="hljs-literal">null</span>) &#123;<br>                    pb.next = <span class="hljs-literal">null</span>;<br>                    newT[i + table.length] = headB;<br>                &#125;<br>            &#125;<br>        &#125;<br>        table = newT;<br>        <span class="hljs-comment">// 更新阈值</span><br>        threshold = (<span class="hljs-type">int</span>) (loadFactor * table.length);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span> &#123;<br>        <span class="hljs-keyword">return</span> key.hashCode() &amp; (table.length - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h2 id="哈希相关">哈希相关</h2><h3 id="布隆过滤器">布隆过滤器</h3><h4 id="概述">概述</h4><p>布隆过滤器（BloomFilter）是一种 <strong>空间高效</strong> 的 <strong>概率型</strong> 数据结构，用于判断一个元素是否属于某个集合。经常被用于快速检查一个元素是否存在于大型数据集中，同时具有很低的内存消耗。</p><p>基本思想：使用 <strong>多个哈希函数</strong> 将元素映射到一个 <strong>位数组</strong> 中的 <strong>多个位置</strong>，每个哈希函数对应位数组的一个位置。当判断一个元素是否在集合中时，将这个元素经过哈希函数映射到位数组中的相应位置，如果所有对应的位都已经被置为 1，则可以大致判定元素可能在集合中，如果有任何一个位为 0，则可以确定元素肯定不在集合中。</p><p>布隆过滤器的优点在于它占用的内存非常小，适合处理大规模的数据集合，而且查询速度非常快。然而，它也有一些缺点：</p><ol><li><strong>误判率</strong>：由于哈希函数的映射和位数组的有限大小，布隆过滤器存在一定的误判率。<strong>即使一个元素没有在集合中，也有可能被误判为在集合中</strong>。</li><li><strong>删除困难</strong>：一旦元素被加入布隆过滤器，通常无法直接删除，因为删除一个元素可能会影响到其他元素的判断结果。</li><li><strong>无法存储具体信息</strong>：布隆过滤器只能告诉你元素可能在集合中，但不能存储元素的具体信息。</li></ol><p>布隆过滤器在很多应用场景中非常有用，例如：</p><ul><li>网络爬虫中用于快速判断一个 URL 是否已经被访问过。</li><li>数据库查询中用于减少对庞大数据库的查询次数。</li><li>分布式系统中用于判定某个数据是否已经同步过。</li><li>防止缓存穿透，过滤掉不存在的数据查询。</li></ul><p>布隆过滤器适合那些可以 <strong>容忍一定误判率</strong> 的场景，但不适合那些对于误判率要求较高的场景。</p><h4 id="实现原理">实现原理</h4><p>通常判断某个元素是否存在用的是什么？HashMap？将值映射到 HashMap 的 Key，然后在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 的时间复杂度内返回结果，效率很高。</p><p>但是 HashMap 的实现也有缺点，如存储容量高，考虑到负载因子的存在，通常空间是不能被用满的，而一旦值很多，多达上亿的时候，那 HashMap 占据的内存大小就变得很可观了。</p><p>若数据集存储在远程服务器上，本地服务接受输入，而数据集非常大，不可能一次性读进内存构建 HashMap 的时候，也会存在问题。</p><p>如果你可以容忍一定误判率，那么不访试试布隆过滤器，它相较于 HashMap 来说，有着极大的空间优化。</p><p>布隆过滤器是一个 bit 向量或者 bit 数组：</p><p><img src="/algorithm-53bff467bc4b/image-20231226091636681.png" alt="bit 向量"></p><p>如果要映射一个值到布隆过滤器中，需要使用多个不同的哈希函数生成多个哈希值，并将每个生成的哈希值指向的 bit 位置为 1，如针对值 “baidu” 和三个不同的哈希函数分别生成了哈希值 0、3、7，则上图转变为：</p><p><img src="/algorithm-53bff467bc4b/image-20231226091931703.png" alt="布隆过滤器"></p><p>再存一个值 “tencent”，如果哈希函数返回 2、3、6 的话，则：</p><p><img src="/algorithm-53bff467bc4b/image-20231226092132757.png" alt="布隆过滤器"></p><p>3 这个 bit 位由于两个值的哈希函数都返回了这个 bit 位，因此它被覆盖了。</p><p>现在查询 “ocsio” 这个值是否存在，哈希函数返回了 0、4、7 三个值，结果发现 4 这个 bit 位上的值为 0，<strong>说明没有任何一个值映射到这个 bit 位上</strong>，因此可以很明确地说 “ocsio” 这个值不存在。</p><p>而当查询 “baidu” 这个值是否存在，那么哈希函数必然会返回 0、3、7，检查发现这三个 bit 位上的值均为 1，那么可以说 “baidu” <strong>存在了么？答案是不可以，只能是 “baidu” 这个值可能存在。</strong></p><p>因为随着增加的值越来越多，被置为 1 的 bit 位也会越来越多，这样某个值如 “taobao” 即使没有被存储过，但是若哈希函数返回的三个 bit 位都被其他值置为了 1 ，那么程序还是会判断 “taobao” 这个值存在。</p><p>这也是布隆过滤器的 <strong>误判率</strong> 所在，即使一个元素没有在集合中，也可能被误判为在集合中。</p><h4 id="三个公式">三个公式</h4><p>布隆过滤器涉及到几个重要的公式，用于计算布隆过滤器所需的参数和性能指标：</p><p>1）<strong>位数组大小（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>）的计算</strong>：布隆过滤器使用一个位数组来存储数据，每个位表示一个位置的状态（1 或 0）。要存储 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个元素，假设期望的误判率为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span>，位数组大小 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 可以通过以下公式计算，向上取整：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>m</mi><mo>=</mo><mo>−</mo><mfrac><mrow><mi>n</mi><mo>×</mo><mi>l</mi><mi>n</mi><mtext>  </mtext><mi>p</mi></mrow><mrow><mo stretchy="false">(</mo><mi>l</mi><mi>n</mi><mtext>  </mtext><mn>2</mn><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow></mfrac></mrow><annotation encoding="application/x-tex">m=-\frac{n×ln\;p}{(ln\;2)^2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.3074em;vertical-align:-0.936em;"></span><span class="mord">−</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">2</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7401em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>2）<strong>哈希函数个数（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>）的计算</strong></p><p>布隆过滤器使用多个哈希函数来将元素映射到位数组中的多个位置。哈希函数的个数可以通过以下公式计算：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>k</mi><mo>=</mo><mi>l</mi><mi>n</mi><mtext>  </mtext><mn>2</mn><mo>×</mo><mfrac><mi>m</mi><mi>n</mi></mfrac></mrow><annotation encoding="application/x-tex">k = ln\;2 ×\frac{m}{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.7936em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1076em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 是位数组大小，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 是要存储的元素个数。</p><p>3）<strong>实际误判率（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span>）的计算</strong></p><p>布隆过滤器的实际误判率取决于位数组大小、哈希函数个数以及要存储的元素个数。可以通过以下公式估计实际误判率：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>P</mi><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><msup><mi>e</mi><mrow><mo>−</mo><mfrac><mrow><mi>n</mi><mi>k</mi></mrow><mi>m</mi></mfrac></mrow></msup><msup><mo stretchy="false">)</mo><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">P= (1-e^{-\frac{nk}{m}})^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.279em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.029em;"><span style="top:-3.413em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.88em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span style="top:-3.2255em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">nk</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span></span></p><p>其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 是哈希函数个数，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 是要存储的元素个数，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 是位数组大小。</p><p>这些公式提供了布隆过滤器的一些理论指导，但实际应用中可能会受到哈希函数的质量、实际数据分布等因素的影响，因此实际性能可能会略有偏差。</p><p><strong>如何获取 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 个哈希函数？</strong></p><p>在布隆过滤器中，选择适当的哈希函数个数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 是一个重要的考虑因素，它会影响到误判率和性能。合适的哈希函数个数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 可以通过以下方法来选择：</p><ol><li><strong>独立的哈希函数</strong>：选择多个相互独立的哈希函数。这些哈希函数应该能够均匀地将元素映射到位数组中的不同位置，以减少碰撞的可能性。常见的哈希函数有散列函数（如 MD5、SHA-1、SHA-256 等）。</li><li><strong>多次哈希</strong>：通过多次应用同一个哈希函数并引入不同的种子值，产生多个哈希值。这样可以模拟多个独立的哈希函数。例如，对于一种哈希函数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span></span></span></span>，可以计算 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mn>1</mn></msub><mo>=</mo><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>s</mi><mi>e</mi><mi>e</mi><mi>d</mi><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h_1=h(x, seed1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">see</span><span class="mord mathnormal">d</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mn>2</mn></msub><mo>=</mo><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>s</mi><mi>e</mi><mi>e</mi><mi>d</mi><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h_2=h(x,seed2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">see</span><span class="mord mathnormal">d</span><span class="mord">2</span><span class="mclose">)</span></span></span></span> 等多个哈希值。</li><li><strong>取模操作</strong>：每个哈希值计算出一个位置，这个位置可能超过位数组的大小。通过对位置进行取模操作，将其映射到位数组的范围内。这样可以保证哈希值的范围在位数组大小之内。</li></ol><p>常见的做法是结合多个哈希函数，如选择一组独立的哈希函数，每个函数对输入进行不同的变换，并取模映射到位数组的范围内。</p><p>总之，选择哈希函数个数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 需要考虑实际应用的误判率要求和性能。较大的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 值可以减少误判率，但会增加计算成本，较小的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 值可能会导致较高的误判率。通常情况下，根据误判率和数据规模，选择适当的哈希函数个数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 可以在误判率和性能之间取得平衡。</p><h3 id="一致性哈希">一致性哈希</h3><p>一致性哈希（Consistent Hashing）是一种用于 <strong>分布式系统</strong> 中数据分片和负载均衡的算法。它的目标是在节点的增加、减少或故障恢复等情况下，最小化数据迁移，同时保持负载均衡。</p><p>在传统的哈希算法中，当节点数量发生变化时，需要重新计算哈希值，导致大量数据的重新映射。这在分布式环境中可能会导致性能问题和数据迁移的开销。而一致性哈希算法通过引入虚拟节点（也称为虚拟副本或虚拟节点副本）的概念，可以在节点变动时减少数据迁移。</p><p>基本思想是将节点和数据都映射到一个相同的环上，环的范围是一个哈希函数的输出空间。每个节点在环上占据一个位置，数据根据哈希函数映射到环上的一个位置。当数据需要被存储或查找时，根据其哈希值找到环上最近的节点，然后在该节点上进行存储或查找操作。</p><p>一致性哈希具有以下特点：</p><ol><li><strong>节点的平衡性</strong>：节点在环上均匀分布，确保负载均衡，因为每个节点只负责环上它与其前一个节点之间的数据区间。</li><li><strong>扩展性</strong>：当节点数量变化时，只会影响到环上少部分数据，大部分数据仍然映射到相同的节点，从而减少数据迁移。</li><li><strong>节点故障的影响减小</strong>：节点故障时，只会影响到环上故障节点的数据区间，而不会影响到其他节点的数据。</li><li><strong>简单性</strong>：一致性哈希算法相对于其他分布式哈希算法来说，实现相对较简单。</li></ol><p>注意，虽然一致性哈希算法在解决分布式负载均衡和节点变化时的数据迁移问题上具有优势，但也可能导致数据分布不够均匀或热点问题。为解决这些问题，提出了一些改进的一致性哈希算法，如带虚拟节点的一致性哈希等。</p><p><strong>带虚拟节点的一致性哈希</strong></p><p>虚拟节点的一致性哈希（Virtual Node Consistent Hashing）是一种对传统一致性哈希算法的改进，旨在解决节点分布不均匀和负载不平衡等问题。</p><p>传统一致性哈希算法中，每个节点只在环上占据一个位置，数据根据哈希函数映射到环上的一个位置，然后根据节点位置存储或查找数据。然而，在某些情况下，节点的分布可能不均匀，导致某些节点负载较重，而其他节点负载较轻。</p><p>虚拟节点的一致性哈希通过引入虚拟节点的概念来解决这个问题。每个实际的物理节点会被映射到多个虚拟节点的位置上，这样就能够更均匀地分布节点，从而减少负载不平衡的问题。虚拟节点在环上的位置可以通过将物理节点的名称与某个数字或索引进行组合而得到。这样，每个物理节点会占据多个虚拟节点的位置，从而在环上分布更均匀。</p><p>虚拟节点的一致性哈希具有以下优点：</p><ol><li><strong>负载均衡</strong>：虚拟节点的引入可以更好地均匀分布数据，从而减少节点负载不平衡。</li><li><strong>节点扩展和收缩的影响减小</strong>：当节点数量变化时，只会影响到少数虚拟节点的位置，而不会影响到所有数据。</li><li><strong>简化数据迁移</strong>：节点的添加或删除时，只需调整虚拟节点的位置，从而减少实际数据的迁移。</li></ol><p>使用虚拟节点的一致性哈希需要在实现中对节点的映射进行适当的调整。每个节点可以映射到多个虚拟节点，然后在查询时，根据哈希函数找到最近的虚拟节点，进而定位到实际的物理节点。</p><p>虚拟节点的一致性哈希算法提供了更好的负载均衡和节点变动时的灵活性，使分布式系统能够更有效地应对节点变化和负载变化。</p>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
